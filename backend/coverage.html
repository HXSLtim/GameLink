
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">gamelink/cmd/main.go (2.8%)</option>
				
				<option value="file1">gamelink/docs/docs.go (100.0%)</option>
				
				<option value="file2">gamelink/internal/auth/jwt.go (60.0%)</option>
				
				<option value="file3">gamelink/internal/cache/cache.go (100.0%)</option>
				
				<option value="file4">gamelink/internal/cache/memory.go (85.4%)</option>
				
				<option value="file5">gamelink/internal/cache/redis.go (37.5%)</option>
				
				<option value="file6">gamelink/internal/config/database.go (100.0%)</option>
				
				<option value="file7">gamelink/internal/config/env.go (56.2%)</option>
				
				<option value="file8">gamelink/internal/config/validate.go (100.0%)</option>
				
				<option value="file9">gamelink/internal/db/db.go (50.0%)</option>
				
				<option value="file10">gamelink/internal/db/migrate.go (60.1%)</option>
				
				<option value="file11">gamelink/internal/db/postgres.go (0.0%)</option>
				
				<option value="file12">gamelink/internal/db/seed.go (79.9%)</option>
				
				<option value="file13">gamelink/internal/db/sqlite.go (64.1%)</option>
				
				<option value="file14">gamelink/internal/handler/admin/commission.go (0.0%)</option>
				
				<option value="file15">gamelink/internal/handler/admin/dashboard.go (79.2%)</option>
				
				<option value="file16">gamelink/internal/handler/admin/game.go (46.8%)</option>
				
				<option value="file17">gamelink/internal/handler/admin/helpers.go (77.5%)</option>
				
				<option value="file18">gamelink/internal/handler/admin/item.go (0.0%)</option>
				
				<option value="file19">gamelink/internal/handler/admin/order.go (33.2%)</option>
				
				<option value="file20">gamelink/internal/handler/admin/permission.go (61.4%)</option>
				
				<option value="file21">gamelink/internal/handler/admin/player.go (44.4%)</option>
				
				<option value="file22">gamelink/internal/handler/admin/ranking.go (0.0%)</option>
				
				<option value="file23">gamelink/internal/handler/admin/review.go (20.0%)</option>
				
				<option value="file24">gamelink/internal/handler/admin/role.go (62.7%)</option>
				
				<option value="file25">gamelink/internal/handler/admin/router.go (0.0%)</option>
				
				<option value="file26">gamelink/internal/handler/admin/stats.go (0.0%)</option>
				
				<option value="file27">gamelink/internal/handler/admin/stats_handler.go (0.0%)</option>
				
				<option value="file28">gamelink/internal/handler/admin/system.go (0.0%)</option>
				
				<option value="file29">gamelink/internal/handler/admin/system_handler.go (0.0%)</option>
				
				<option value="file30">gamelink/internal/handler/admin/user.go (45.6%)</option>
				
				<option value="file31">gamelink/internal/handler/admin/withdraw.go (0.0%)</option>
				
				<option value="file32">gamelink/internal/handler/auth.go (80.4%)</option>
				
				<option value="file33">gamelink/internal/handler/health.go (100.0%)</option>
				
				<option value="file34">gamelink/internal/handler/middleware/auth.go (100.0%)</option>
				
				<option value="file35">gamelink/internal/handler/middleware/cors.go (97.1%)</option>
				
				<option value="file36">gamelink/internal/handler/middleware/crypto.go (70.4%)</option>
				
				<option value="file37">gamelink/internal/handler/middleware/error_map.go (56.7%)</option>
				
				<option value="file38">gamelink/internal/handler/middleware/jwt_auth.go (93.2%)</option>
				
				<option value="file39">gamelink/internal/handler/middleware/metrics.go (100.0%)</option>
				
				<option value="file40">gamelink/internal/handler/middleware/permission.go (0.0%)</option>
				
				<option value="file41">gamelink/internal/handler/middleware/permission_sync.go (0.0%)</option>
				
				<option value="file42">gamelink/internal/handler/middleware/rate_limit.go (100.0%)</option>
				
				<option value="file43">gamelink/internal/handler/middleware/recovery.go (100.0%)</option>
				
				<option value="file44">gamelink/internal/handler/middleware/request_id.go (91.7%)</option>
				
				<option value="file45">gamelink/internal/handler/middleware/slog_logger.go (0.0%)</option>
				
				<option value="file46">gamelink/internal/handler/middleware/validation.go (94.9%)</option>
				
				<option value="file47">gamelink/internal/handler/player/commission.go (0.0%)</option>
				
				<option value="file48">gamelink/internal/handler/player/earnings.go (55.3%)</option>
				
				<option value="file49">gamelink/internal/handler/player/gift.go (0.0%)</option>
				
				<option value="file50">gamelink/internal/handler/player/helpers.go (77.8%)</option>
				
				<option value="file51">gamelink/internal/handler/player/order.go (46.6%)</option>
				
				<option value="file52">gamelink/internal/handler/player/profile.go (60.4%)</option>
				
				<option value="file53">gamelink/internal/handler/root.go (0.0%)</option>
				
				<option value="file54">gamelink/internal/handler/swagger.go (0.0%)</option>
				
				<option value="file55">gamelink/internal/handler/user/gift.go (0.0%)</option>
				
				<option value="file56">gamelink/internal/handler/user/helpers.go (100.0%)</option>
				
				<option value="file57">gamelink/internal/handler/user/order.go (30.4%)</option>
				
				<option value="file58">gamelink/internal/handler/user/payment.go (65.9%)</option>
				
				<option value="file59">gamelink/internal/handler/user/player.go (57.1%)</option>
				
				<option value="file60">gamelink/internal/handler/user/review.go (51.5%)</option>
				
				<option value="file61">gamelink/internal/logging/ctx.go (0.0%)</option>
				
				<option value="file62">gamelink/internal/logging/logger.go (70.0%)</option>
				
				<option value="file63">gamelink/internal/metrics/gorm.go (0.0%)</option>
				
				<option value="file64">gamelink/internal/metrics/metrics.go (100.0%)</option>
				
				<option value="file65">gamelink/internal/model/commission.go (100.0%)</option>
				
				<option value="file66">gamelink/internal/model/currency.go (100.0%)</option>
				
				<option value="file67">gamelink/internal/model/financial.go (100.0%)</option>
				
				<option value="file68">gamelink/internal/model/order.go (100.0%)</option>
				
				<option value="file69">gamelink/internal/model/order_helper.go (100.0%)</option>
				
				<option value="file70">gamelink/internal/model/permission.go (0.0%)</option>
				
				<option value="file71">gamelink/internal/model/ranking.go (0.0%)</option>
				
				<option value="file72">gamelink/internal/model/rating.go (83.3%)</option>
				
				<option value="file73">gamelink/internal/model/role.go (100.0%)</option>
				
				<option value="file74">gamelink/internal/model/role_permission.go (0.0%)</option>
				
				<option value="file75">gamelink/internal/model/service_item.go (100.0%)</option>
				
				<option value="file76">gamelink/internal/model/social.go (0.0%)</option>
				
				<option value="file77">gamelink/internal/model/user_role.go (0.0%)</option>
				
				<option value="file78">gamelink/internal/model/withdraw.go (0.0%)</option>
				
				<option value="file79">gamelink/internal/repository/commission/repository.go (78.2%)</option>
				
				<option value="file80">gamelink/internal/repository/common/uow.go (100.0%)</option>
				
				<option value="file81">gamelink/internal/repository/game/repository.go (83.3%)</option>
				
				<option value="file82">gamelink/internal/repository/mocks/mocks.go (0.0%)</option>
				
				<option value="file83">gamelink/internal/repository/operation_log/repository.go (90.5%)</option>
				
				<option value="file84">gamelink/internal/repository/order/repository.go (89.1%)</option>
				
				<option value="file85">gamelink/internal/repository/pagination.go (100.0%)</option>
				
				<option value="file86">gamelink/internal/repository/payment/repository.go (88.4%)</option>
				
				<option value="file87">gamelink/internal/repository/permission/repository.go (69.0%)</option>
				
				<option value="file88">gamelink/internal/repository/player/repository.go (82.9%)</option>
				
				<option value="file89">gamelink/internal/repository/player_tag/repository.go (90.3%)</option>
				
				<option value="file90">gamelink/internal/repository/ranking/commission_repository.go (0.0%)</option>
				
				<option value="file91">gamelink/internal/repository/ranking/repository.go (0.0%)</option>
				
				<option value="file92">gamelink/internal/repository/review/repository.go (87.8%)</option>
				
				<option value="file93">gamelink/internal/repository/role/repository.go (74.5%)</option>
				
				<option value="file94">gamelink/internal/repository/serviceitem/repository.go (79.0%)</option>
				
				<option value="file95">gamelink/internal/repository/stats/repository.go (76.1%)</option>
				
				<option value="file96">gamelink/internal/repository/user/repository.go (85.7%)</option>
				
				<option value="file97">gamelink/internal/repository/withdraw/repository.go (78.0%)</option>
				
				<option value="file98">gamelink/internal/scheduler/settlement_scheduler.go (0.0%)</option>
				
				<option value="file99">gamelink/internal/service/admin/admin.go (59.9%)</option>
				
				<option value="file100">gamelink/internal/service/auth/auth.go (92.1%)</option>
				
				<option value="file101">gamelink/internal/service/commission/commission.go (49.7%)</option>
				
				<option value="file102">gamelink/internal/service/earnings/earnings.go (80.6%)</option>
				
				<option value="file103">gamelink/internal/service/gift/gift.go (87.0%)</option>
				
				<option value="file104">gamelink/internal/service/item/item.go (66.3%)</option>
				
				<option value="file105">gamelink/internal/service/order/order.go (76.6%)</option>
				
				<option value="file106">gamelink/internal/service/payment/payment.go (75.5%)</option>
				
				<option value="file107">gamelink/internal/service/permission/permission.go (88.1%)</option>
				
				<option value="file108">gamelink/internal/service/player/player.go (81.6%)</option>
				
				<option value="file109">gamelink/internal/service/ranking/ranking.go (0.0%)</option>
				
				<option value="file110">gamelink/internal/service/review/review.go (78.6%)</option>
				
				<option value="file111">gamelink/internal/service/role/mock_repository.go (0.0%)</option>
				
				<option value="file112">gamelink/internal/service/role/role.go (93.1%)</option>
				
				<option value="file113">gamelink/internal/service/stats/stats.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

// GameLink API
//
// @title           GameLink API
// @version         0.3.0
// @description     GameLink 平台 API，包含健康检查、认证与管理端能力。
// @BasePath        /api/v1
// @schemes         http https
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization

import (
        "context"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "github.com/gin-gonic/gin"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"

        "gamelink/internal/auth"
        "gamelink/internal/cache"
        "gamelink/internal/config"
        "gamelink/internal/db"
        "gamelink/internal/handler"
        adminhandler "gamelink/internal/handler/admin"
        "gamelink/internal/handler/middleware"
        playerhandler "gamelink/internal/handler/player"
        userhandler "gamelink/internal/handler/user"
        "gamelink/internal/logging"
        "gamelink/internal/model"
        commissionrepo "gamelink/internal/repository/commission"
        "gamelink/internal/repository/common"
        gamerepo "gamelink/internal/repository/game"
        orderrepo "gamelink/internal/repository/order"
        paymentrepo "gamelink/internal/repository/payment"
        permissionrepo "gamelink/internal/repository/permission"
        playerrepo "gamelink/internal/repository/player"
        playertagrepo "gamelink/internal/repository/player_tag"
        rankingrepo "gamelink/internal/repository/ranking"
        reviewrepo "gamelink/internal/repository/review"
        rolerepo "gamelink/internal/repository/role"
        serviceitemrepo "gamelink/internal/repository/serviceitem"
        statsrepo "gamelink/internal/repository/stats"
        userrepo "gamelink/internal/repository/user"
        withdrawrepo "gamelink/internal/repository/withdraw"
        "gamelink/internal/scheduler"
        adminservice "gamelink/internal/service/admin"
        authservice "gamelink/internal/service/auth"
        commissionservice "gamelink/internal/service/commission"
        earningsservice "gamelink/internal/service/earnings"
        giftservice "gamelink/internal/service/gift"
        itemservice "gamelink/internal/service/item"
        orderservice "gamelink/internal/service/order"
        paymentservice "gamelink/internal/service/payment"
        permissionservice "gamelink/internal/service/permission"
        playerservice "gamelink/internal/service/player"
        reviewservice "gamelink/internal/service/review"
        roleservice "gamelink/internal/service/role"
        statsservice "gamelink/internal/service/stats"
)

func main() <span class="cov0" title="0">{
        cfg := config.Load()
        if err := config.Validate(os.Getenv("APP_ENV"), cfg); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("配置校验失败: %v", err)
        }</span>
        <span class="cov0" title="0">if cfg.Crypto.Enabled </span><span class="cov0" title="0">{
                log.Printf("crypto middleware enabled, methods=%v exclude=%v use_signature=%v", cfg.Crypto.Methods, cfg.Crypto.ExcludePaths, cfg.Crypto.UseSignature)
        }</span> else<span class="cov0" title="0"> {
                log.Println("crypto middleware disabled")
        }</span>

        <span class="cov0" title="0">orm, err := db.Open(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("打开数据库失败: %v", err)
        }</span>
        <span class="cov0" title="0">sqlDB, err := orm.DB()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("获取底层连接失败: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := sqlDB.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("close db error: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">cacheClient, err := cache.New(cfg.Cache)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("初始化缓存失败: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := cacheClient.Close(context.Background()); err != nil </span><span class="cov0" title="0">{
                        log.Printf("close cache error: %v", err)
                }</span>
        }()

        // RBAC - 初始化 RoleRepository（需要在 AdminService 之前）
        <span class="cov0" title="0">roleRepo := rolerepo.NewRoleRepository(orm)

        adminSvc := adminservice.NewAdminService(
                gamerepo.NewGameRepository(orm),
                userrepo.NewUserRepository(orm),
                playerrepo.NewPlayerRepository(orm),
                orderrepo.NewOrderRepository(orm),
                paymentrepo.NewPaymentRepository(orm),
                roleRepo,
                cacheClient,
        )

        // Inject transaction manager for composite operations
        uow := common.NewUnitOfWork(orm)
        adminSvc.SetTxManager(uow)

        gin.SetMode(resolveGinMode())

        // 初始化结构化日志（slog），从 LOG_LEVEL 读取级别
        _ = logging.Init(os.Getenv("LOG_LEVEL"))

        router := gin.New()

        // 注册全局中间件（按顺序执行）
        router.Use(middleware.RequestID())
        router.Use(middleware.SlogLogger())        // 结构化访问日志
        router.Use(middleware.MetricsMiddleware()) // HTTP 指标
        router.Use(middleware.Crypto(cfg.Crypto))  // 请求解密（与前端 AES 中间件对齐）
        router.Use(middleware.ErrorMap())          // 统一错误映射（ErrValidation/ErrNotFound）
        router.Use(middleware.Recovery())          // 统一JSON恢复中间件
        router.Use(middleware.CORS())              // CORS中间件（跨域处理）

        // Register root and health on both base and versioned API for compatibility
        handler.RegisterRoot(router)
        handler.RegisterHealth(router)

        // Versioned API group
        api := router.Group("/api/v1")
        handler.RegisterRoot(api)
        handler.RegisterHealth(api)

        // Metrics endpoint
        router.GET("/metrics", middleware.MetricsHandler())

        // Auth service and routes
        jwtSecret := strings.TrimSpace(cfg.Auth.JWTSecret)
        if jwtSecret == "" </span><span class="cov0" title="0">{
                if os.Getenv("APP_ENV") == "production" </span><span class="cov0" title="0">{
                        log.Fatal("JWT secret must be provided via configs.auth.jwt_secret or JWT_SECRET_KEY")
                }</span>
                <span class="cov0" title="0">jwtSecret = config.DefaultDevJWTSecret</span>
        }
        <span class="cov0" title="0">tokenTTL := time.Duration(cfg.Auth.TokenTTLHours) * time.Hour
        if tokenTTL &lt;= 0 </span><span class="cov0" title="0">{
                tokenTTL = 24 * time.Hour
        }</span>
        <span class="cov0" title="0">jwtMgr := auth.NewJWTManager(jwtSecret, tokenTTL)
        authSvc := authservice.NewAuthService(userrepo.NewUserRepository(orm), jwtMgr)
        handler.RegisterAuthRoutes(api, authSvc)

        // Initialize repositories (reuse where possible)
        userRepo := userrepo.NewUserRepository(orm)
        playerRepo := playerrepo.NewPlayerRepository(orm)
        gameRepo := gamerepo.NewGameRepository(orm)
        orderRepo := orderrepo.NewOrderRepository(orm)
        paymentRepo := paymentrepo.NewPaymentRepository(orm)
        reviewRepo := reviewrepo.NewReviewRepository(orm)
        playerTagRepo := playertagrepo.NewPlayerTagRepository(orm)
        withdrawRepo := withdrawrepo.NewWithdrawRepository(orm)
        commissionRepo := commissionrepo.NewCommissionRepository(orm)
        serviceItemRepo := serviceitemrepo.NewServiceItemRepository(orm)
        rankingCommissionRepo := rankingrepo.NewRankingCommissionRepository(orm)

        // Initialize user-side services
        commissionSvc := commissionservice.NewCommissionService(commissionRepo, orderRepo, playerRepo)
        serviceItemSvc := itemservice.NewServiceItemService(serviceItemRepo, gameRepo, playerRepo)
        giftSvc := giftservice.NewGiftService(serviceItemRepo, orderRepo, playerRepo, commissionRepo)
        orderSvc := orderservice.NewOrderService(orderRepo, playerRepo, userRepo, gameRepo, paymentRepo, reviewRepo, commissionRepo)
        paymentSvc := paymentservice.NewPaymentService(paymentRepo, orderRepo)
        playerSvc := playerservice.NewPlayerService(playerRepo, userRepo, gameRepo, orderRepo, reviewRepo, playerTagRepo, cacheClient)
        reviewSvc := reviewservice.NewReviewService(reviewRepo, orderRepo, playerRepo, userRepo)
        earningsSvc := earningsservice.NewEarningsService(playerRepo, orderRepo, withdrawRepo)

        // Initialize settlement scheduler
        settlementScheduler := scheduler.NewSettlementScheduler(commissionSvc)
        settlementScheduler.Start()
        defer settlementScheduler.Stop()

        // Register user-side routes (require authentication)
        authMiddleware := middleware.JWTAuth()
        userGroup := api.Group("/user")
        userGroup.Use(authMiddleware)
        </span><span class="cov0" title="0">{
                userhandler.RegisterOrderRoutes(userGroup, orderSvc, authMiddleware)
                userhandler.RegisterPaymentRoutes(userGroup, paymentSvc, authMiddleware)
                userhandler.RegisterPlayerRoutes(userGroup, playerSvc, authMiddleware)
                userhandler.RegisterReviewRoutes(userGroup, reviewSvc, authMiddleware)
                userhandler.RegisterGiftRoutes(userGroup, giftSvc, serviceItemSvc, authMiddleware)
        }</span>

        // Register player-side routes (require authentication)
        <span class="cov0" title="0">playerGroup := api.Group("/player")
        playerGroup.Use(authMiddleware)
        </span><span class="cov0" title="0">{
                playerhandler.RegisterProfileRoutes(playerGroup, playerSvc, authMiddleware)
                playerhandler.RegisterOrderRoutes(playerGroup, orderSvc, authMiddleware)
                playerhandler.RegisterEarningsRoutes(playerGroup, earningsSvc, authMiddleware)
                playerhandler.RegisterCommissionRoutes(playerGroup, commissionSvc, authMiddleware)
                playerhandler.RegisterGiftRoutes(playerGroup, giftSvc, authMiddleware)
        }</span>

        <span class="cov0" title="0">if cfg.EnableSwagger </span><span class="cov0" title="0">{
                log.Println("swagger endpoint enabled at /swagger")
                // Serve embedded OpenAPI v3 at /swagger and /swagger.json
                handler.RegisterSwagger(router)
                // Serve gin-swagger UI backed by /swagger.json for compatibility
                router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler, ginSwagger.URL("/swagger.json")))
        }</span> else<span class="cov0" title="0"> {
                log.Println("swagger endpoint disabled by configuration")
        }</span>

        // RBAC - 权限服务（RoleRepository 已在 AdminService 创建时初始化）
        <span class="cov0" title="0">permRepo := permissionrepo.NewPermissionRepository(orm)
        permService := permissionservice.NewPermissionService(permRepo, cacheClient)
        roleSvc := roleservice.NewRoleService(roleRepo, cacheClient)

        // 权限中间件
        permMiddleware := middleware.NewPermissionMiddleware(jwtMgr, permService, roleSvc)

        // Register admin routes under versioned prefix: /api/v1/admin（使用新的权限中间件）
        adminhandler.RegisterRoutes(api, adminSvc, permMiddleware)

        // Stats routes（使用新的权限中间件）
        statsSvc := statsservice.NewStatsService(statsrepo.NewStatsRepository(orm))
        adminhandler.RegisterStatsRoutes(api, statsSvc, permMiddleware)

        // System info routes（使用新的权限中间件）
        adminhandler.RegisterSystemRoutes(api, cfg, sqlDB, cacheClient, permMiddleware)

        // 注册角色和权限管理路由（使用细粒度权限控制）
        roleHandler := adminhandler.NewRoleHandler(roleSvc)
        permHandler := adminhandler.NewPermissionHandler(permService)

        // RBAC routes
        rbacGroup := api.Group("/admin")
        rbacGroup.Use(permMiddleware.RequireAuth()) // 所有 RBAC 接口需要认证
        </span><span class="cov0" title="0">{
                // 角色管理 - 使用细粒度权限
                rbacGroup.GET("/roles", permMiddleware.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/roles"), roleHandler.ListRoles)
                rbacGroup.GET("/roles/:id", permMiddleware.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/roles/:id"), roleHandler.GetRole)
                rbacGroup.POST("/roles", permMiddleware.RequirePermission(model.HTTPMethodPOST, "/api/v1/admin/roles"), roleHandler.CreateRole)
                rbacGroup.PUT("/roles/:id", permMiddleware.RequirePermission(model.HTTPMethodPUT, "/api/v1/admin/roles/:id"), roleHandler.UpdateRole)
                rbacGroup.DELETE("/roles/:id", permMiddleware.RequirePermission(model.HTTPMethodDELETE, "/api/v1/admin/roles/:id"), roleHandler.DeleteRole)
                rbacGroup.PUT("/roles/:id/permissions", permMiddleware.RequirePermission(model.HTTPMethodPUT, "/api/v1/admin/roles/:id/permissions"), roleHandler.AssignPermissions)
                rbacGroup.POST("/roles/assign-user", permMiddleware.RequirePermission(model.HTTPMethodPOST, "/api/v1/admin/roles/assign-user"), roleHandler.AssignRolesToUser)
                rbacGroup.GET("/users/:id/roles", permMiddleware.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/users/:id/roles"), roleHandler.GetUserRoles)

                // 权限管理 - 使用细粒度权限
                rbacGroup.GET("/permissions", permMiddleware.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/permissions"), permHandler.ListPermissions)
                rbacGroup.GET("/permissions/groups", permMiddleware.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/permissions/groups"), permHandler.GetPermissionGroups)
                rbacGroup.GET("/permissions/:id", permMiddleware.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/permissions/:id"), permHandler.GetPermission)
                rbacGroup.POST("/permissions", permMiddleware.RequirePermission(model.HTTPMethodPOST, "/api/v1/admin/permissions"), permHandler.CreatePermission)
                rbacGroup.PUT("/permissions/:id", permMiddleware.RequirePermission(model.HTTPMethodPUT, "/api/v1/admin/permissions/:id"), permHandler.UpdatePermission)
                rbacGroup.DELETE("/permissions/:id", permMiddleware.RequirePermission(model.HTTPMethodDELETE, "/api/v1/admin/permissions/:id"), permHandler.DeletePermission)
                rbacGroup.GET("/roles/:id/permissions", permMiddleware.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/roles/:id/permissions"), permHandler.GetRolePermissions)
                rbacGroup.GET("/users/:id/permissions", permMiddleware.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/users/:id/permissions"), permHandler.GetUserPermissions)
        }</span>

        // Commission management routes (admin)
        <span class="cov0" title="0">adminhandler.RegisterCommissionRoutes(rbacGroup, commissionSvc, settlementScheduler)

        // Service Item management routes (admin) - 统一管理护航服务和礼物
        adminhandler.RegisterServiceItemRoutes(rbacGroup, serviceItemSvc)

        // Withdraw management routes (admin) - 提现审核管理
        adminhandler.RegisterWithdrawRoutes(rbacGroup, withdrawRepo)

        // Dashboard routes (admin) - 数据统计和Dashboard
        adminhandler.RegisterDashboardRoutes(rbacGroup, userRepo, playerRepo, orderRepo, withdrawRepo, serviceItemRepo, commissionRepo)

        // Stats routes (admin) - 统计分析
        adminhandler.RegisterStatsAnalysisRoutes(rbacGroup, orderRepo, commissionRepo, serviceItemRepo)

        // Ranking Commission routes (admin) - 排名抽成配置
        adminhandler.RegisterRankingCommissionRoutes(rbacGroup, rankingCommissionRepo)

        // 同步 API 路由到权限表（开发环境自动同步）
        if os.Getenv("APP_ENV") != "production" || os.Getenv("SYNC_API_PERMISSIONS") == "true" </span><span class="cov0" title="0">{
                log.Println("同步 API 权限到数据库...")
                syncConfig := middleware.APISyncConfig{
                        GroupFilter: "/api/v1/admin",
                        SkipPaths: []string{
                                "/api/v1/health",
                                "/api/v1/metrics",
                                "/api/v1/swagger",
                        },
                        DryRun: false,
                }
                if err := middleware.SyncAPIPermissions(router, permService, syncConfig); err != nil </span><span class="cov0" title="0">{
                        log.Printf("同步权限失败: %v", err)
                }</span>

                // 权限同步后，为默认角色分配权限
                <span class="cov0" title="0">log.Println("为默认角色分配权限...")
                if err := assignDefaultRolePermissions(context.Background(), roleSvc, permService); err != nil </span><span class="cov0" title="0">{
                        log.Printf("分配默认权限失败: %v", err)
                }</span>
        }

        <span class="cov0" title="0">addr := fmt.Sprintf(":%s", cfg.Port)

        server := &amp;http.Server{
                Addr:              addr,
                Handler:           router,
                ReadHeaderTimeout: 5 * time.Second,
        }

        go func() </span><span class="cov0" title="0">{
                log.Printf("user-service listening on %s", server.Addr)
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("server error: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">stop := make(chan os.Signal, 1)
        signal.Notify(stop, syscall.SIGINT, syscall.SIGTERM)
        &lt;-stop

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("shutdown error: %v", err)
        }</span>
        <span class="cov0" title="0">log.Println("server stopped gracefully")</span>
}

// assignDefaultRolePermissions 为默认角色（admin 和 super_admin）分配所有管理权限。
func assignDefaultRolePermissions(ctx context.Context, roleSvc *roleservice.RoleService, permService *permissionservice.PermissionService) error <span class="cov0" title="0">{
        // 获取所有权限
        allPermissions, err := permService.ListPermissions(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list permissions: %w", err)
        }</span>

        <span class="cov0" title="0">if len(allPermissions) == 0 </span><span class="cov0" title="0">{
                log.Println("没有权限需要分配，跳过")
                return nil
        }</span>

        // 提取所有权限 ID
        <span class="cov0" title="0">permissionIDs := make([]uint64, 0, len(allPermissions))
        for _, perm := range allPermissions </span><span class="cov0" title="0">{
                permissionIDs = append(permissionIDs, perm.ID)
        }</span>

        // 为 admin 和 super_admin 角色分配所有权限
        <span class="cov0" title="0">roleSlugs := []string{
                string(model.RoleSlugSuperAdmin),
                string(model.RoleSlugAdmin),
        }

        for _, roleSlug := range roleSlugs </span><span class="cov0" title="0">{
                role, err := roleSvc.GetRoleBySlug(ctx, roleSlug)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("警告：未找到角色 %s，跳过: %v", roleSlug, err)
                        continue</span>
                }

                // 分配权限（替换现有权限）
                <span class="cov0" title="0">if err := roleSvc.AssignPermissionsToRole(ctx, role.ID, permissionIDs); err != nil </span><span class="cov0" title="0">{
                        log.Printf("警告：为角色 %s 分配权限失败: %v", roleSlug, err)
                        continue</span>
                }

                <span class="cov0" title="0">log.Printf("已为角色 %s (id=%d) 分配 %d 个权限", roleSlug, role.ID, len(permissionIDs))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func resolveGinMode() string <span class="cov8" title="1">{
        if mode := os.Getenv("GIN_MODE"); mode != "" </span><span class="cov8" title="1">{
                return mode
        }</span>
        <span class="cov8" title="1">if env := os.Getenv("APP_ENV"); env == "production" </span><span class="cov8" title="1">{
                return gin.ReleaseMode
        }</span>
        <span class="cov8" title="1">return gin.DebugMode</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/admin/games": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Games"
                ],
                "summary": "列出游戏",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "页码",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "每页数量",
                        "name": "page_size",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Games"
                ],
                "summary": "创建游戏",
                "parameters": [
                    {
                        "description": "游戏信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_admin.GamePayload"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/games/{id}": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Games"
                ],
                "summary": "获取游戏",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "游戏ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Games"
                ],
                "summary": "更新游戏",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "游戏ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "游戏信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_admin.GamePayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Games"
                ],
                "summary": "删除游戏",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "游戏ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/games/{id}/logs": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Games"
                ],
                "summary": "获取游戏操作日志",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "游戏ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "页码",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "每页数量",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "type": "string",
                        "description": "动作过滤",
                        "name": "action",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "操作者用户ID",
                        "name": "actor_user_id",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "开始时间",
                        "name": "date_from",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "结束时间",
                        "name": "date_to",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "csv"
                        ],
                        "type": "string",
                        "description": "导出格式",
                        "name": "export",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "导出列（逗号分隔）",
                        "name": "fields",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "en",
                            "zh"
                        ],
                        "type": "string",
                        "description": "列头语言",
                        "name": "header_lang",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/orders": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "根据状态/用户/玩家/游戏和时间范围筛选，支持分页",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Orders"
                ],
                "summary": "列出订单",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "页码",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "每页数量",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "collectionFormat": "csv",
                        "description": "订单状态，可多值",
                        "name": "status",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "用户ID",
                        "name": "user_id",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "玩家ID",
                        "name": "player_id",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "游戏ID",
                        "name": "game_id",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "开始时间",
                        "name": "date_from",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "结束时间",
                        "name": "date_to",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Orders"
                ],
                "summary": "创建订单",
                "parameters": [
                    {
                        "description": "订单信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_admin.CreateOrderPayload"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/orders/{id}": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Orders"
                ],
                "summary": "获取订单",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "订单ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Orders"
                ],
                "summary": "更新订单",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "订单ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "订单信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_admin.UpdateOrderPayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Orders"
                ],
                "summary": "删除订单",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "订单ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/orders/{id}/assign": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Orders"
                ],
                "summary": "指派订单的陪玩师",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "订单ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "指派信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_admin.AssignOrderPayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/orders/{id}/cancel": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Orders"
                ],
                "summary": "取消订单",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "订单ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "取消原因",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_admin.CancelOrderPayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/orders/{id}/complete": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "将订单状态从 in_progress 置为 completed，并记录完成时间",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Orders"
                ],
                "summary": "完成订单",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "订单ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "备注（可选）",
                        "name": "request",
                        "in": "body",
                        "schema": {
                            "$ref": "#/definitions/internal_admin.orderNotePayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/orders/{id}/confirm": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "将订单状态从 pending 置为 confirmed",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Orders"
                ],
                "summary": "确认订单",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "订单ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "备注（可选）",
                        "name": "request",
                        "in": "body",
                        "schema": {
                            "$ref": "#/definitions/internal_admin.orderNotePayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/orders/{id}/logs": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Orders"
                ],
                "summary": "获取订单操作日志",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "订单ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "页码",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "每页数量",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "create",
                            "assign_player",
                            "update_status",
                            "cancel",
                            "delete"
                        ],
                        "type": "string",
                        "description": "动作过滤",
                        "name": "action",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "操作者用户ID",
                        "name": "actor_user_id",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "开始时间",
                        "name": "date_from",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "结束时间",
                        "name": "date_to",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "csv"
                        ],
                        "type": "string",
                        "description": "导出格式",
                        "name": "export",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "导出列（逗号分隔），默认：id,entity_type,entity_id,actor_user_id,action,reason,metadata,created_at",
                        "name": "fields",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "en",
                            "zh"
                        ],
                        "type": "string",
                        "description": "列头语言",
                        "name": "header_lang",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/orders/{id}/payments": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Orders"
                ],
                "summary": "获取订单支付记录",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "订单ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/orders/{id}/refund": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "将订单状态标记为 refunded，并记录退款金额与原因，同时关联支付退款",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Orders"
                ],
                "summary": "订单退款",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "订单ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "退款信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_admin.orderRefundPayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/orders/{id}/refunds": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Orders"
                ],
                "summary": "获取订单退款记录",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "订单ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/orders/{id}/review": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Orders"
                ],
                "summary": "审核订单（通过/拒绝）",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "订单ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "审核信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_admin.ReviewOrderPayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/orders/{id}/reviews": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Orders"
                ],
                "summary": "获取订单评价列表",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "订单ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/orders/{id}/start": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "将订单状态从 confirmed 置为 in_progress，并记录开始时间",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Orders"
                ],
                "summary": "开始服务",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "订单ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "备注（可选）",
                        "name": "request",
                        "in": "body",
                        "schema": {
                            "$ref": "#/definitions/internal_admin.orderNotePayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/orders/{id}/timeline": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "汇总订单的状态变更、操作日志、支付事件等信息",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Orders"
                ],
                "summary": "获取订单时间线",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "订单ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/payments": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "根据状态/方法/用户/订单和时间范围筛选，支持分页",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Payments"
                ],
                "summary": "列出支付",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "页码",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "每页数量",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "collectionFormat": "csv",
                        "description": "支付状态",
                        "name": "status",
                        "in": "query"
                    },
                    {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "collectionFormat": "csv",
                        "description": "支付方式",
                        "name": "method",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "用户ID",
                        "name": "user_id",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "订单ID",
                        "name": "order_id",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "开始时间",
                        "name": "date_from",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "结束时间",
                        "name": "date_to",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Payments"
                ],
                "summary": "创建支付记录",
                "parameters": [
                    {
                        "description": "支付信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_admin.CreatePaymentPayload"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/payments/{id}": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Payments"
                ],
                "summary": "获取支付",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "支付ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Payments"
                ],
                "summary": "更新支付",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "支付ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "支付信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_admin.UpdatePaymentPayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Payments"
                ],
                "summary": "删除支付",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "支付ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/payments/{id}/capture": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Payments"
                ],
                "summary": "确认支付入账",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "支付ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "入账信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_admin.CapturePaymentPayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/payments/{id}/logs": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Payments"
                ],
                "summary": "获取支付操作日志",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "支付ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "页码",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "每页数量",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "create",
                            "capture",
                            "update_status",
                            "refund",
                            "delete"
                        ],
                        "type": "string",
                        "description": "动作过滤",
                        "name": "action",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "操作者用户ID",
                        "name": "actor_user_id",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "开始时间",
                        "name": "date_from",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "结束时间",
                        "name": "date_to",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "csv"
                        ],
                        "type": "string",
                        "description": "导出格式",
                        "name": "export",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "导出列（逗号分隔），默认：id,entity_type,entity_id,actor_user_id,action,reason,metadata,created_at",
                        "name": "fields",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "en",
                            "zh"
                        ],
                        "type": "string",
                        "description": "列头语言",
                        "name": "header_lang",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/payments/{id}/refund": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Payments"
                ],
                "summary": "退款处理",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "支付ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "退款信息",
                        "name": "request",
                        "in": "body",
                        "schema": {
                            "$ref": "#/definitions/internal_admin.RefundPaymentPayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/players": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Players"
                ],
                "summary": "列出玩家资料",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "页码",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "每页数量",
                        "name": "page_size",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Players"
                ],
                "summary": "新建玩家资料",
                "parameters": [
                    {
                        "description": "玩家信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_admin.CreatePlayerPayload"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/players/{id}": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Players"
                ],
                "summary": "获取玩家资料",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "玩家ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Players"
                ],
                "summary": "更新玩家资料",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "玩家ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "玩家信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_admin.UpdatePlayerPayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Players"
                ],
                "summary": "删除玩家资料",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "玩家ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/players/{id}/games": {
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Players"
                ],
                "summary": "更新玩家主游戏",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "玩家ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "{main_game_id}",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "integer",
                                "format": "int64"
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/players/{id}/logs": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Players"
                ],
                "summary": "获取玩家操作日志",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "玩家ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "页码",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "每页数量",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "type": "string",
                        "description": "动作过滤",
                        "name": "action",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "操作者用户ID",
                        "name": "actor_user_id",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "开始时间",
                        "name": "date_from",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "结束时间",
                        "name": "date_to",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "csv"
                        ],
                        "type": "string",
                        "description": "导出格式",
                        "name": "export",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "导出列（逗号分隔）",
                        "name": "fields",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "en",
                            "zh"
                        ],
                        "type": "string",
                        "description": "列头语言",
                        "name": "header_lang",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/players/{id}/reviews": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Players"
                ],
                "summary": "获取陪玩师的评价",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "陪玩师ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "页码",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "每页数量",
                        "name": "page_size",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/players/{id}/skill-tags": {
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Players"
                ],
                "summary": "更新玩家技能标签",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "玩家ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "标签集合",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_admin.SkillTagsBody"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/players/{id}/verification": {
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Players"
                ],
                "summary": "更新玩家认证状态",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "玩家ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "{verification_status}",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/reviews": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Reviews"
                ],
                "summary": "评价列表",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "页码",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "每页数量",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "订单ID",
                        "name": "order_id",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "用户ID",
                        "name": "user_id",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "陪玩师ID",
                        "name": "player_id",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "开始时间",
                        "name": "date_from",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "结束时间",
                        "name": "date_to",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Reviews"
                ],
                "summary": "创建评价",
                "parameters": [
                    {
                        "description": "评价",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_admin.CreateReviewPayload"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/reviews/{id}": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Reviews"
                ],
                "summary": "获取评价",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "评价ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Reviews"
                ],
                "summary": "更新评价",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "评价ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "评价",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_admin.UpdateReviewPayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Reviews"
                ],
                "summary": "删除评价",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "评价ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/reviews/{id}/logs": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Reviews"
                ],
                "summary": "获取评价操作日志",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "评价ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "页码",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "每页数量",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "type": "string",
                        "description": "动作过滤",
                        "name": "action",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "操作者用户ID",
                        "name": "actor_user_id",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "开始时间",
                        "name": "date_from",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "结束时间",
                        "name": "date_to",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "csv"
                        ],
                        "type": "string",
                        "description": "导出格式",
                        "name": "export",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "导出列（逗号分隔）",
                        "name": "fields",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "en",
                            "zh"
                        ],
                        "type": "string",
                        "description": "列头语言",
                        "name": "header_lang",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/stats/audit/overview": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Stats"
                ],
                "summary": "审计总览（按实体/动作汇总）",
                "parameters": [
                    {
                        "type": "string",
                        "description": "开始时间",
                        "name": "date_from",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "结束时间",
                        "name": "date_to",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/stats/audit/trend": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Stats"
                ],
                "summary": "审计趋势（日）",
                "parameters": [
                    {
                        "type": "string",
                        "description": "开始时间",
                        "name": "date_from",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "结束时间",
                        "name": "date_to",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "order",
                            "payment",
                            "player",
                            "game",
                            "review",
                            "user"
                        ],
                        "type": "string",
                        "description": "实体类型",
                        "name": "entity",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "动作",
                        "name": "action",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/stats/dashboard": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Stats"
                ],
                "summary": "Dashboard 概览",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/stats/orders": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Stats"
                ],
                "summary": "订单状态统计",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/stats/revenue-trend": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Stats"
                ],
                "summary": "收入趋势（日）",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "天数，默认7",
                        "name": "days",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/stats/top-players": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Stats"
                ],
                "summary": "Top 陪玩师排行",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "数量，默认10",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/stats/user-growth": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Stats"
                ],
                "summary": "用户增长（日）",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "天数，默认7",
                        "name": "days",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/users": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "分页列出用户，支持按角色/状态/时间范围/关键字筛选",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Users"
                ],
                "summary": "列出用户",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "页码",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "每页数量",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "collectionFormat": "csv",
                        "description": "角色过滤，可多值",
                        "name": "role",
                        "in": "query"
                    },
                    {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "collectionFormat": "csv",
                        "description": "状态过滤，可多值",
                        "name": "status",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "开始时间",
                        "name": "date_from",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "结束时间",
                        "name": "date_to",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "关键字（匹配 name/email/phone）",
                        "name": "keyword",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Users"
                ],
                "summary": "创建用户",
                "parameters": [
                    {
                        "description": "用户信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_admin.CreateUserPayload"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/users/{id}": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Users"
                ],
                "summary": "获取用户",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "用户ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Users"
                ],
                "summary": "更新用户",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "用户ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "用户信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_admin.UpdateUserPayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Users"
                ],
                "summary": "删除用户",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "用户ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/users/{id}/logs": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Users"
                ],
                "summary": "获取用户操作日志",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "用户ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "页码",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "每页数量",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "create",
                            "update",
                            "delete"
                        ],
                        "type": "string",
                        "description": "动作过滤",
                        "name": "action",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "操作者用户ID",
                        "name": "actor_user_id",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "开始时间",
                        "name": "date_from",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "结束时间",
                        "name": "date_to",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "csv"
                        ],
                        "type": "string",
                        "description": "导出格式",
                        "name": "export",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "导出列（逗号分隔）",
                        "name": "fields",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "en",
                            "zh"
                        ],
                        "type": "string",
                        "description": "列头语言",
                        "name": "header_lang",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/users/{id}/orders": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Users"
                ],
                "summary": "获取用户的订单",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "用户ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "页码",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "每页数量",
                        "name": "page_size",
                        "in": "query"
                    },
                    {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "collectionFormat": "csv",
                        "description": "订单状态",
                        "name": "status",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "开始时间",
                        "name": "date_from",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "结束时间",
                        "name": "date_to",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/users/{id}/role": {
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Users"
                ],
                "summary": "更新用户角色",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "用户ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "{role}",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/admin/users/{id}/status": {
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Admin/Users"
                ],
                "summary": "更新用户状态",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "用户ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "{status}",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/auth/login": {
            "post": {
                "description": "用户名（邮箱或手机号）+ 密码登录，返回 JWT",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "登录",
                "parameters": [
                    {
                        "description": "登录凭据",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_handler.loginRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/internal_handler.loginResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/auth/logout": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "登出（前端丢弃 Token）",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/auth/me": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "获取当前用户信息",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/internal_handler.loginResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/auth/refresh": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "使用 Authorization: Bearer \u003ctoken\u003e 刷新 JWT",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "刷新 Token",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/internal_handler.tokenPayload"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "邮箱或手机号 + 密码注册，默认角色为 user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "注册",
                "parameters": [
                    {
                        "description": "注册信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_handler.registerRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/internal_handler.loginResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "gamelink_internal_model.Role": {
            "type": "string",
            "enum": [
                "user",
                "player",
                "admin"
            ],
            "x-enum-varnames": [
                "RoleUser",
                "RolePlayer",
                "RoleAdmin"
            ]
        },
        "gamelink_internal_model.User": {
            "type": "object",
            "properties": {
                "avatar_url": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "last_login_at": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "phone": {
                    "type": "string"
                },
                "role": {
                    "$ref": "#/definitions/gamelink_internal_model.Role"
                },
                "status": {
                    "$ref": "#/definitions/gamelink_internal_model.UserStatus"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "gamelink_internal_model.UserStatus": {
            "type": "string",
            "enum": [
                "active",
                "suspended",
                "banned"
            ],
            "x-enum-varnames": [
                "UserStatusActive",
                "UserStatusSuspended",
                "UserStatusBanned"
            ]
        },
        "internal_admin.AssignOrderPayload": {
            "type": "object",
            "required": [
                "player_id"
            ],
            "properties": {
                "player_id": {
                    "type": "integer"
                }
            }
        },
        "internal_admin.CancelOrderPayload": {
            "type": "object",
            "properties": {
                "reason": {
                    "type": "string"
                }
            }
        },
        "internal_admin.CapturePaymentPayload": {
            "type": "object",
            "properties": {
                "paid_at": {
                    "type": "string",
                    "example": "2025-10-28T10:00:00Z"
                },
                "provider_raw": {
                    "type": "string",
                    "example": "{\"result\":\"captured\"}"
                },
                "provider_trade_no": {
                    "type": "string"
                }
            }
        },
        "internal_admin.CreateOrderPayload": {
            "type": "object",
            "required": [
                "currency",
                "game_id",
                "price_cents",
                "user_id"
            ],
            "properties": {
                "currency": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "game_id": {
                    "type": "integer"
                },
                "player_id": {
                    "type": "integer"
                },
                "price_cents": {
                    "type": "integer"
                },
                "scheduled_end": {
                    "type": "string"
                },
                "scheduled_start": {
                    "type": "string"
                },
                "title": {
                    "type": "string"
                },
                "user_id": {
                    "type": "integer"
                }
            }
        },
        "internal_admin.CreatePaymentPayload": {
            "type": "object",
            "required": [
                "amount_cents",
                "currency",
                "method",
                "order_id",
                "user_id"
            ],
            "properties": {
                "amount_cents": {
                    "type": "integer"
                },
                "currency": {
                    "type": "string"
                },
                "method": {
                    "type": "string"
                },
                "order_id": {
                    "type": "integer"
                },
                "provider_raw": {
                    "type": "string",
                    "example": "{\"result\":\"success\"}"
                },
                "user_id": {
                    "type": "integer"
                }
            }
        },
        "internal_admin.CreatePlayerPayload": {
            "type": "object",
            "required": [
                "user_id",
                "verification_status"
            ],
            "properties": {
                "bio": {
                    "type": "string"
                },
                "hourly_rate_cents": {
                    "type": "integer"
                },
                "main_game_id": {
                    "type": "integer"
                },
                "nickname": {
                    "type": "string"
                },
                "rank": {
                    "type": "string"
                },
                "user_id": {
                    "type": "integer"
                },
                "verification_status": {
                    "type": "string"
                }
            }
        },
        "internal_admin.CreateReviewPayload": {
            "type": "object",
            "required": [
                "order_id",
                "player_id",
                "score",
                "user_id"
            ],
            "properties": {
                "content": {
                    "type": "string"
                },
                "order_id": {
                    "type": "integer"
                },
                "player_id": {
                    "type": "integer"
                },
                "score": {
                    "type": "integer"
                },
                "user_id": {
                    "type": "integer"
                }
            }
        },
        "internal_admin.CreateUserPayload": {
            "type": "object",
            "required": [
                "name",
                "password",
                "role",
                "status"
            ],
            "properties": {
                "avatar_url": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "password": {
                    "type": "string",
                    "minLength": 6
                },
                "phone": {
                    "type": "string"
                },
                "role": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "internal_admin.GamePayload": {
            "type": "object",
            "required": [
                "key",
                "name"
            ],
            "properties": {
                "category": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "icon_url": {
                    "type": "string"
                },
                "key": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "internal_admin.RefundPaymentPayload": {
            "type": "object",
            "properties": {
                "provider_raw": {
                    "type": "string",
                    "example": "{\"result\":\"refunded\"}"
                },
                "provider_trade_no": {
                    "type": "string"
                },
                "refunded_at": {
                    "type": "string",
                    "example": "2025-10-28T12:00:00Z"
                }
            }
        },
        "internal_admin.ReviewOrderPayload": {
            "type": "object",
            "properties": {
                "approved": {
                    "type": "boolean"
                },
                "reason": {
                    "type": "string"
                }
            }
        },
        "internal_admin.SkillTagsBody": {
            "type": "object",
            "required": [
                "tags"
            ],
            "properties": {
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "internal_admin.UpdateOrderPayload": {
            "type": "object",
            "required": [
                "currency",
                "price_cents",
                "status"
            ],
            "properties": {
                "cancel_reason": {
                    "type": "string"
                },
                "currency": {
                    "type": "string"
                },
                "price_cents": {
                    "type": "integer"
                },
                "scheduled_end": {
                    "type": "string"
                },
                "scheduled_start": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "internal_admin.UpdatePaymentPayload": {
            "type": "object",
            "required": [
                "status"
            ],
            "properties": {
                "paid_at": {
                    "type": "string",
                    "example": "2025-10-28T10:00:00Z"
                },
                "provider_raw": {
                    "type": "string",
                    "example": "{\"result\":\"update\"}"
                },
                "provider_trade_no": {
                    "type": "string"
                },
                "refunded_at": {
                    "type": "string",
                    "example": "2025-10-28T12:00:00Z"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "internal_admin.UpdatePlayerPayload": {
            "type": "object",
            "required": [
                "verification_status"
            ],
            "properties": {
                "bio": {
                    "type": "string"
                },
                "hourly_rate_cents": {
                    "type": "integer"
                },
                "main_game_id": {
                    "type": "integer"
                },
                "nickname": {
                    "type": "string"
                },
                "rank": {
                    "type": "string"
                },
                "verification_status": {
                    "type": "string"
                }
            }
        },
        "internal_admin.UpdateReviewPayload": {
            "type": "object",
            "required": [
                "score"
            ],
            "properties": {
                "content": {
                    "type": "string"
                },
                "score": {
                    "type": "integer"
                }
            }
        },
        "internal_admin.UpdateUserPayload": {
            "type": "object",
            "required": [
                "name",
                "role",
                "status"
            ],
            "properties": {
                "avatar_url": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                },
                "phone": {
                    "type": "string"
                },
                "role": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "internal_admin.orderNotePayload": {
            "type": "object",
            "properties": {
                "note": {
                    "type": "string"
                }
            }
        },
        "internal_admin.orderRefundPayload": {
            "type": "object",
            "required": [
                "reason"
            ],
            "properties": {
                "amount_cents": {
                    "type": "integer"
                },
                "note": {
                    "type": "string"
                },
                "reason": {
                    "type": "string"
                }
            }
        },
        "internal_handler.loginRequest": {
            "type": "object",
            "required": [
                "password",
                "username"
            ],
            "properties": {
                "password": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "internal_handler.loginResponse": {
            "type": "object",
            "properties": {
                "expires_at": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                },
                "user": {
                    "$ref": "#/definitions/gamelink_internal_model.User"
                }
            }
        },
        "internal_handler.registerRequest": {
            "type": "object",
            "required": [
                "name",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "password": {
                    "type": "string",
                    "minLength": 6
                },
                "phone": {
                    "type": "string"
                }
            }
        },
        "internal_handler.tokenPayload": {
            "type": "object",
            "properties": {
                "token": {
                    "type": "string"
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "0.3.0",
        Host:             "",
        BasePath:         "/api/v1",
        Schemes:          []string{"http", "https"},
        Title:            "GameLink API",
        Description:      "GameLink 平台 API，包含健康检查、认证与管理端能力。",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov8" title="1">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package auth

import (
        "errors"
        "os"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

// JWT工具类
//
// 功能：
// 1. 生成JWT Token
// 2. 解析和验证JWT Token
// 3. 提取用户信息

// Claims 定义JWT载荷结构
type Claims struct {
        UserID uint64 `json:"user_id"` // 用户ID
        Role   string `json:"role"`    // 用户角色
        jwt.RegisteredClaims
}

// JWTManager JWT管理器
type JWTManager struct {
        secretKey     string        // 签名密钥
        tokenDuration time.Duration // Token有效期
        maxRefresh    time.Duration // 允许刷新窗口（自签发起）
}

// NewJWTManager 创建JWT管理器
func NewJWTManager(secretKey string, tokenDuration time.Duration) *JWTManager <span class="cov8" title="1">{
        return &amp;JWTManager{
                secretKey:     secretKey,
                tokenDuration: tokenDuration,
                maxRefresh:    readMaxRefreshWindow(),
        }
}</span>

func readMaxRefreshWindow() time.Duration <span class="cov8" title="1">{
        v := os.Getenv("JWT_MAX_REFRESH")
        if v != "" </span><span class="cov0" title="0">{
                if d, err := time.ParseDuration(v); err == nil </span><span class="cov0" title="0">{
                        return d
                }</span>
        }
        <span class="cov8" title="1">return 7 * 24 * time.Hour</span>
}

// GenerateToken 生成JWT Token
//
// 参数：
// - userID: 用户ID
// - role: 用户角色
//
// 返回：
// - token: JWT字符串
// - err: 错误信息
func (manager *JWTManager) GenerateToken(userID uint64, role string) (string, error) <span class="cov8" title="1">{
        // 创建Claims
        claims := Claims{
                UserID: userID,
                Role:   role,
                RegisteredClaims: jwt.RegisteredClaims{
                        // 设置过期时间
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(manager.tokenDuration)),
                        // 设置签发时间
                        IssuedAt: jwt.NewNumericDate(time.Now()),
                        // 设置生效时间（立即生效）
                        NotBefore: jwt.NewNumericDate(time.Now()),
                        // 设置签发者
                        Issuer: "gamelink",
                },
        }

        // 创建Token
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        // 签名Token
        signedToken, err := token.SignedString([]byte(manager.secretKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return signedToken, nil</span>
}

// VerifyToken 验证JWT Token
//
// 参数：
// - tokenString: JWT字符串
//
// 返回：
// - claims: 用户信息
// - err: 错误信息
func (manager *JWTManager) VerifyToken(tokenString string) (*Claims, error) <span class="cov8" title="1">{
        // 解析Token
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                // 验证签名算法
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("无效的签名算法")
                }</span>
                <span class="cov8" title="1">return []byte(manager.secretKey), nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 验证Token是否有效
        <span class="cov8" title="1">if !token.Valid </span><span class="cov0" title="0">{
                return nil, errors.New("无效的Token")
        }</span>

        // 提取Claims
        <span class="cov8" title="1">claims, ok := token.Claims.(*Claims)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("无法解析Token Claims")
        }</span>

        <span class="cov8" title="1">return claims, nil</span>
}

// RefreshToken 刷新Token
//
// 当Token快要过期时，可以生成新的Token
func (manager *JWTManager) RefreshToken(claims *Claims) (string, error) <span class="cov0" title="0">{
        // 检查Token是否还有足够的时间
        if time.Until(claims.ExpiresAt.Time) &gt; 30*time.Second </span><span class="cov0" title="0">{
                return "", errors.New("Token还未到刷新时间")
        }</span>

        // 限制刷新窗口：签发时间距今不得超过 maxRefresh
        <span class="cov0" title="0">if !claims.IssuedAt.Time.IsZero() &amp;&amp; time.Since(claims.IssuedAt.Time) &gt; manager.maxRefresh </span><span class="cov0" title="0">{
                return "", errors.New("Token已超过可刷新窗口")
        }</span>

        // 生成新的Token
        <span class="cov0" title="0">return manager.GenerateToken(claims.UserID, claims.Role)</span>
}

// ExtractTokenFromHeader 从HTTP头中提取Token
//
// Authorization Header格式：Bearer &lt;token&gt;
func ExtractTokenFromHeader(authHeader string) (string, error) <span class="cov8" title="1">{
        if authHeader == "" </span><span class="cov0" title="0">{
                return "", errors.New("缺少Authorization头")
        }</span>

        // 检查Bearer前缀
        <span class="cov8" title="1">const bearerPrefix = "Bearer "
        if len(authHeader) &lt; len(bearerPrefix) || authHeader[:len(bearerPrefix)] != bearerPrefix </span><span class="cov8" title="1">{
                return "", errors.New("Authorization头格式错误，应为'Bearer &lt;token&gt;'")
        }</span>

        // 提取Token
        <span class="cov8" title="1">token := authHeader[len(bearerPrefix):]
        if token == "" </span><span class="cov0" title="0">{
                return "", errors.New("Token为空")
        }</span>

        <span class="cov8" title="1">return token, nil</span>
}

// IsTokenExpired 检查Token是否过期
func IsTokenExpired(claims *Claims) bool <span class="cov0" title="0">{
        return time.Now().After(claims.ExpiresAt.Time)
}</span>

// GetTokenRemainingTime 获取Token剩余有效时间
func GetTokenRemainingTime(claims *Claims) time.Duration <span class="cov0" title="0">{
        return time.Until(claims.ExpiresAt.Time)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package cache

import (
        "context"
        "time"

        "gamelink/internal/config"
)

// Cache 提供简单的 KV 缓存接口。
type Cache interface {
        Get(ctx context.Context, key string) (value string, ok bool, err error)
        Set(ctx context.Context, key, value string, ttl time.Duration) error
        Delete(ctx context.Context, key string) error
        Close(ctx context.Context) error
}

// New 根据配置创建缓存实例。
func New(cfg config.CacheConfig) (Cache, error) <span class="cov8" title="1">{
        switch cfg.Type </span>{
        case "", "memory":<span class="cov8" title="1">
                return NewMemory(), nil</span>
        case "redis":<span class="cov8" title="1">
                return NewRedis(cfg.Redis)</span>
        default:<span class="cov8" title="1">
                return NewMemory(), nil</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package cache

import (
        "context"
        "sync"
        "time"
)

type memoryEntry struct {
        value  string
        expiry time.Time
}

// memoryCache 是开发环境下的本地缓存实现。
type memoryCache struct {
        mu     sync.RWMutex
        values map[string]memoryEntry
        stopCh chan struct{}
}

// NewMemory 创建内存缓存。
func NewMemory() Cache <span class="cov8" title="1">{
        c := &amp;memoryCache{
                values: make(map[string]memoryEntry),
                stopCh: make(chan struct{}),
        }
        go c.janitor(1 * time.Minute)
        return c
}</span>

func (c *memoryCache) Get(_ context.Context, key string) (string, bool, error) <span class="cov8" title="1">{
        c.mu.RLock()
        entry, ok := c.values[key]
        c.mu.RUnlock()
        if !ok </span><span class="cov8" title="1">{
                return "", false, nil
        }</span>
        <span class="cov8" title="1">if !entry.expiry.IsZero() &amp;&amp; time.Now().After(entry.expiry) </span><span class="cov8" title="1">{
                c.mu.Lock()
                delete(c.values, key)
                c.mu.Unlock()
                return "", false, nil
        }</span>
        <span class="cov8" title="1">return entry.value, true, nil</span>
}

func (c *memoryCache) Set(_ context.Context, key, value string, ttl time.Duration) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        entry := memoryEntry{value: value}
        if ttl &gt; 0 </span><span class="cov8" title="1">{
                entry.expiry = time.Now().Add(ttl)
        }</span>
        <span class="cov8" title="1">c.values[key] = entry
        return nil</span>
}

func (c *memoryCache) Delete(_ context.Context, key string) error <span class="cov8" title="1">{
        c.mu.Lock()
        delete(c.values, key)
        c.mu.Unlock()
        return nil
}</span>

func (c *memoryCache) Close(context.Context) error <span class="cov8" title="1">{
        close(c.stopCh)
        c.mu.Lock()
        c.values = make(map[string]memoryEntry)
        c.mu.Unlock()
        return nil
}</span>

func (c *memoryCache) janitor(interval time.Duration) <span class="cov8" title="1">{
        ticker := time.NewTicker(interval)
        defer ticker.Stop()
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        now := time.Now()
                        c.mu.Lock()
                        for k, v := range c.values </span><span class="cov0" title="0">{
                                if !v.expiry.IsZero() &amp;&amp; now.After(v.expiry) </span><span class="cov0" title="0">{
                                        delete(c.values, k)
                                }</span>
                        }
                        <span class="cov0" title="0">c.mu.Unlock()</span>
                case &lt;-c.stopCh:<span class="cov8" title="1">
                        return</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package cache

import (
        "context"
        "time"

        "github.com/redis/go-redis/v9"

        "gamelink/internal/config"
)

// redisCache 是生产环境下的 Redis 缓存实现。
type redisCache struct {
        client *redis.Client
}

// NewRedis 创建 Redis 缓存实例。
func NewRedis(cfg config.RedisConfig) (Cache, error) <span class="cov8" title="1">{
        client := redis.NewClient(&amp;redis.Options{
                Addr:         cfg.Addr,
                Password:     cfg.Password,
                DB:           cfg.DB,
                DialTimeout:  10 * time.Second,
                ReadTimeout:  10 * time.Second,
                WriteTimeout: 10 * time.Second,
                PoolTimeout:  10 * time.Second,
        })

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        if err := client.Ping(ctx).Err(); err != nil </span><span class="cov8" title="1">{
                _ = client.Close()
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;redisCache{client: client}, nil</span>
}

func (c *redisCache) Get(ctx context.Context, key string) (string, bool, error) <span class="cov0" title="0">{
        result, err := c.client.Get(ctx, key).Result()
        if err == redis.Nil </span><span class="cov0" title="0">{
                return "", false, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", false, err
        }</span>
        <span class="cov0" title="0">return result, true, nil</span>
}

func (c *redisCache) Set(ctx context.Context, key, value string, ttl time.Duration) error <span class="cov0" title="0">{
        return c.client.Set(ctx, key, value, ttl).Err()
}</span>

func (c *redisCache) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        return c.client.Del(ctx, key).Err()
}</span>

func (c *redisCache) Close(context.Context) error <span class="cov0" title="0">{
        return c.client.Close()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "log"
        "strings"
)

const defaultDBType = "sqlite"

var dsnSamples = map[string]string{
        "sqlite":    "file:./var/dev.db?mode=rwc&amp;_pragma=busy_timeout(5000)&amp;_pragma=foreign_keys(1)",
        "postgres":  "postgres://user:password@localhost:5432/gamelink?sslmode=disable",
        "mysql":     "user:password@tcp(localhost:3306)/gamelink?parseTime=true&amp;charset=utf8mb4",
        "sqlserver": "sqlserver://user:password@localhost:1433?database=gamelink",
}

// SampleDSN 返回常见数据库类型的 DSN 示例。
func SampleDSN(dbType string) string <span class="cov8" title="1">{
        return dsnSamples[dbType]
}</span>

func normalizeDBType(input string) string <span class="cov8" title="1">{
        value := strings.ToLower(strings.TrimSpace(input))
        if _, ok := dsnSamples[value]; ok </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">log.Printf("未知 DB_TYPE %q，使用默认值 %s", input, defaultDBType)
        return defaultDBType</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package config

import (
        "fmt"
        "log"
        "os"
        "path/filepath"
        "strconv"
        "strings"

        "gopkg.in/yaml.v3"
)

const (
        // DefaultDevJWTSecret 为开发环境提供兜底的 JWT 密钥（仅限本地调试）。
        DefaultDevJWTSecret = "gamelink-default-secret-key-change-in-development"
        defaultTokenTTL     = 24
)

// AppConfig 汇总服务运行所需的核心配置。
type AppConfig struct {
        Port          string
        EnableSwagger bool
        Database      DatabaseConfig
        Cache         CacheConfig
        Crypto        CryptoConfig
        Auth          AuthConfig
        Seed          SeedConfig
        SuperAdmin    SuperAdminConfig
        AdminAuth     AdminAuthConfig
}

// DatabaseConfig 描述数据库驱动与连接信息。
type DatabaseConfig struct {
        Type string `yaml:"type"`
        DSN  string `yaml:"dsn"`
}

// CacheConfig 描述缓存配置。
type CacheConfig struct {
        Type  string      `yaml:"type"`
        Redis RedisConfig `yaml:"redis"`
}

// RedisConfig 包含 redis 连接信息。
type RedisConfig struct {
        Addr     string `yaml:"addr"`
        Password string `yaml:"password"`
        DB       int    `yaml:"db"`
}

// CryptoConfig 描述前后端对称加密配置。
type CryptoConfig struct {
        Enabled      bool     `yaml:"enabled"`
        SecretKey    string   `yaml:"secret_key"`
        IV           string   `yaml:"iv"`
        Methods      []string `yaml:"methods"`
        ExcludePaths []string `yaml:"exclude_paths"`
        UseSignature bool     `yaml:"use_signature"`
}

// AuthConfig 描述鉴权配置。
type AuthConfig struct {
        JWTSecret     string `yaml:"jwt_secret"`
        TokenTTLHours int    `yaml:"token_ttl_hours"`
}

// SeedConfig 控制是否注入演示数据。
type SeedConfig struct {
        Enabled bool `yaml:"enabled"`
}

// SuperAdminConfig 描述超级管理员初始化配置。
type SuperAdminConfig struct {
        Email    string `yaml:"email"`
        Password string `yaml:"password"`
        Name     string `yaml:"name"`
        Phone    string `yaml:"phone"`
}

// AdminAuthConfig 描述管理员认证模式配置。
type AdminAuthConfig struct {
        Mode string `yaml:"mode"`
}

type cryptoFileConfig struct {
        Enabled      *bool    `yaml:"enabled"`
        SecretKey    string   `yaml:"secret_key"`
        IV           string   `yaml:"iv"`
        Methods      []string `yaml:"methods"`
        ExcludePaths []string `yaml:"exclude_paths"`
        UseSignature *bool    `yaml:"use_signature"`
}

type authFileConfig struct {
        JWTSecret     string `yaml:"jwt_secret"`
        TokenTTLHours *int   `yaml:"token_ttl_hours"`
}

type superAdminFileConfig struct {
        Email    string `yaml:"email"`
        Password string `yaml:"password"`
        Name     string `yaml:"name"`
        Phone    string `yaml:"phone"`
}

type adminAuthFileConfig struct {
        Mode string `yaml:"mode"`
}

type fileConfig struct {
        Server struct {
                Port          string `yaml:"port"`
                EnableSwagger *bool  `yaml:"enable_swagger"`
        } `yaml:"server"`
        Database  DatabaseConfig   `yaml:"database"`
        Cache     CacheConfig      `yaml:"cache"`
        Crypto    cryptoFileConfig `yaml:"crypto"`
        Auth      authFileConfig   `yaml:"auth"`
        Seed      SeedConfig       `yaml:"seed"`
        SuperAdmin superAdminFileConfig  `yaml:"super_admin"`
        AdminAuth  adminAuthFileConfig  `yaml:"admin_auth"`
}

// Load 读取配置文件及环境变量，生成最终配置。
func Load() AppConfig <span class="cov8" title="1">{
        env := os.Getenv("APP_ENV")
        if env == "" </span><span class="cov0" title="0">{
                env = "development"
        }</span>

        <span class="cov8" title="1">cfg := AppConfig{
                Port:          "8080",
                EnableSwagger: true,
                Database: DatabaseConfig{
                        Type: defaultDBType,
                        DSN:  "",
                },
                Cache: CacheConfig{
                        Type: "memory",
                        Redis: RedisConfig{
                                Addr:     "127.0.0.1:6379",
                                Password: "",
                                DB:       0,
                        },
                },
                Crypto: CryptoConfig{
                        Enabled:      false,
                        SecretKey:    "GameLink2025SecretKey!@#",
                        IV:           "GameLink2025IV!!!",
                        Methods:      []string{"POST", "PUT", "PATCH"},
                        ExcludePaths: []string{"/api/v1/health", "/api/v1/ping", "/api/v1/auth/refresh"},
                        UseSignature: true,
                },
                Auth: AuthConfig{
                        JWTSecret:     "",
                        TokenTTLHours: defaultTokenTTL,
                },
                Seed: SeedConfig{Enabled: false},
                SuperAdmin: SuperAdminConfig{
                        Email:    "admin@gamelink.local",
                        Password: "Admin@123456",
                        Name:     "Super Admin",
                        Phone:    "",
                },
                AdminAuth: AdminAuthConfig{
                        Mode: "admin", // 默认使用 AdminAuth，生产环境建议使用 jwt
                },
        }

        loadFromFile(env, &amp;cfg)
        overrideFromEnv(&amp;cfg)

        if cfg.Database.DSN == "" </span><span class="cov8" title="1">{
                if env != "production" </span><span class="cov8" title="1">{
                        if sample := SampleDSN(cfg.Database.Type); sample != "" </span><span class="cov8" title="1">{
                                cfg.Database.DSN = sample
                                log.Printf("DB_DSN 未配置，使用 %s 示例 DSN：%s", cfg.Database.Type, sample)
                        }</span>
                } else<span class="cov0" title="0"> {
                        log.Printf("DB_DSN 未配置，生产环境将保持为空并由外部注入")
                }</span>
        }

        <span class="cov8" title="1">if cfg.Auth.TokenTTLHours &lt;= 0 </span><span class="cov0" title="0">{
                cfg.Auth.TokenTTLHours = defaultTokenTTL
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(cfg.Auth.JWTSecret) == "" </span><span class="cov8" title="1">{
                if env == "production" </span><span class="cov0" title="0">{
                        log.Printf("JWT_SECRET_KEY 未配置，生产环境请通过配置或环境变量提供")
                }</span> else<span class="cov8" title="1"> {
                        cfg.Auth.JWTSecret = DefaultDevJWTSecret
                }</span>
        }

        <span class="cov8" title="1">return cfg</span>
}

func loadFromFile(env string, cfg *AppConfig) <span class="cov8" title="1">{
        configPath := filepath.Join("configs", fmt.Sprintf("config.%s.yaml", env))
        data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("读取配置文件 %s 失败：%v，使用默认值", configPath, err)
                return
        }</span>

        <span class="cov0" title="0">var fc fileConfig
        if err := yaml.Unmarshal(data, &amp;fc); err != nil </span><span class="cov0" title="0">{
                log.Printf("解析配置文件 %s 失败：%v，使用默认值", configPath, err)
                return
        }</span>

        <span class="cov0" title="0">if fc.Server.Port != "" </span><span class="cov0" title="0">{
                cfg.Port = fc.Server.Port
        }</span>
        <span class="cov0" title="0">if fc.Server.EnableSwagger != nil </span><span class="cov0" title="0">{
                cfg.EnableSwagger = *fc.Server.EnableSwagger
        }</span>
        <span class="cov0" title="0">if fc.Database.Type != "" </span><span class="cov0" title="0">{
                cfg.Database.Type = normalizeDBType(fc.Database.Type)
        }</span>
        <span class="cov0" title="0">if fc.Database.DSN != "" </span><span class="cov0" title="0">{
                cfg.Database.DSN = fc.Database.DSN
        }</span>
        <span class="cov0" title="0">if fc.Cache.Type != "" </span><span class="cov0" title="0">{
                cfg.Cache.Type = strings.ToLower(fc.Cache.Type)
        }</span>
        <span class="cov0" title="0">if fc.Cache.Redis.Addr != "" </span><span class="cov0" title="0">{
                cfg.Cache.Redis.Addr = fc.Cache.Redis.Addr
        }</span>
        <span class="cov0" title="0">if fc.Cache.Redis.Password != "" </span><span class="cov0" title="0">{
                cfg.Cache.Redis.Password = fc.Cache.Redis.Password
        }</span>
        <span class="cov0" title="0">if fc.Cache.Redis.DB != 0 </span><span class="cov0" title="0">{
                cfg.Cache.Redis.DB = fc.Cache.Redis.DB
        }</span>
        <span class="cov0" title="0">if fc.Crypto.SecretKey != "" </span><span class="cov0" title="0">{
                cfg.Crypto.SecretKey = fc.Crypto.SecretKey
        }</span>
        <span class="cov0" title="0">if fc.Crypto.IV != "" </span><span class="cov0" title="0">{
                cfg.Crypto.IV = fc.Crypto.IV
        }</span>
        <span class="cov0" title="0">if len(fc.Crypto.Methods) &gt; 0 </span><span class="cov0" title="0">{
                cfg.Crypto.Methods = normalizeHTTPMethods(fc.Crypto.Methods)
        }</span>
        <span class="cov0" title="0">if len(fc.Crypto.ExcludePaths) &gt; 0 </span><span class="cov0" title="0">{
                cfg.Crypto.ExcludePaths = normalizePaths(fc.Crypto.ExcludePaths)
        }</span>
        <span class="cov0" title="0">if fc.Crypto.Enabled != nil </span><span class="cov0" title="0">{
                cfg.Crypto.Enabled = *fc.Crypto.Enabled
        }</span>
        <span class="cov0" title="0">if fc.Crypto.UseSignature != nil </span><span class="cov0" title="0">{
                cfg.Crypto.UseSignature = *fc.Crypto.UseSignature
        }</span>
        <span class="cov0" title="0">if fc.Auth.JWTSecret != "" </span><span class="cov0" title="0">{
                cfg.Auth.JWTSecret = fc.Auth.JWTSecret
        }</span>
        <span class="cov0" title="0">if fc.Auth.TokenTTLHours != nil </span><span class="cov0" title="0">{
                cfg.Auth.TokenTTLHours = *fc.Auth.TokenTTLHours
        }</span>
        <span class="cov0" title="0">if fc.Seed.Enabled </span><span class="cov0" title="0">{
                cfg.Seed.Enabled = fc.Seed.Enabled
        }</span>
        <span class="cov0" title="0">if fc.SuperAdmin.Email != "" </span><span class="cov0" title="0">{
                cfg.SuperAdmin.Email = fc.SuperAdmin.Email
        }</span>
        <span class="cov0" title="0">if fc.SuperAdmin.Password != "" </span><span class="cov0" title="0">{
                cfg.SuperAdmin.Password = fc.SuperAdmin.Password
        }</span>
        <span class="cov0" title="0">if fc.SuperAdmin.Name != "" </span><span class="cov0" title="0">{
                cfg.SuperAdmin.Name = fc.SuperAdmin.Name
        }</span>
        <span class="cov0" title="0">if fc.SuperAdmin.Phone != "" </span><span class="cov0" title="0">{
                cfg.SuperAdmin.Phone = fc.SuperAdmin.Phone
        }</span>
        <span class="cov0" title="0">if fc.AdminAuth.Mode != "" </span><span class="cov0" title="0">{
                cfg.AdminAuth.Mode = fc.AdminAuth.Mode
        }</span>
}

func overrideFromEnv(cfg *AppConfig) <span class="cov8" title="1">{
        if port := os.Getenv("SERVICE_PORT"); port != "" </span><span class="cov8" title="1">{
                cfg.Port = port
        }</span>

        <span class="cov8" title="1">if v := os.Getenv("ENABLE_SWAGGER"); v != "" </span><span class="cov8" title="1">{
                if enabled, err := strconv.ParseBool(v); err != nil </span><span class="cov0" title="0">{
                        log.Printf("ENABLE_SWAGGER=%q 无法解析，保持原值 %v", v, cfg.EnableSwagger)
                }</span> else<span class="cov8" title="1"> {
                        cfg.EnableSwagger = enabled
                }</span>
        }

        <span class="cov8" title="1">if dbType := os.Getenv("DB_TYPE"); dbType != "" </span><span class="cov8" title="1">{
                cfg.Database.Type = normalizeDBType(dbType)
        }</span>

        <span class="cov8" title="1">if dsn := os.Getenv("DB_DSN"); dsn != "" </span><span class="cov8" title="1">{
                cfg.Database.DSN = dsn
        }</span>

        <span class="cov8" title="1">if cacheType := os.Getenv("CACHE_TYPE"); cacheType != "" </span><span class="cov8" title="1">{
                cfg.Cache.Type = strings.ToLower(cacheType)
        }</span>
        <span class="cov8" title="1">if redisAddr := os.Getenv("REDIS_ADDR"); redisAddr != "" </span><span class="cov8" title="1">{
                cfg.Cache.Redis.Addr = redisAddr
        }</span>
        <span class="cov8" title="1">if redisPassword := os.Getenv("REDIS_PASSWORD"); redisPassword != "" </span><span class="cov8" title="1">{
                cfg.Cache.Redis.Password = redisPassword
        }</span>
        <span class="cov8" title="1">if redisDB := os.Getenv("REDIS_DB"); redisDB != "" </span><span class="cov8" title="1">{
                if db, err := strconv.Atoi(redisDB); err != nil </span><span class="cov0" title="0">{
                        log.Printf("REDIS_DB=%q 无法解析，保持原值 %d", redisDB, cfg.Cache.Redis.DB)
                }</span> else<span class="cov8" title="1"> {
                        cfg.Cache.Redis.DB = db
                }</span>
        }

        <span class="cov8" title="1">if v := os.Getenv("CRYPTO_ENABLED"); v != "" </span><span class="cov8" title="1">{
                if enabled, err := strconv.ParseBool(v); err != nil </span><span class="cov0" title="0">{
                        log.Printf("CRYPTO_ENABLED=%q 无法解析，保持原值 %v", v, cfg.Crypto.Enabled)
                }</span> else<span class="cov8" title="1"> {
                        cfg.Crypto.Enabled = enabled
                }</span>
        }
        <span class="cov8" title="1">if secret := os.Getenv("CRYPTO_SECRET_KEY"); secret != "" </span><span class="cov8" title="1">{
                cfg.Crypto.SecretKey = secret
        }</span>
        <span class="cov8" title="1">if iv := os.Getenv("CRYPTO_IV"); iv != "" </span><span class="cov8" title="1">{
                cfg.Crypto.IV = iv
        }</span>
        <span class="cov8" title="1">if methods := os.Getenv("CRYPTO_METHODS"); methods != "" </span><span class="cov8" title="1">{
                cfg.Crypto.Methods = normalizeHTTPMethods(strings.Split(methods, ","))
        }</span>
        <span class="cov8" title="1">if excludes := os.Getenv("CRYPTO_EXCLUDE_PATHS"); excludes != "" </span><span class="cov8" title="1">{
                cfg.Crypto.ExcludePaths = normalizePaths(strings.Split(excludes, ","))
        }</span>
        <span class="cov8" title="1">if useSignature := os.Getenv("CRYPTO_USE_SIGNATURE"); useSignature != "" </span><span class="cov8" title="1">{
                if enabled, err := strconv.ParseBool(useSignature); err != nil </span><span class="cov0" title="0">{
                        log.Printf("CRYPTO_USE_SIGNATURE=%q 无法解析，保持原值 %v", useSignature, cfg.Crypto.UseSignature)
                }</span> else<span class="cov8" title="1"> {
                        cfg.Crypto.UseSignature = enabled
                }</span>
        }

        <span class="cov8" title="1">if jwtSecret := os.Getenv("JWT_SECRET_KEY"); jwtSecret != "" </span><span class="cov8" title="1">{
                cfg.Auth.JWTSecret = jwtSecret
        }</span>
        <span class="cov8" title="1">if ttl := os.Getenv("JWT_TOKEN_TTL_HOURS"); ttl != "" </span><span class="cov8" title="1">{
                if hours, err := strconv.Atoi(ttl); err != nil </span><span class="cov0" title="0">{
                        log.Printf("JWT_TOKEN_TTL_HOURS=%q 无法解析，保持原值 %d", ttl, cfg.Auth.TokenTTLHours)
                }</span> else<span class="cov8" title="1"> {
                        cfg.Auth.TokenTTLHours = hours
                }</span>
        }

        <span class="cov8" title="1">if seed := os.Getenv("SEED_ENABLED"); seed != "" </span><span class="cov8" title="1">{
                if enabled, err := strconv.ParseBool(seed); err != nil </span><span class="cov0" title="0">{
                        log.Printf("SEED_ENABLED=%q 无法解析，保持原值 %v", seed, cfg.Seed.Enabled)
                }</span> else<span class="cov8" title="1"> {
                        cfg.Seed.Enabled = enabled
                }</span>
        }

        // 超级管理员配置
        <span class="cov8" title="1">if email := os.Getenv("SUPER_ADMIN_EMAIL"); email != "" </span><span class="cov0" title="0">{
                cfg.SuperAdmin.Email = email
        }</span>
        <span class="cov8" title="1">if password := os.Getenv("SUPER_ADMIN_PASSWORD"); password != "" </span><span class="cov0" title="0">{
                cfg.SuperAdmin.Password = password
        }</span>
        <span class="cov8" title="1">if name := os.Getenv("SUPER_ADMIN_NAME"); name != "" </span><span class="cov0" title="0">{
                cfg.SuperAdmin.Name = name
        }</span>
        <span class="cov8" title="1">if phone := os.Getenv("SUPER_ADMIN_PHONE"); phone != "" </span><span class="cov0" title="0">{
                cfg.SuperAdmin.Phone = phone
        }</span>

        // 管理员认证模式
        <span class="cov8" title="1">if mode := os.Getenv("ADMIN_AUTH_MODE"); mode != "" </span><span class="cov0" title="0">{
                cfg.AdminAuth.Mode = strings.ToLower(mode)
        }</span>
}

func normalizeHTTPMethods(methods []string) []string <span class="cov8" title="1">{
        var normalized []string
        for _, method := range methods </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(strings.ToUpper(method))
                if trimmed == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">normalized = append(normalized, trimmed)</span>
        }
        <span class="cov8" title="1">if len(normalized) == 0 </span><span class="cov8" title="1">{
                return []string{"POST", "PUT", "PATCH"}
        }</span>
        <span class="cov8" title="1">return normalized</span>
}

func normalizePaths(paths []string) []string <span class="cov8" title="1">{
        var normalized []string
        for _, path := range paths </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(path)
                if trimmed == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">normalized = append(normalized, trimmed)</span>
        }
        <span class="cov8" title="1">return normalized</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package config

import "errors"

// Validate checks configuration for required values in production.
func Validate(env string, cfg AppConfig) error <span class="cov8" title="1">{
        if env == "production" </span><span class="cov8" title="1">{
                if cfg.Database.DSN == "" </span><span class="cov8" title="1">{
                        return errors.New("DB_DSN is required in production")
                }</span>
        }
        <span class="cov8" title="1">if cfg.Crypto.Enabled </span><span class="cov8" title="1">{
                keyLen := len(cfg.Crypto.SecretKey)
                if keyLen != 16 &amp;&amp; keyLen != 24 &amp;&amp; keyLen != 32 </span><span class="cov8" title="1">{
                        return errors.New("CRYPTO_SECRET_KEY must be 16, 24 or 32 bytes when encryption is enabled")
                }</span>
                <span class="cov8" title="1">if len(cfg.Crypto.IV) &lt; 16 </span><span class="cov8" title="1">{
                        return errors.New("CRYPTO_IV must be at least 16 bytes when encryption is enabled")
                }</span>
                <span class="cov8" title="1">if len(cfg.Crypto.Methods) == 0 </span><span class="cov8" title="1">{
                        return errors.New("crypto methods must not be empty when encryption is enabled")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package db

import (
        "fmt"

        "gorm.io/gorm"

        "gamelink/internal/config"
)

// Open 根据配置创建数据库连接。
func Open(cfg config.AppConfig) (*gorm.DB, error) <span class="cov8" title="1">{
        switch cfg.Database.Type </span>{
        case "sqlite":<span class="cov8" title="1">
                return openSQLite(cfg)</span>
        case "postgres":<span class="cov0" title="0">
                return openPostgres(cfg)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("暂不支持的数据库类型: %s", cfg.Database.Type)</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package db

import (
        "errors"
        "fmt"
        "log"
        "os"
        "strings"
        "time"

        "golang.org/x/crypto/bcrypt"
        "gorm.io/gorm"

        "gamelink/internal/config"
        "gamelink/internal/model"
)

// prepareOrdersMigration 在 autoMigrate 之前处理 orders 表的字段迁移
func prepareOrdersMigration(db *gorm.DB) error <span class="cov8" title="1">{
        // 检查 orders 表是否存在
        var tableExists bool
        if err := db.Raw("SELECT COUNT(*) &gt; 0 FROM sqlite_master WHERE type='table' AND name='orders'").Scan(&amp;tableExists).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !tableExists </span><span class="cov8" title="1">{
                return nil // 表不存在，autoMigrate 会创建
        }</span>

        // 检查并添加 item_id 字段（如果不存在）
        <span class="cov8" title="1">var itemIDExists bool
        if err := db.Raw("SELECT COUNT(*) &gt; 0 FROM pragma_table_info('orders') WHERE name='item_id'").Scan(&amp;itemIDExists).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !itemIDExists </span><span class="cov0" title="0">{
                // 先添加字段（允许 NULL），设置默认值为 1（临时默认服务项）
                if err := db.Exec("ALTER TABLE orders ADD COLUMN item_id integer DEFAULT 1").Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // 更新所有现有订单的 item_id 为 1
                <span class="cov0" title="0">if err := db.Exec("UPDATE orders SET item_id = 1 WHERE item_id IS NULL").Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // 检查并添加 order_no 字段（如果不存在）
        <span class="cov8" title="1">var orderNoExists bool
        if err := db.Raw("SELECT COUNT(*) &gt; 0 FROM pragma_table_info('orders') WHERE name='order_no'").Scan(&amp;orderNoExists).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !orderNoExists </span><span class="cov0" title="0">{
                // 添加 order_no 字段（允许 NULL）
                if err := db.Exec("ALTER TABLE orders ADD COLUMN order_no text").Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // 检查并添加 unit_price_cents 字段（如果不存在）
        <span class="cov8" title="1">var unitPriceExists bool
        if err := db.Raw("SELECT COUNT(*) &gt; 0 FROM pragma_table_info('orders') WHERE name='unit_price_cents'").Scan(&amp;unitPriceExists).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !unitPriceExists </span><span class="cov0" title="0">{
                // 添加字段（默认值为 0）
                if err := db.Exec("ALTER TABLE orders ADD COLUMN unit_price_cents integer DEFAULT 0").Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // 如果有 price_cents 字段，从中迁移数据
                <span class="cov0" title="0">var oldPriceExists bool
                if err := db.Raw("SELECT COUNT(*) &gt; 0 FROM pragma_table_info('orders') WHERE name='price_cents'").Scan(&amp;oldPriceExists).Error; err == nil &amp;&amp; oldPriceExists </span><span class="cov0" title="0">{
                        if err := db.Exec("UPDATE orders SET unit_price_cents = price_cents WHERE unit_price_cents = 0").Error; err != nil </span><span class="cov0" title="0">{
                                log.Printf("warning: failed to migrate price_cents to unit_price_cents: %v", err)
                        }</span>
                }
        }

        // 检查并添加 total_price_cents 字段（如果不存在）
        <span class="cov8" title="1">var totalPriceExists bool
        if err := db.Raw("SELECT COUNT(*) &gt; 0 FROM pragma_table_info('orders') WHERE name='total_price_cents'").Scan(&amp;totalPriceExists).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !totalPriceExists </span><span class="cov0" title="0">{
                // 添加字段（默认值为 0）
                if err := db.Exec("ALTER TABLE orders ADD COLUMN total_price_cents integer DEFAULT 0").Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // 如果有 price_cents 字段，从中迁移数据
                <span class="cov0" title="0">var oldPriceExists bool
                if err := db.Raw("SELECT COUNT(*) &gt; 0 FROM pragma_table_info('orders') WHERE name='price_cents'").Scan(&amp;oldPriceExists).Error; err == nil &amp;&amp; oldPriceExists </span><span class="cov0" title="0">{
                        if err := db.Exec("UPDATE orders SET total_price_cents = price_cents WHERE total_price_cents = 0").Error; err != nil </span><span class="cov0" title="0">{
                                log.Printf("warning: failed to migrate price_cents to total_price_cents: %v", err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func autoMigrate(db *gorm.DB) error <span class="cov8" title="1">{
        // 临时禁用外键检查（SQLite）
        db.Exec("PRAGMA foreign_keys = OFF")
        defer db.Exec("PRAGMA foreign_keys = ON")

        // 先处理 orders 表的特殊字段
        if err := prepareOrdersMigration(db); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return db.AutoMigrate(
                &amp;model.Game{},
                &amp;model.Player{},
                &amp;model.PlayerGame{},
                &amp;model.PlayerSkillTag{},
                &amp;model.User{},
                &amp;model.Order{},
                &amp;model.Payment{},
                &amp;model.Review{},
                &amp;model.Withdraw{},
                &amp;model.OperationLog{},
                // Service Item (统一管理护航服务和礼物)
                &amp;model.ServiceItem{},
                // Commission models
                &amp;model.CommissionRule{},
                &amp;model.CommissionRecord{},
                &amp;model.MonthlySettlement{},
                // Ranking models
                &amp;model.PlayerRanking{},
                &amp;model.RankingCommissionConfig{},
                // RBAC models
                &amp;model.Permission{},
                &amp;model.RoleModel{},
                &amp;model.RolePermission{},
                &amp;model.UserRole{},
        )</span>
}

// runDataFixups contains data migrations that adjust existing values.
// It is idempotent and safe to run at startup.
func runDataFixups(db *gorm.DB) error <span class="cov8" title="1">{
        // Normalize order status spelling: "cancelled" -&gt; "canceled" //nolint:misspell // legacy spelling retained for clarity
        if err := db.Exec("UPDATE orders SET status='canceled' WHERE status='cancelled'").Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Generate OrderNo for existing orders without one
        <span class="cov8" title="1">if err := generateOrderNumbers(db); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Clamp player rating average to [0,5] and set negative counts to 0
        <span class="cov8" title="1">if err := db.Exec("UPDATE players SET rating_average = CASE WHEN rating_average &lt; 0 THEN 0 WHEN rating_average &gt; 5 THEN 5 ELSE rating_average END").Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := db.Exec("UPDATE players SET rating_count = 0 WHERE rating_count &lt; 0").Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Ensure RBAC default roles exist
        <span class="cov8" title="1">if err := ensureDefaultRoles(db); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Ensure default commission rule exists
        <span class="cov8" title="1">if err := ensureDefaultCommissionRule(db); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return ensureSuperAdmin(db)</span>
}

func ensureIndexes(db *gorm.DB) error <span class="cov8" title="1">{
        stmts := []string{
                // Orders composite indexes
                "CREATE INDEX IF NOT EXISTS idx_orders_status_created ON orders (status, created_at DESC)",
                "CREATE INDEX IF NOT EXISTS idx_orders_user_created ON orders (user_id, created_at DESC)",
                "CREATE INDEX IF NOT EXISTS idx_orders_player_created ON orders (player_id, created_at DESC)",
                "CREATE INDEX IF NOT EXISTS idx_orders_game_created ON orders (game_id, created_at DESC)",
                // Payments composite indexes
                "CREATE INDEX IF NOT EXISTS idx_payments_status_created ON payments (status, created_at DESC)",
                "CREATE INDEX IF NOT EXISTS idx_payments_user_created ON payments (user_id, created_at DESC)",
                "CREATE INDEX IF NOT EXISTS idx_payments_order_created ON payments (order_id, created_at DESC)",
                // Withdraws composite indexes
                "CREATE INDEX IF NOT EXISTS idx_withdraws_status_created ON withdraws (status, created_at DESC)",
                "CREATE INDEX IF NOT EXISTS idx_withdraws_player_created ON withdraws (player_id, created_at DESC)",
                "CREATE INDEX IF NOT EXISTS idx_withdraws_user_created ON withdraws (user_id, created_at DESC)",
                // Service Items indexes
                "CREATE INDEX IF NOT EXISTS idx_service_items_game_subcat ON service_items (game_id, sub_category)",
                "CREATE INDEX IF NOT EXISTS idx_service_items_subcat_active ON service_items (sub_category, is_active)",
                "CREATE INDEX IF NOT EXISTS idx_orders_item_created ON orders (item_id, created_at DESC)",
                "CREATE INDEX IF NOT EXISTS idx_orders_recipient_player ON orders (recipient_player_id, created_at DESC)",
                // Commission indexes
                "CREATE INDEX IF NOT EXISTS idx_commission_records_player_month ON commission_records (player_id, settlement_month)",
                "CREATE INDEX IF NOT EXISTS idx_commission_records_status_month ON commission_records (settlement_status, settlement_month)",
                "CREATE INDEX IF NOT EXISTS idx_monthly_settlements_player_month ON monthly_settlements (player_id, settlement_month)",
                "CREATE INDEX IF NOT EXISTS idx_monthly_settlements_month_status ON monthly_settlements (settlement_month, status)",
                // Operation logs indexes
                "CREATE INDEX IF NOT EXISTS idx_oplogs_entity ON operation_logs (entity_type, entity_id, created_at DESC)",
                "CREATE INDEX IF NOT EXISTS idx_oplogs_actor ON operation_logs (actor_user_id, created_at DESC)",
                "CREATE INDEX IF NOT EXISTS idx_oplogs_action ON operation_logs (action, created_at DESC)",
        }
        for _, s := range stmts </span><span class="cov8" title="1">{
                if err := db.Exec(s).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ensureDefaultRoles creates system predefined roles if they don't exist.
func ensureDefaultRoles(db *gorm.DB) error <span class="cov8" title="1">{
        roles := []model.RoleModel{
                {
                        Slug:        string(model.RoleSlugSuperAdmin),
                        Name:        "超级管理员",
                        Description: "拥有系统所有权限，不可删除",
                        IsSystem:    true,
                },
                {
                        Slug:        string(model.RoleSlugAdmin),
                        Name:        "管理员",
                        Description: "后台管理权限",
                        IsSystem:    true,
                },
                {
                        Slug:        string(model.RoleSlugPlayer),
                        Name:        "陪玩师",
                        Description: "提供陪玩服务的用户",
                        IsSystem:    true,
                },
                {
                        Slug:        string(model.RoleSlugUser),
                        Name:        "普通用户",
                        Description: "平台普通用户",
                        IsSystem:    true,
                },
        }

        for i := range roles </span><span class="cov8" title="1">{
                role := &amp;roles[i]
                var existing model.RoleModel
                err := db.Where("slug = ?", role.Slug).First(&amp;existing).Error
                if err == nil </span><span class="cov8" title="1">{
                        // Role exists, update description if needed
                        if existing.Name != role.Name || existing.Description != role.Description </span><span class="cov0" title="0">{
                                db.Model(&amp;existing).Updates(map[string]interface{}{
                                        "name":        role.Name,
                                        "description": role.Description,
                                        "is_system":   true,
                                })
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">if !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return err
                }</span>
                // Create new role
                <span class="cov8" title="1">if err := db.Create(role).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">log.Printf("created system role: %s (id=%d)", role.Slug, role.ID)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func ensureSuperAdmin(db *gorm.DB) error <span class="cov8" title="1">{
        cfg := config.Load()
        env := strings.TrimSpace(os.Getenv("APP_ENV"))
        email := strings.TrimSpace(cfg.SuperAdmin.Email)
        phone := strings.TrimSpace(cfg.SuperAdmin.Phone)
        name := strings.TrimSpace(cfg.SuperAdmin.Name)
        password := cfg.SuperAdmin.Password

        if name == "" </span><span class="cov0" title="0">{
                name = "Super Admin"
        }</span>

        <span class="cov8" title="1">if email == "" &amp;&amp; phone == "" </span><span class="cov0" title="0">{
                if env == "production" </span><span class="cov0" title="0">{
                        return errors.New("SUPER_ADMIN_EMAIL or SUPER_ADMIN_PHONE must be set in production")
                }</span>
                <span class="cov0" title="0">email = "admin@gamelink.local"</span>
        }

        <span class="cov8" title="1">if password == "" </span><span class="cov0" title="0">{
                if env == "production" </span><span class="cov0" title="0">{
                        return errors.New("SUPER_ADMIN_PASSWORD must be set in production")
                }</span>
                <span class="cov0" title="0">password = "Admin@123456"</span>
        }

        // Avoid unique constraint conflicts when phone 为空且已有空手机号行
        <span class="cov8" title="1">if phone == "" </span><span class="cov8" title="1">{
                phone = fmt.Sprintf("superadmin-%d", time.Now().UnixNano())
        }</span>

        <span class="cov8" title="1">lookup := db.Model(&amp;model.User{})
        if email != "" </span><span class="cov8" title="1">{
                lookup = lookup.Where("email = ?", email)
        }</span> else<span class="cov0" title="0"> {
                lookup = lookup.Where("phone = ?", phone)
        }</span>

        <span class="cov8" title="1">var existing model.User
        err := lookup.First(&amp;existing).Error
        switch </span>{
        case err == nil:<span class="cov8" title="1">
                return nil</span>
        case errors.Is(err, gorm.ErrRecordNotFound):<span class="cov8" title="1"></span>
                // fall through and create admin user
        default:<span class="cov0" title="0">
                return err</span>
        }

        <span class="cov8" title="1">hashed, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">admin := &amp;model.User{
                Name:         name,
                Email:        email,
                Phone:        phone,
                PasswordHash: string(hashed),
                Role:         model.RoleAdmin,
                Status:       model.UserStatusActive,
        }

        if err := db.Create(admin).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Assign super_admin role to this user
        <span class="cov8" title="1">var superAdminRole model.RoleModel
        if err := db.Where("slug = ?", model.RoleSlugSuperAdmin).First(&amp;superAdminRole).Error; err != nil </span><span class="cov0" title="0">{
                log.Printf("warning: super_admin role not found, skipping role assignment: %v", err)
        }</span> else<span class="cov8" title="1"> {
                // Check if user already has the role
                var existingUserRole model.UserRole
                err := db.Where("user_id = ? AND role_id = ?", admin.ID, superAdminRole.ID).First(&amp;existingUserRole).Error
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        // Assign role
                        userRole := &amp;model.UserRole{
                                UserID: admin.ID,
                                RoleID: superAdminRole.ID,
                        }
                        if err := db.Create(userRole).Error; err != nil </span><span class="cov0" title="0">{
                                log.Printf("warning: failed to assign super_admin role: %v", err)
                        }</span> else<span class="cov8" title="1"> {
                                log.Printf("assigned super_admin role to user id=%d", admin.ID)
                        }</span>
                }
        }

        <span class="cov8" title="1">log.Printf("super admin user ensured: email=%s phone=%s id=%d", email, phone, admin.ID)
        return nil</span>
}

// generateOrderNumbers 为没有订单号的订单生成订单号
func generateOrderNumbers(db *gorm.DB) error <span class="cov8" title="1">{
        // 查询所有没有订单号的订单（空字符串或NULL）
        var orders []model.Order
        if err := db.Where("order_no = ? OR order_no IS NULL OR TRIM(order_no) = ''", "").Find(&amp;orders).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(orders) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">log.Printf("generating order numbers for %d orders", len(orders))

        // 为每个订单生成唯一订单号
        timestamp := time.Now().Unix()
        for i := range orders </span><span class="cov0" title="0">{
                // 格式: ORD + 时间戳 + 订单ID (确保唯一性)
                orderNo := fmt.Sprintf("ORD%d%08d", timestamp, orders[i].ID)
                if err := db.Model(&amp;orders[i]).Update("order_no", orderNo).Error; err != nil </span><span class="cov0" title="0">{
                        log.Printf("warning: failed to update order %d: %v", orders[i].ID, err)
                        continue</span> // 继续处理其他订单，不要中断整个流程
                }
        }

        <span class="cov0" title="0">log.Printf("successfully generated order numbers for %d orders", len(orders))
        return nil</span>
}

// ensureDefaultCommissionRule 确保默认抽成规则存在
func ensureDefaultCommissionRule(db *gorm.DB) error <span class="cov8" title="1">{
        var existing model.CommissionRule
        err := db.Where("type = ? AND is_active = ?", "default", true).
                Where("game_id IS NULL AND player_id IS NULL AND service_type IS NULL").
                First(&amp;existing).Error

        if err == nil </span><span class="cov8" title="1">{
                // 默认规则已存在
                return nil
        }</span>

        <span class="cov8" title="1">if !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return err
        }</span>

        // 创建默认抽成规则：20%
        <span class="cov8" title="1">defaultRule := &amp;model.CommissionRule{
                Name:        "默认抽成规则",
                Description: "平台默认抽成比例为20%",
                Type:        "default",
                Rate:        20,
                IsActive:    true,
        }

        if err := db.Create(defaultRule).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">log.Printf("created default commission rule: 20%% (id=%d)", defaultRule.ID)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package db

import (
        "fmt"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"

        "gamelink/internal/config"
        "gamelink/internal/metrics"
)

func openPostgres(cfg config.AppConfig) (*gorm.DB, error) <span class="cov0" title="0">{
        gormDB, err := gorm.Open(postgres.Open(cfg.Database.DSN), &amp;gorm.Config{
                Logger: logger.Default.LogMode(logger.Warn),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("打开 postgres 失败: %w", err)
        }</span>

        <span class="cov0" title="0">if err := configureConnection(gormDB, 25); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := autoMigrate(gormDB); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := runDataFixups(gormDB); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := ensureIndexes(gormDB); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if cfg.Seed.Enabled </span><span class="cov0" title="0">{
                if err := applySeeds(gormDB); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">_ = metrics.InstrumentGorm(gormDB)

        return gormDB, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package db

import (
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "strings"
        "time"

        "golang.org/x/crypto/bcrypt"
        "gorm.io/gorm"

        "gamelink/internal/model"
)

type seedUserInput struct {
        Key      string
        Email    string
        Phone    string
        Name     string
        Role     model.Role
        Password string
}

type seedPlayerSpec struct {
        Key                string
        UserKey            string
        Nickname           string
        Bio                string
        RatingAverage      float32
        RatingCount        uint32
        HourlyRateCents    int64
        MainGameKey        string
        VerificationStatus model.VerificationStatus
}

type seedOrderSpec struct {
        Key          string
        UserKey      string
        PlayerKey    string
        GameKey      string
        Title        string
        Description  string
        Status       model.OrderStatus
        PriceCents   int64
        Currency     model.Currency
        StartOffset  time.Duration
        Duration     time.Duration
        CancelReason string
}

type seedPaymentSpec struct {
        OrderKey        string
        UserKey         string
        Method          model.PaymentMethod
        AmountCents     int64
        Currency        model.Currency
        Status          model.PaymentStatus
        ProviderTradeNo string
        ProviderRaw     string
        PaidAtOffset    *time.Duration
        RefundedOffset  *time.Duration
}

type seedReviewSpec struct {
        OrderKey  string
        UserKey   string
        PlayerKey string
        Score     model.Rating
        Content   string
}

func applySeeds(db *gorm.DB) error <span class="cov8" title="1">{
        return db.Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                games, err := seedGames(tx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">now := time.Now()

                userInputs := []seedUserInput{
                        {Key: "customerA", Email: "demo.user@gamelink.com", Phone: "13800138000", Name: "测试用户", Role: model.RoleUser, Password: "User@123456"},
                        {Key: "proA", Email: "pro.player@gamelink.com", Phone: "13800138001", Name: "职业陪玩", Role: model.RolePlayer, Password: "Player@123456"},
                        {Key: "customerB", Email: "vip.user@gamelink.com", Phone: "13800138002", Name: "高级会员", Role: model.RoleUser, Password: "Vip@123456"},
                        {Key: "customerC", Email: "new.user@gamelink.com", Phone: "13800138003", Name: "体验用户", Role: model.RoleUser, Password: "User@123789"},
                        {Key: "proB", Email: "streamer@gamelink.com", Phone: "13800138004", Name: "魔王主播", Role: model.RolePlayer, Password: "Player@654321"},
                        {Key: "adminA", Email: "admin@gamelink.com", Phone: "13800138005", Name: "系统管理员", Role: model.RoleAdmin, Password: "Admin@123456"},
                        {Key: "customerD", Email: "casual.player@gamelink.com", Phone: "13800138006", Name: "休闲玩家", Role: model.RoleUser, Password: "User@123789"},
                        {Key: "customerE", Email: "competitive.gamer@gamelink.com", Phone: "13800138007", Name: "竞技高手", Role: model.RoleUser, Password: "User@456789"},
                        {Key: "proC", Email: "fps.master@gamelink.com", Phone: "13800138008", Name: "FPS大神", Role: model.RolePlayer, Password: "Player@987654"},
                        {Key: "proD", Email: "rpg.explorer@gamelink.com", Phone: "13800138009", Name: "RPG探险家", Role: model.RolePlayer, Password: "Player@456123"},
                        {Key: "customerF", Email: "weekend.gamer@gamelink.com", Phone: "13800138010", Name: "周末玩家", Role: model.RoleUser, Password: "User@789456"},
                        {Key: "proE", Email: "sports.champion@gamelink.com", Phone: "13800138011", Name: "体育冠军", Role: model.RolePlayer, Password: "Player@789012"},
                        {Key: "customerG", Email: "newbie.player@gamelink.com", Phone: "13800138012", Name: "新手玩家", Role: model.RoleUser, Password: "User@234567"},
                        {Key: "proF", Email: "party.entertainer@gamelink.com", Phone: "13800138013", Name: "派对达人", Role: model.RolePlayer, Password: "Player@345678"},
                        {Key: "customerH", Email: "business.professional@gamelink.com", Phone: "13800138014", Name: "商务人士", Role: model.RoleUser, Password: "User@567890"},
                }

                users := make(map[string]*model.User, len(userInputs))
                for _, input := range userInputs </span><span class="cov8" title="1">{
                        user, err := seedUser(tx, input)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">users[input.Key] = user</span>
                }

                <span class="cov8" title="1">playerSpecs := []seedPlayerSpec{
                        {
                                Key:                "playerA",
                                UserKey:            "proA",
                                Nickname:           "峡谷守护者",
                                Bio:                "全职陪玩，擅长打野位，帮助玩家快速上分。国服前100玩家。",
                                RatingAverage:      4.9,
                                RatingCount:        152,
                                HourlyRateCents:    9900,
                                MainGameKey:        "lol",
                                VerificationStatus: model.VerificationVerified,
                        },
                        {
                                Key:                "playerB",
                                UserKey:            "proB",
                                Nickname:           "王牌射手",
                                Bio:                "FPS 资深选手，提供高强度陪练服务。参加过多次线下比赛。",
                                RatingAverage:      4.7,
                                RatingCount:        98,
                                HourlyRateCents:    12900,
                                MainGameKey:        "valorant",
                                VerificationStatus: model.VerificationVerified,
                        },
                        {
                                Key:                "playerC",
                                UserKey:            "proC",
                                Nickname:           "枪神降临",
                                Bio:                "CS:GO职业选手，退役后专注陪玩教学。枪法精准，战术理解深入。",
                                RatingAverage:      4.8,
                                RatingCount:        127,
                                HourlyRateCents:    15900,
                                MainGameKey:        "csgo",
                                VerificationStatus: model.VerificationVerified,
                        },
                        {
                                Key:                "playerD",
                                UserKey:            "proD",
                                Nickname:           "异世界旅者",
                                Bio:                "RPG游戏专家，熟悉各种MMORPG机制。带新手快速上手，老玩家攻克难关。",
                                RatingAverage:      4.6,
                                RatingCount:        89,
                                HourlyRateCents:    11900,
                                MainGameKey:        "wow",
                                VerificationStatus: model.VerificationVerified,
                        },
                        {
                                Key:                "playerE",
                                UserKey:            "proE",
                                Nickname:           "运动健将",
                                Bio:                "FIFA/NBA2K专业玩家，体育游戏发烧友。战术教学，技巧提升。",
                                RatingAverage:      4.5,
                                RatingCount:        76,
                                HourlyRateCents:    8900,
                                MainGameKey:        "fifa",
                                VerificationStatus: model.VerificationVerified,
                        },
                        {
                                Key:                "playerF",
                                UserKey:            "proF",
                                Nickname:           "欢乐使者",
                                Bio:                "派对游戏达人，擅长各种休闲游戏。轻松愉快的陪玩体验。",
                                RatingAverage:      4.9,
                                RatingCount:        203,
                                HourlyRateCents:    7900,
                                MainGameKey:        "fallguys",
                                VerificationStatus: model.VerificationVerified,
                        },
                        {
                                Key:                "playerG",
                                UserKey:            "proA",
                                Nickname:           "DOTA宗师",
                                Bio:                "DOTA2老玩家，精通所有英雄。从新手教学到高端局指导全覆盖。",
                                RatingAverage:      4.8,
                                RatingCount:        143,
                                HourlyRateCents:    13900,
                                MainGameKey:        "dota2",
                                VerificationStatus: model.VerificationVerified,
                        },
                        {
                                Key:                "playerH",
                                UserKey:            "proC",
                                Nickname:           "大逃杀之王",
                                Bio:                "PUBG/Apex资深玩家，枪法犀利，吃鸡率高。带你享受刺激的生存体验。",
                                RatingAverage:      4.4,
                                RatingCount:        67,
                                HourlyRateCents:    10900,
                                MainGameKey:        "pubg",
                                VerificationStatus: model.VerificationPending,
                        },
                }

                players := make(map[string]*model.Player, len(playerSpecs))
                for _, spec := range playerSpecs </span><span class="cov8" title="1">{
                        user, ok := users[spec.UserKey]
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("seed player missing user %s", spec.UserKey)
                        }</span>
                        <span class="cov8" title="1">game, ok := games[spec.MainGameKey]
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("seed player missing game %s", spec.MainGameKey)
                        }</span>
                        <span class="cov8" title="1">player, err := seedPlayer(tx, seedPlayerParams{
                                UserID:             user.ID,
                                Nickname:           spec.Nickname,
                                Bio:                spec.Bio,
                                RatingAverage:      spec.RatingAverage,
                                RatingCount:        spec.RatingCount,
                                HourlyRateCents:    spec.HourlyRateCents,
                                MainGameID:         game.ID,
                                VerificationStatus: spec.VerificationStatus,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">players[spec.Key] = player</span>
                }

                <span class="cov8" title="1">hour := time.Hour

                orderSpecs := []seedOrderSpec{
                        {
                                Key:         "orderCompleted1",
                                UserKey:     "customerA",
                                PlayerKey:   "playerA",
                                GameKey:     "lol",
                                Title:       "欢迎体验 GameLink 陪玩",
                                Description: "我们为您匹配了经验丰富的高胜率陪玩，尽情享受游戏时光吧！",
                                Status:      model.OrderStatusCompleted,
                                PriceCents:  19900,
                                Currency:    model.CurrencyCNY,
                                StartOffset: -3 * hour,
                                Duration:    1 * hour,
                        },
                        {
                                Key:         "orderInProgress1",
                                UserKey:     "customerB",
                                PlayerKey:   "playerA",
                                GameKey:     "dota2",
                                Title:       "高端局连胜陪玩",
                                Description: "DOTA2 冠军陪练，助你提升团队协作。",
                                Status:      model.OrderStatusInProgress,
                                PriceCents:  29900,
                                Currency:    model.CurrencyCNY,
                                StartOffset: -1 * hour,
                                Duration:    2 * hour,
                        },
                        {
                                Key:         "orderPending1",
                                UserKey:     "customerC",
                                PlayerKey:   "playerA",
                                GameKey:     "lol",
                                Title:       "黄金段位冲刺",
                                Description: "等待分配陪玩师，预计 30 分钟内开始。",
                                Status:      model.OrderStatusPending,
                                PriceCents:  15900,
                                Currency:    model.CurrencyCNY,
                                StartOffset: 1 * hour,
                                Duration:    90 * time.Minute,
                        },
                        {
                                Key:          "orderCanceled1",
                                UserKey:      "customerB",
                                PlayerKey:    "playerB",
                                GameKey:      "valorant",
                                Title:        "战术射击训练营",
                                Description:  "因临时有事取消，等待重新安排。",
                                Status:       model.OrderStatusCanceled,
                                PriceCents:   12900,
                                Currency:     model.CurrencyCNY,
                                StartOffset:  -5 * hour,
                                Duration:     2 * hour,
                                CancelReason: "用户主动取消",
                        },
                        {
                                Key:         "orderConfirmed1",
                                UserKey:     "customerD",
                                PlayerKey:   "playerC",
                                GameKey:     "csgo",
                                Title:       "枪法强化训练",
                                Description: "专业CS:GO选手带你提升枪法，从基础到进阶全覆盖。",
                                Status:      model.OrderStatusConfirmed,
                                PriceCents:  18900,
                                Currency:    model.CurrencyCNY,
                                StartOffset: 30 * time.Minute,
                                Duration:    2 * hour,
                        },
                        {
                                Key:         "orderPending2",
                                UserKey:     "customerE",
                                PlayerKey:   "playerB",
                                GameKey:     "apex",
                                Title:       "大逃杀双人排位",
                                Description: "寻找志同道合的队友一起冲击更高段位。",
                                Status:      model.OrderStatusPending,
                                PriceCents:  9900,
                                Currency:    model.CurrencyCNY,
                                StartOffset: 2 * hour,
                                Duration:    3 * hour,
                        },
                        {
                                Key:         "orderCompleted2",
                                UserKey:     "customerF",
                                PlayerKey:   "playerD",
                                GameKey:     "wow",
                                Title:       "魔兽世界副本开荒",
                                Description: "资深玩家带你体验经典副本，了解游戏机制和装备获取。",
                                Status:      model.OrderStatusCompleted,
                                PriceCents:  24900,
                                Currency:    model.CurrencyCNY,
                                StartOffset: -6 * hour,
                                Duration:    4 * hour,
                        },
                        {
                                Key:         "orderInProgress2",
                                UserKey:     "customerG",
                                PlayerKey:   "playerE",
                                GameKey:     "fifa",
                                Title:       "FIFA在线友谊赛",
                                Description: "体育游戏爱好者之间的友好比赛，享受竞技乐趣。",
                                Status:      model.OrderStatusInProgress,
                                PriceCents:  7900,
                                Currency:    model.CurrencyCNY,
                                StartOffset: -30 * time.Minute,
                                Duration:    90 * time.Minute,
                        },
                        {
                                Key:         "orderPending3",
                                UserKey:     "customerH",
                                PlayerKey:   "playerF",
                                GameKey:     "fallguys",
                                Title:       "糖豆人欢乐时光",
                                Description: "轻松愉快的派对游戏，适合休闲娱乐，放松心情。",
                                Status:      model.OrderStatusPending,
                                PriceCents:  5900,
                                Currency:    model.CurrencyCNY,
                                StartOffset: 4 * hour,
                                Duration:    2 * hour,
                        },
                        {
                                Key:          "orderRefunded1",
                                UserKey:      "customerA",
                                PlayerKey:    "playerB",
                                GameKey:      "overwatch",
                                Title:        "守望先锋团队竞技",
                                Description:  "因技术问题服务器维护，全额退款。",
                                Status:       model.OrderStatusRefunded,
                                PriceCents:   16900,
                                Currency:     model.CurrencyCNY,
                                StartOffset:  -2 * hour,
                                Duration:     90 * time.Minute,
                                CancelReason: "服务器维护退款",
                        },
                        {
                                Key:         "orderConfirmed2",
                                UserKey:     "customerB",
                                PlayerKey:   "playerG",
                                GameKey:     "dota2",
                                Title:       "DOTA2新手教学",
                                Description: "DOTA2老玩家带你熟悉游戏机制，学习基础操作和战术理解。",
                                Status:      model.OrderStatusConfirmed,
                                PriceCents:  21900,
                                Currency:    model.CurrencyCNY,
                                StartOffset: 1 * hour,
                                Duration:    3 * hour,
                        },
                }

                orders := make(map[string]*model.Order, len(orderSpecs))
                for _, spec := range orderSpecs </span><span class="cov8" title="1">{
                        user, ok := users[spec.UserKey]
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("seed order missing user %s", spec.UserKey)
                        }</span>
                        <span class="cov8" title="1">game, ok := games[spec.GameKey]
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("seed order missing game %s", spec.GameKey)
                        }</span>
                        <span class="cov8" title="1">var playerID *uint64
                        if spec.PlayerKey != "" </span><span class="cov8" title="1">{
                                player, ok := players[spec.PlayerKey]
                                if !ok </span><span class="cov0" title="0">{
                                        return fmt.Errorf("seed order missing player %s", spec.PlayerKey)
                                }</span>
                                <span class="cov8" title="1">playerID = &amp;player.ID</span>
                        }
                        <span class="cov8" title="1">var startPtr, endPtr *time.Time
                        if spec.StartOffset != 0 || spec.Duration != 0 </span><span class="cov8" title="1">{
                                startTime := now.Add(spec.StartOffset)
                                startPtr = ptrTime(startTime)
                                if spec.Duration != 0 </span><span class="cov8" title="1">{
                                        endPtr = ptrTime(startTime.Add(spec.Duration))
                                }</span>
                        }
                        <span class="cov8" title="1">var startedAt, completedAt *time.Time
                        switch spec.Status </span>{
                        case model.OrderStatusInProgress, model.OrderStatusCompleted:<span class="cov8" title="1">
                                startedAt = startPtr</span>
                        }
                        <span class="cov8" title="1">if spec.Status == model.OrderStatusCompleted </span><span class="cov8" title="1">{
                                completedAt = endPtr
                        }</span>
                        <span class="cov8" title="1">order, err := seedOrder(tx, seedOrderParams{
                                Title:          spec.Title,
                                Description:    spec.Description,
                                UserID:         user.ID,
                                PlayerID:       playerID,
                                GameID:         game.ID,
                                Status:         spec.Status,
                                PriceCents:     spec.PriceCents,
                                Currency:       spec.Currency,
                                ScheduledStart: startPtr,
                                ScheduledEnd:   endPtr,
                                CancelReason:   spec.CancelReason,
                                StartedAt:      startedAt,
                                CompletedAt:    completedAt,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">orders[spec.Key] = order</span>
                }

                <span class="cov8" title="1">paymentSpecs := []seedPaymentSpec{
                        {
                                OrderKey:        "orderCompleted1",
                                UserKey:         "customerA",
                                Method:          model.PaymentMethodWeChat,
                                AmountCents:     19900,
                                Currency:        model.CurrencyCNY,
                                Status:          model.PaymentStatusPaid,
                                ProviderTradeNo: "WX1234567890",
                                ProviderRaw:     `{"result":"success"}`,
                                PaidAtOffset:    ptrDuration(-2 * hour),
                        },
                        {
                                OrderKey:        "orderInProgress1",
                                UserKey:         "customerB",
                                Method:          model.PaymentMethodAlipay,
                                AmountCents:     29900,
                                Currency:        model.CurrencyCNY,
                                Status:          model.PaymentStatusPending,
                                ProviderTradeNo: "ALI987654321",
                                ProviderRaw:     `{"result":"processing"}`,
                        },
                        {
                                OrderKey:        "orderCanceled1",
                                UserKey:         "customerB",
                                Method:          model.PaymentMethodWeChat,
                                AmountCents:     12900,
                                Currency:        model.CurrencyCNY,
                                Status:          model.PaymentStatusRefunded,
                                ProviderTradeNo: "WXREFUND001",
                                ProviderRaw:     `{"result":"refunded"}`,
                                PaidAtOffset:    ptrDuration(-5 * hour),
                                RefundedOffset:  ptrDuration(-4 * hour),
                        },
                        {
                                OrderKey:        "orderConfirmed1",
                                UserKey:         "customerD",
                                Method:          model.PaymentMethodWeChat,
                                AmountCents:     18900,
                                Currency:        model.CurrencyCNY,
                                Status:          model.PaymentStatusPaid,
                                ProviderTradeNo: "WXTRAIN123",
                                ProviderRaw:     `{"result":"success"}`,
                                PaidAtOffset:    ptrDuration(10 * time.Minute),
                        },
                        {
                                OrderKey:        "orderCompleted2",
                                UserKey:         "customerF",
                                Method:          model.PaymentMethodAlipay,
                                AmountCents:     24900,
                                Currency:        model.CurrencyCNY,
                                Status:          model.PaymentStatusPaid,
                                ProviderTradeNo: "ALIWOWEXP456",
                                ProviderRaw:     `{"result":"success"}`,
                                PaidAtOffset:    ptrDuration(-7 * hour),
                        },
                        {
                                OrderKey:        "orderInProgress2",
                                UserKey:         "customerG",
                                Method:          model.PaymentMethodWeChat,
                                AmountCents:     7900,
                                Currency:        model.CurrencyCNY,
                                Status:          model.PaymentStatusPaid,
                                ProviderTradeNo: "WXSPORTS789",
                                ProviderRaw:     `{"result":"success"}`,
                                PaidAtOffset:    ptrDuration(-45 * time.Minute),
                        },
                        {
                                OrderKey:        "orderRefunded1",
                                UserKey:         "customerA",
                                Method:          model.PaymentMethodAlipay,
                                AmountCents:     16900,
                                Currency:        model.CurrencyCNY,
                                Status:          model.PaymentStatusRefunded,
                                ProviderTradeNo: "ALIREPAIR001",
                                ProviderRaw:     `{"result":"refunded"}`,
                                PaidAtOffset:    ptrDuration(-2 * hour),
                                RefundedOffset:  ptrDuration(-90 * time.Minute),
                        },
                        {
                                OrderKey:        "orderConfirmed2",
                                UserKey:         "customerB",
                                Method:          model.PaymentMethodWeChat,
                                AmountCents:     21900,
                                Currency:        model.CurrencyCNY,
                                Status:          model.PaymentStatusPaid,
                                ProviderTradeNo: "WXDOTATEACH012",
                                ProviderRaw:     `{"result":"success"}`,
                                PaidAtOffset:    ptrDuration(30 * time.Minute),
                        },
                }

                for _, spec := range paymentSpecs </span><span class="cov8" title="1">{
                        order, ok := orders[spec.OrderKey]
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("seed payment missing order %s", spec.OrderKey)
                        }</span>
                        <span class="cov8" title="1">user, ok := users[spec.UserKey]
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("seed payment missing user %s", spec.UserKey)
                        }</span>
                        <span class="cov8" title="1">paidAt := ptrTimeWithOffset(now, spec.PaidAtOffset)
                        refundedAt := ptrTimeWithOffset(now, spec.RefundedOffset)
                        if err := seedPayment(tx, seedPaymentParams{
                                OrderID:         order.ID,
                                UserID:          user.ID,
                                Method:          spec.Method,
                                AmountCents:     spec.AmountCents,
                                Currency:        spec.Currency,
                                Status:          spec.Status,
                                ProviderTradeNo: spec.ProviderTradeNo,
                                ProviderRaw:     json.RawMessage(spec.ProviderRaw),
                                PaidAt:          paidAt,
                                RefundedAt:      refundedAt,
                        }); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">reviewSpecs := []seedReviewSpec{
                        {
                                OrderKey:  "orderCompleted1",
                                UserKey:   "customerA",
                                PlayerKey: "playerA",
                                Score:     model.MustRating(5),
                                Content:   "很满意的陪玩体验，带我连胜！峡谷守护者技术确实强，打野节奏把控很好。",
                        },
                        {
                                OrderKey:  "orderInProgress1",
                                UserKey:   "customerB",
                                PlayerKey: "playerA",
                                Score:     model.MustRating(4),
                                Content:   "战术指导很专业，期待后续完成。DOTA2的复杂度很高，有专业指导确实不一样。",
                        },
                        {
                                OrderKey:  "orderCompleted2",
                                UserKey:   "customerF",
                                PlayerKey: "playerD",
                                Score:     model.MustRating(5),
                                Content:   "异世界旅者对MMORPG的理解非常深入，带我了解了魔兽世界的核心玩法，收益很大！",
                        },
                        {
                                OrderKey:  "orderInProgress2",
                                UserKey:   "customerG",
                                PlayerKey: "playerE",
                                Score:     model.MustRating(4),
                                Content:   "运动健将的足球水平很高，学到了很多实用的技巧。FIFA游戏体验很好。",
                        },
                        {
                                OrderKey:  "orderCompleted1",
                                UserKey:   "customerD",
                                PlayerKey: "playerC",
                                Score:     model.MustRating(5),
                                Content:   "枪神降临不愧是职业选手，枪法精准，教学耐心细致。CS:GO的水平确实提升了很多！",
                        },
                        {
                                OrderKey:  "orderConfirmed2",
                                UserKey:   "customerB",
                                PlayerKey: "playerG",
                                Score:     model.MustRating(4),
                                Content:   "DOTA宗师的教学很系统，从基础到进阶都有涉及，受益匪浅。",
                        },
                        {
                                OrderKey:  "orderRefunded1",
                                UserKey:   "customerA",
                                PlayerKey: "playerB",
                                Score:     model.MustRating(3),
                                Content:   "虽然因为服务器维护退款了，但之前的服务还不错。期待下次能正常完成。",
                        },
                }

                for _, spec := range reviewSpecs </span><span class="cov8" title="1">{
                        order, ok := orders[spec.OrderKey]
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("seed review missing order %s", spec.OrderKey)
                        }</span>
                        <span class="cov8" title="1">user, ok := users[spec.UserKey]
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("seed review missing user %s", spec.UserKey)
                        }</span>
                        <span class="cov8" title="1">player, ok := players[spec.PlayerKey]
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("seed review missing player %s", spec.PlayerKey)
                        }</span>
                        <span class="cov8" title="1">if err := seedReview(tx, seedReviewParams{
                                OrderID:  order.ID,
                                UserID:   user.ID,
                                PlayerID: player.ID,
                                Score:    spec.Score,
                                Content:  spec.Content,
                        }); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">log.Println("seed data ensured for demo environment")
                return nil</span>
        })
}

type seedPlayerParams struct {
        UserID             uint64
        Nickname           string
        Bio                string
        RatingAverage      float32
        RatingCount        uint32
        HourlyRateCents    int64
        MainGameID         uint64
        VerificationStatus model.VerificationStatus
}

type seedOrderParams struct {
        Title             string
        Description       string
        UserID            uint64
        PlayerID          *uint64
        GameID            uint64
        Status            model.OrderStatus
        PriceCents        int64
        Currency          model.Currency
        ScheduledStart    *time.Time
        ScheduledEnd      *time.Time
        CancelReason      string
        StartedAt         *time.Time
        CompletedAt       *time.Time
        RefundAmountCents *int64
        RefundReason      string
        RefundedAt        *time.Time
}

type seedPaymentParams struct {
        OrderID         uint64
        UserID          uint64
        Method          model.PaymentMethod
        AmountCents     int64
        Currency        model.Currency
        Status          model.PaymentStatus
        ProviderTradeNo string
        ProviderRaw     json.RawMessage
        PaidAt          *time.Time
        RefundedAt      *time.Time
}

type seedReviewParams struct {
        OrderID  uint64
        UserID   uint64
        PlayerID uint64
        Score    model.Rating
        Content  string
}

func seedGames(tx *gorm.DB) (map[string]*model.Game, error) <span class="cov8" title="1">{
        seeds := []model.Game{
                {Key: "lol", Name: "英雄联盟", Category: "moba", Description: "召唤师峡谷 5v5 对战"},
                {Key: "dota2", Name: "DOTA 2", Category: "moba", Description: "经典即时战略竞技"},
                {Key: "valorant", Name: "无畏契约", Category: "fps", Description: "英雄战术射击"},
                {Key: "csgo", Name: "反恐精英：全球攻势", Category: "fps", Description: "经典第一人称射击"},
                {Key: "apex", Name: "Apex英雄", Category: "fps", Description: "大逃杀类射击游戏"},
                {Key: "pubg", Name: "绝地求生", Category: "fps", Description: "百人竞技生存游戏"},
                {Key: "overwatch", Name: "守望先锋", Category: "fps", Description: "团队英雄射击游戏"},
                {Key: "fifa", Name: "FIFA足球", Category: "sports", Description: "足球模拟游戏"},
                {Key: "nba2k", Name: "NBA2K篮球", Category: "sports", Description: "篮球模拟游戏"},
                {Key: "wzry", Name: "王者荣耀", Category: "moba", Description: "移动端MOBA游戏"},
                {Key: "genshin", Name: "原神", Category: "rpg", Description: "开放世界冒险游戏"},
                {Key: "wow", Name: "魔兽世界", Category: "rpg", Description: "大型多人在线角色扮演游戏"},
                {Key: "minecraft", Name: "我的世界", Category: "sandbox", Description: "沙盒建造游戏"},
                {Key: "amongus", Name: "Among Us", Category: "social", Description: "社交推理游戏"},
                {Key: "fallguys", Name: "糖豆人", Category: "party", Description: "多人派对游戏"},
        }
        result := make(map[string]*model.Game, len(seeds))
        for i := range seeds </span><span class="cov8" title="1">{
                game := &amp;seeds[i]
                var existing model.Game
                if err := tx.Where("key = ?", game.Key).First(&amp;existing).Error; err == nil </span><span class="cov8" title="1">{
                        ex := existing
                        result[game.Key] = &amp;ex
                        continue</span>
                } else<span class="cov8" title="1"> if !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := tx.Create(game).Error; err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">result[game.Key] = game</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

func seedUser(tx *gorm.DB, input seedUserInput) (*model.User, error) <span class="cov8" title="1">{
        if input.Email == "" &amp;&amp; input.Phone == "" </span><span class="cov0" title="0">{
                return nil, errors.New("seed user requires email or phone")
        }</span>
        <span class="cov8" title="1">lookup := tx.Model(&amp;model.User{})
        if input.Email != "" </span><span class="cov8" title="1">{
                lookup = lookup.Where("email = ?", input.Email)
        }</span> else<span class="cov0" title="0"> {
                lookup = lookup.Where("phone = ?", input.Phone)
        }</span>
        <span class="cov8" title="1">var existing model.User
        if err := lookup.First(&amp;existing).Error; err == nil </span><span class="cov8" title="1">{
                return &amp;existing, nil
        }</span> else<span class="cov8" title="1"> if !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">hashed, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">user := &amp;model.User{
                Email:        input.Email,
                Phone:        input.Phone,
                Name:         input.Name,
                Role:         input.Role,
                Status:       model.UserStatusActive,
                PasswordHash: string(hashed),
        }
        if err := tx.Create(user).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}

func seedPlayer(tx *gorm.DB, input seedPlayerParams) (*model.Player, error) <span class="cov8" title="1">{
        var existing model.Player
        if err := tx.Where("user_id = ?", input.UserID).First(&amp;existing).Error; err == nil </span><span class="cov8" title="1">{
                return &amp;existing, nil
        }</span> else<span class="cov8" title="1"> if !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">player := &amp;model.Player{
                UserID:             input.UserID,
                Nickname:           input.Nickname,
                Bio:                input.Bio,
                RatingAverage:      input.RatingAverage,
                RatingCount:        input.RatingCount,
                HourlyRateCents:    input.HourlyRateCents,
                MainGameID:         input.MainGameID,
                VerificationStatus: input.VerificationStatus,
        }
        if err := tx.Create(player).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return player, nil</span>
}

func seedOrder(tx *gorm.DB, input seedOrderParams) (*model.Order, error) <span class="cov8" title="1">{
        var existing model.Order
        if err := tx.Where("title = ? AND user_id = ?", input.Title, input.UserID).First(&amp;existing).Error; err == nil </span><span class="cov8" title="1">{
                return &amp;existing, nil
        }</span> else<span class="cov8" title="1"> if !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">order := &amp;model.Order{
                OrderNo:         model.GenerateEscortOrderNo(),
                UserID:          input.UserID,
                ItemID:          1, // TODO: 需要从service_items获取
                GameID:          &amp;input.GameID,
                Quantity:        1,
                UnitPriceCents:  input.PriceCents,
                TotalPriceCents: input.PriceCents,
                Currency:        input.Currency,
                Status:          input.Status,
                Title:           input.Title,
                Description:     input.Description,
                ScheduledStart:  input.ScheduledStart,
                ScheduledEnd:    input.ScheduledEnd,
                CancelReason:    strings.TrimSpace(input.CancelReason),
        }
        if input.PlayerID != nil </span><span class="cov8" title="1">{
                order.PlayerID = input.PlayerID
        }</span>
        <span class="cov8" title="1">if input.StartedAt != nil </span><span class="cov8" title="1">{
                order.StartedAt = input.StartedAt
        }</span>
        <span class="cov8" title="1">if input.CompletedAt != nil </span><span class="cov8" title="1">{
                order.CompletedAt = input.CompletedAt
        }</span>
        <span class="cov8" title="1">if input.RefundAmountCents != nil </span><span class="cov0" title="0">{
                order.RefundAmountCents = *input.RefundAmountCents
        }</span>
        <span class="cov8" title="1">if input.RefundReason != "" </span><span class="cov0" title="0">{
                order.RefundReason = strings.TrimSpace(input.RefundReason)
        }</span>
        <span class="cov8" title="1">if input.RefundedAt != nil </span><span class="cov0" title="0">{
                order.RefundedAt = input.RefundedAt
        }</span>
        <span class="cov8" title="1">if err := tx.Create(order).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return order, nil</span>
}

func seedPayment(tx *gorm.DB, input seedPaymentParams) error <span class="cov8" title="1">{
        var existing model.Payment
        if err := tx.Where("order_id = ?", input.OrderID).First(&amp;existing).Error; err == nil </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> if !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">payment := &amp;model.Payment{
                OrderID:         input.OrderID,
                UserID:          input.UserID,
                Method:          input.Method,
                AmountCents:     input.AmountCents,
                Currency:        input.Currency,
                Status:          input.Status,
                ProviderTradeNo: input.ProviderTradeNo,
                ProviderRaw:     input.ProviderRaw,
                PaidAt:          input.PaidAt,
                RefundedAt:      input.RefundedAt,
        }
        if err := tx.Create(payment).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func seedReview(tx *gorm.DB, input seedReviewParams) error <span class="cov8" title="1">{
        var existing model.Review
        if err := tx.Where("order_id = ?", input.OrderID).First(&amp;existing).Error; err == nil </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> if !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">review := &amp;model.Review{
                OrderID:  input.OrderID,
                UserID:   input.UserID,
                PlayerID: input.PlayerID,
                Score:    input.Score,
                Content:  input.Content,
        }
        if err := tx.Create(review).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func ptrTime(t time.Time) *time.Time <span class="cov8" title="1">{
        return &amp;t
}</span>

func ptrDuration(d time.Duration) *time.Duration <span class="cov8" title="1">{
        return &amp;d
}</span>

func ptrTimeWithOffset(base time.Time, offset *time.Duration) *time.Time <span class="cov8" title="1">{
        if offset == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return ptrTime(base.Add(*offset))</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package db

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "gorm.io/gorm"
        "gorm.io/gorm/logger"

        "gamelink/internal/config"
        "gamelink/internal/metrics"

        // 使用纯 Go 实现的 SQLite GORM 驱动（无需 CGO）
        // github.com/glebarez/sqlite 基于 modernc.org/sqlite
        sqlite "github.com/glebarez/sqlite"
)

func openSQLite(cfg config.AppConfig) (*gorm.DB, error) <span class="cov8" title="1">{
        dsn := cfg.Database.DSN
        if err := ensureSQLiteDir(dsn); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">gormDB, err := gorm.Open(sqlite.Open(dsn), &amp;gorm.Config{
                Logger: logger.Default.LogMode(logger.Warn),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("打开 sqlite 失败: %w", err)
        }</span>

        <span class="cov8" title="1">if err := configureConnection(gormDB, 1); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := gormDB.Exec("PRAGMA foreign_keys = ON").Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("启用 sqlite 外键失败: %w", err)
        }</span>

        <span class="cov8" title="1">if err := autoMigrate(gormDB); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := runDataFixups(gormDB); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := ensureIndexes(gormDB); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if cfg.Seed.Enabled </span><span class="cov0" title="0">{
                if err := applySeeds(gormDB); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">_ = metrics.InstrumentGorm(gormDB)

        return gormDB, nil</span>
}

func configureConnection(db *gorm.DB, maxOpen int) error <span class="cov8" title="1">{
        sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">sqlDB.SetMaxOpenConns(maxOpen)
        sqlDB.SetMaxIdleConns(maxOpen)
        sqlDB.SetConnMaxLifetime(30 * time.Minute)
        return nil</span>
}

func ensureSQLiteDir(dsn string) error <span class="cov8" title="1">{
        if !strings.HasPrefix(dsn, "file:") </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">path := strings.TrimPrefix(dsn, "file:")
        if idx := strings.Index(path, "?"); idx &gt;= 0 </span><span class="cov8" title="1">{
                path = path[:idx]
        }</span>

        <span class="cov8" title="1">dir := filepath.Dir(path)
        if dir == "." </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">if err := os.MkdirAll(dir, 0o755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("创建 sqlite 目录失败: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package admin

import (
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"

        "gamelink/internal/model"
        "gamelink/internal/service/commission"
)

// RegisterCommissionRoutes Register admin commission management routes
func RegisterCommissionRoutes(router gin.IRouter, svc *commission.CommissionService, scheduler interface{ TriggerSettlement(string) error }) <span class="cov0" title="0">{
        group := router.Group("/admin/commission")
        </span><span class="cov0" title="0">{
                // 抽成规则管理
                group.POST("/rules", func(c *gin.Context) </span><span class="cov0" title="0">{ createCommissionRuleHandler(c, svc) }</span>)
                <span class="cov0" title="0">group.PUT("/rules/:id", func(c *gin.Context) </span><span class="cov0" title="0">{ updateCommissionRuleHandler(c, svc) }</span>)

                // 月度结算
                <span class="cov0" title="0">group.POST("/settlements/trigger", func(c *gin.Context) </span><span class="cov0" title="0">{ triggerSettlementHandler(c, scheduler) }</span>)
                <span class="cov0" title="0">group.GET("/stats", func(c *gin.Context) </span><span class="cov0" title="0">{ getPlatformStatsHandler(c, svc) }</span>)
        }
}

// createCommissionRuleHandler 创建抽成规则
// @Summary      创建抽成规则
// @Description  管理员创建抽成规�?
// @Tags         Admin - Commission
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string                                    true  "Bearer {token}"
// @Param        request        body      commission.CreateCommissionRuleRequest  true  "抽成规则信息"
// @Success      200            {object}  model.APIResponse[model.CommissionRule]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/commission/rules [post]
func createCommissionRuleHandler(c *gin.Context, svc *commission.CommissionService) <span class="cov0" title="0">{
        var req commission.CreateCommissionRuleRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">rule, err := svc.CreateCommissionRule(c.Request.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[model.CommissionRule]{
                Success: true,
                Code:    http.StatusOK,
                Message: "Commission rule created successfully",
                Data:    *rule,
        })</span>
}

// updateCommissionRuleHandler 更新抽成规则
// @Summary      更新抽成规则
// @Description  管理员更新抽成规�?
// @Tags         Admin - Commission
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string                                    true  "Bearer {token}"
// @Param        id             path      int                                       true  "规则ID"
// @Param        request        body      commission.UpdateCommissionRuleRequest  true  "更新信息"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/commission/rules/{id} [put]
func updateCommissionRuleHandler(c *gin.Context, svc *commission.CommissionService) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "Invalid rule ID")
                return
        }</span>

        <span class="cov0" title="0">var req commission.UpdateCommissionRuleRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">err = svc.UpdateCommissionRule(c.Request.Context(), id, req)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "Commission rule updated successfully",
        })</span>
}

// triggerSettlementHandler 手动触发月度结算
// @Summary      手动触发月度结算
// @Description  管理员手动触发指定月份的结算
// @Tags         Admin - Commission
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Param        month          query     string  true  "月份 (YYYY-MM)"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/commission/settlements/trigger [post]
func triggerSettlementHandler(c *gin.Context, scheduler interface{ TriggerSettlement(string) error }) <span class="cov0" title="0">{
        month := c.Query("month")
        if month == "" </span><span class="cov0" title="0">{
                // 默认结算上个�?
                lastMonth := time.Now().AddDate(0, -1, 0)
                month = lastMonth.Format("2006-01")
        }</span>

        <span class="cov0" title="0">err := scheduler.TriggerSettlement(month)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "Settlement triggered successfully for month: " + month,
        })</span>
}

// getPlatformStatsHandler 获取平台统计
// @Summary      获取平台统计
// @Description  管理员查看平台月度统计数�?
// @Tags         Admin - Commission
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Param        month          query     string  true  "月份 (YYYY-MM)"
// @Success      200            {object}  model.APIResponse[commission.PlatformStatsResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/commission/stats [get]
func getPlatformStatsHandler(c *gin.Context, svc *commission.CommissionService) <span class="cov0" title="0">{
        month := c.DefaultQuery("month", time.Now().Format("2006-01"))

        stats, err := svc.GetPlatformStats(c.Request.Context(), month)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[commission.PlatformStatsResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *stats,
        })</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package admin

import (
        "context"
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"

        "gamelink/internal/model"
        "gamelink/internal/repository"
        commissionrepo "gamelink/internal/repository/commission"
        serviceitemrepo "gamelink/internal/repository/serviceitem"
        withdrawrepo "gamelink/internal/repository/withdraw"
)

// DashboardService Dashboard统计服务接口
type DashboardService interface {
        GetOverviewStats(ctx context.Context) (*DashboardOverviewStats, error)
        GetRecentOrders(ctx context.Context, limit int) ([]model.Order, error)
        GetRecentWithdraws(ctx context.Context, limit int) ([]model.Withdraw, error)
        GetMonthlyRevenue(ctx context.Context, months int) ([]MonthlyRevenueData, error)
}

// DashboardOverviewStats 总览统计
type DashboardOverviewStats struct {
        TotalUsers       int64 `json:"totalUsers"`
        TotalPlayers     int64 `json:"totalPlayers"`
        TotalOrders      int64 `json:"totalOrders"`
        TodayOrders      int64 `json:"todayOrders"`
        TodayRevenue     int64 `json:"todayRevenue"`
        MonthRevenue     int64 `json:"monthRevenue"`
        PendingWithdraws int64 `json:"pendingWithdraws"`
        ActiveServices   int64 `json:"activeServices"`
}

// MonthlyRevenueData 月度收入数据
type MonthlyRevenueData struct {
        Month           string `json:"month"`
        TotalRevenue    int64  `json:"totalRevenue"`
        TotalCommission int64  `json:"totalCommission"`
        TotalOrders     int64  `json:"totalOrders"`
}

// RegisterDashboardRoutes 注册管理端Dashboard路由
func RegisterDashboardRoutes(
        router gin.IRouter,
        userRepo repository.UserRepository,
        playerRepo repository.PlayerRepository,
        orderRepo repository.OrderRepository,
        withdrawRepo withdrawrepo.WithdrawRepository,
        serviceItemRepo serviceitemrepo.ServiceItemRepository,
        commissionRepo commissionrepo.CommissionRepository,
) <span class="cov0" title="0">{
        group := router.Group("/admin/dashboard")
        </span><span class="cov0" title="0">{
                group.GET("/overview", func(c *gin.Context) </span><span class="cov0" title="0">{
                        getDashboardOverviewHandler(c, userRepo, playerRepo, orderRepo, withdrawRepo, serviceItemRepo)
                }</span>)
                <span class="cov0" title="0">group.GET("/recent-orders", func(c *gin.Context) </span><span class="cov0" title="0">{
                        getRecentOrdersHandler(c, orderRepo)
                }</span>)
                <span class="cov0" title="0">group.GET("/recent-withdraws", func(c *gin.Context) </span><span class="cov0" title="0">{
                        getRecentWithdrawsHandler(c, withdrawRepo)
                }</span>)
                <span class="cov0" title="0">group.GET("/monthly-revenue", func(c *gin.Context) </span><span class="cov0" title="0">{
                        getMonthlyRevenueHandler(c, commissionRepo)
                }</span>)
        }
}

// getDashboardOverviewHandler 获取Dashboard总览
// @Summary      获取Dashboard总览
// @Description  管理员Dashboard总览数据
// @Tags         Admin - Dashboard
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Success      200            {object}  model.APIResponse[DashboardOverviewStats]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/dashboard/overview [get]
func getDashboardOverviewHandler(
        c *gin.Context,
        userRepo repository.UserRepository,
        playerRepo repository.PlayerRepository,
        orderRepo repository.OrderRepository,
        withdrawRepo withdrawrepo.WithdrawRepository,
        serviceItemRepo serviceitemrepo.ServiceItemRepository,
) <span class="cov8" title="1">{
        ctx := c.Request.Context()
        stats := &amp;DashboardOverviewStats{}

        // 总用户数
        users, _ := userRepo.List(ctx)
        stats.TotalUsers = int64(len(users))

        // 总陪玩师数
        _, totalPlayers, _ := playerRepo.ListPaged(ctx, 1, 1)
        stats.TotalPlayers = totalPlayers

        // 总订单数
        orders, total, _ := orderRepo.List(ctx, repository.OrderListOptions{Page: 1, PageSize: 1})
        _ = orders
        stats.TotalOrders = total

        // 今日订单数
        todayStart := time.Now().Truncate(24 * time.Hour)
        todayOrders, todayTotal, _ := orderRepo.List(ctx, repository.OrderListOptions{
                DateFrom: &amp;todayStart,
                Page:     1,
                PageSize: 10000,
        })
        stats.TodayOrders = todayTotal

        // 今日收入
        var todayRevenue int64
        for _, order := range todayOrders </span><span class="cov8" title="1">{
                if order.Status == model.OrderStatusCompleted </span><span class="cov8" title="1">{
                        todayRevenue += order.TotalPriceCents
                }</span>
        }
        <span class="cov8" title="1">stats.TodayRevenue = todayRevenue

        // 本月收入
        monthStart := time.Date(time.Now().Year(), time.Now().Month(), 1, 0, 0, 0, 0, time.Now().Location())
        monthOrders, _, _ := orderRepo.List(ctx, repository.OrderListOptions{
                DateFrom: &amp;monthStart,
                Statuses: []model.OrderStatus{model.OrderStatusCompleted},
                Page:     1,
                PageSize: 10000,
        })
        var monthRevenue int64
        for _, order := range monthOrders </span><span class="cov8" title="1">{
                monthRevenue += order.TotalPriceCents
        }</span>
        <span class="cov8" title="1">stats.MonthRevenue = monthRevenue

        // 待审批提现
        pendingStatus := model.WithdrawStatusPending
        _, pendingTotal, _ := withdrawRepo.List(ctx, withdrawrepo.WithdrawListOptions{
                Status:   &amp;pendingStatus,
                Page:     1,
                PageSize: 1,
        })
        stats.PendingWithdraws = pendingTotal

        // 活跃服务数
        isActive := true
        _, activeTotal, _ := serviceItemRepo.List(ctx, serviceitemrepo.ServiceItemListOptions{
                IsActive: &amp;isActive,
                Page:     1,
                PageSize: 1,
        })
        stats.ActiveServices = activeTotal

        writeJSON(c, http.StatusOK, model.APIResponse[DashboardOverviewStats]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *stats,
        })</span>
}

// getRecentOrdersHandler 获取最近订�?// @Summary      获取最近订�?// @Description  管理员查看最近订�?// @Tags         Admin - Dashboard
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        limit          query     int     false  "数量限制"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/dashboard/recent-orders [get]
func getRecentOrdersHandler(c *gin.Context, orderRepo repository.OrderRepository) <span class="cov8" title="1">{
        limit := 10
        if limitStr := c.Query("limit"); limitStr != "" </span><span class="cov8" title="1">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 &amp;&amp; l &lt;= 100 </span><span class="cov8" title="1">{
                        limit = l
                }</span>
        }

        <span class="cov8" title="1">orders, _, err := orderRepo.List(c.Request.Context(), repository.OrderListOptions{
                Page:     1,
                PageSize: limit,
        })
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data: map[string]interface{}{
                        "orders": orders,
                },
        })</span>
}

// getRecentWithdrawsHandler 获取最近提�?// @Summary      获取最近提�?// @Description  管理员查看最近提现申�?// @Tags         Admin - Dashboard
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        limit          query     int     false  "数量限制"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/dashboard/recent-withdraws [get]
func getRecentWithdrawsHandler(c *gin.Context, withdrawRepo withdrawrepo.WithdrawRepository) <span class="cov8" title="1">{
        limit := 10
        if limitStr := c.Query("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 &amp;&amp; l &lt;= 100 </span><span class="cov0" title="0">{
                        limit = l
                }</span>
        }

        <span class="cov8" title="1">withdraws, _, err := withdrawRepo.List(c.Request.Context(), withdrawrepo.WithdrawListOptions{
                Page:     1,
                PageSize: limit,
        })
        if err != nil </span><span class="cov8" title="1">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data: map[string]interface{}{
                        "withdraws": withdraws,
                },
        })</span>
}

// getMonthlyRevenueHandler 获取月度收入趋势
// @Summary      获取月度收入趋势
// @Description  管理员查看最近几个月的收入趋�?// @Tags         Admin - Dashboard
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        months         query     int     false  "月数（默�?2�?
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/dashboard/monthly-revenue [get]
func getMonthlyRevenueHandler(c *gin.Context, commissionRepo commissionrepo.CommissionRepository) <span class="cov8" title="1">{
        months := 12
        if monthsStr := c.Query("months"); monthsStr != "" </span><span class="cov8" title="1">{
                if m, err := strconv.Atoi(monthsStr); err == nil &amp;&amp; m &gt; 0 &amp;&amp; m &lt;= 24 </span><span class="cov8" title="1">{
                        months = m
                }</span>
        }

        <span class="cov8" title="1">ctx := c.Request.Context()
        revenueData := make([]MonthlyRevenueData, 0, months)

        // 计算每个月的数据
        now := time.Now()
        for i := months - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                month := now.AddDate(0, -i, 0).Format("2006-01")

                // 获取月度统计 - 直接使用具体类型
                stats, err := commissionRepo.GetMonthlyStats(ctx, month)
                if err == nil &amp;&amp; stats != nil </span><span class="cov8" title="1">{
                        revenueData = append(revenueData, MonthlyRevenueData{
                                Month:           month,
                                TotalRevenue:    stats.TotalIncome,
                                TotalCommission: stats.TotalCommission,
                                TotalOrders:     stats.TotalOrders,
                        })
                }</span> else<span class="cov8" title="1"> {
                        // 如果没有数据，填0
                        revenueData = append(revenueData, MonthlyRevenueData{
                                Month:           month,
                                TotalRevenue:    0,
                                TotalCommission: 0,
                                TotalOrders:     0,
                        })
                }</span>
        }

        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data: map[string]interface{}{
                        "revenue": revenueData,
                },
        })</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package admin

import (
        "errors"
        "net/http"
        "strings"
        "time"

        "github.com/gin-gonic/gin"

        apierr "gamelink/internal/handler"
        "gamelink/internal/model"
        "gamelink/internal/repository"
        adminservice "gamelink/internal/service/admin"
)

// GameHandler 处理后台游戏管理接口�?
type GameHandler struct {
        svc *adminservice.AdminService
}

// NewGameHandler 创建Handler
func NewGameHandler(svc *adminservice.AdminService) *GameHandler <span class="cov8" title="1">{
        return &amp;GameHandler{svc: svc}
}</span>

// ListGames
// @Summary      列出游戏
// @Tags         Admin/Games
// @Security     BearerAuth
// @Param        page       query  int  false  "页码"
// @Param        pageSize   query     int       false  "每页数量"
// @Produce      json
// @Success      200  {object}  map[string]any
// @Router       /admin/games [get]
//
// ListGames 返回全部游戏�?
func (h *GameHandler) ListGames(c *gin.Context) <span class="cov8" title="1">{
        page, pageSize, ok := parsePagination(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">games, pagination, err := h.svc.ListGamesPaged(c.Request.Context(), page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov8" title="1">games = ensureSlice(games)
        writeJSON(c, http.StatusOK, model.APIResponse[[]model.Game]{
                Success:    true,
                Code:       http.StatusOK,
                Message:    "OK",
                Data:       games,
                Pagination: pagination,
        })</span>
}

// GetGame
// @Summary      获取游戏
// @Tags         Admin/Games
// @Security     BearerAuth
// @Param        id   path  int  true  "游戏ID"
// @Produce      json
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/games/{id} [get]
//
// GetGame 获取单个游戏�?
func (h *GameHandler) GetGame(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov8" title="1">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">game, err := h.svc.GetGame(c.Request.Context(), id)
        if errors.Is(err, repository.ErrNotFound) </span><span class="cov8" title="1">{
                writeJSONError(c, http.StatusNotFound, apierr.ErrGameNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[*model.Game]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    game,
        })</span>
}

// CreateGame
// @Summary      创建游戏
// @Tags         Admin/Games
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        request  body  GamePayload  true  "游戏信息"
// @Success      201  {object}  map[string]any
// @Failure      400  {object}  map[string]any
// @Router       /admin/games [post]
//
// CreateGame 创建新游戏�?
func (h *GameHandler) CreateGame(c *gin.Context) <span class="cov8" title="1">{
        var payload GamePayload
        if err := c.ShouldBindJSON(&amp;payload); err != nil </span><span class="cov8" title="1">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                return
        }</span>

        <span class="cov8" title="1">game, err := h.svc.CreateGame(c.Request.Context(), adminservice.CreateGameInput{
                Key:         payload.Key,
                Name:        payload.Name,
                Category:    payload.Category,
                IconURL:     payload.IconURL,
                Description: payload.Description,
        })
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "Validation failed")
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusCreated, model.APIResponse[*model.Game]{
                Success: true,
                Code:    http.StatusCreated,
                Message: "created",
                Data:    game,
        })</span>
}

// UpdateGame
// @Summary      更新游戏
// @Tags         Admin/Games
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        id       path  int         true  "游戏ID"
// @Param        request  body  GamePayload true  "游戏信息"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/games/{id} [put]
//
// UpdateGame 更新游戏信息�?
func (h *GameHandler) UpdateGame(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>

        <span class="cov8" title="1">var payload GamePayload
        if bindErr := c.ShouldBindJSON(&amp;payload); bindErr != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                return
        }</span>

        <span class="cov8" title="1">game, err := h.svc.UpdateGame(c.Request.Context(), id, adminservice.UpdateGameInput{
                Key:         payload.Key,
                Name:        payload.Name,
                Category:    payload.Category,
                IconURL:     payload.IconURL,
                Description: payload.Description,
        })
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "Validation failed")
                return
        }</span>
        <span class="cov8" title="1">if errors.Is(err, repository.ErrNotFound) </span><span class="cov8" title="1">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[*model.Game]{
                Success: true,
                Code:    http.StatusOK,
                Message: "updated",
                Data:    game,
        })</span>
}

// DeleteGame
// @Summary      删除游戏
// @Tags         Admin/Games
// @Security     BearerAuth
// @Param        id   path  int  true  "游戏ID"
// @Produce      json
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/games/{id} [delete]
//
// DeleteGame 删除游戏�?
func (h *GameHandler) DeleteGame(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>

        <span class="cov8" title="1">err = h.svc.DeleteGame(c.Request.Context(), id)
        if errors.Is(err, repository.ErrNotFound) </span><span class="cov8" title="1">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "deleted",
        })</span>
}

// ListGameLogs
// @Summary      获取游戏操作日志
// @Tags         Admin/Games
// @Security     BearerAuth
// @Produce      json
// @Param        id           path   int  true  "游戏ID"
// @Param        page         query  int  false "页码"
// @Param        pageSize   query     int       false  "每页数量"
// @Param        action       query  string false "动作过滤" Enums(create,update,delete)
// @Param        actor_user_id query int   false "操作者用户ID"
// @Param        dateFrom   query     string    false  "开始时�?
// @Param        dateTo     query     string    false  "结束时间"
// @Param        export       query  string false "导出格式" Enums(csv)
// @Param        fields       query  string false "导出列（逗号分隔�?
// @Param        header_lang  query  string false "列头语言" Enums(en,zh)
// @Success      200  {object}  map[string]any
// @Router       /admin/games/{id}/logs [get]
func (h *GameHandler) ListGameLogs(c *gin.Context) <span class="cov0" title="0">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov0" title="0">page, pageSize, ok := parsePagination(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">var actorID *uint64
        if v, err := queryUint64Ptr(c, "actor_user_id"); err == nil </span><span class="cov0" title="0">{
                actorID = v
        }</span>
        <span class="cov0" title="0">var dateFrom, dateTo *time.Time
        if v, err := queryTimePtr(c, "date_from"); err == nil </span><span class="cov0" title="0">{
                dateFrom = v
        }</span> else<span class="cov0" title="0"> {
                writeJSONError(c, 400, apierr.ErrInvalidDateFrom)
                return
        }</span>
        <span class="cov0" title="0">if v, err := queryTimePtr(c, "date_to"); err == nil </span><span class="cov0" title="0">{
                dateTo = v
        }</span> else<span class="cov0" title="0"> {
                writeJSONError(c, 400, apierr.ErrInvalidDateTo)
                return
        }</span>
        <span class="cov0" title="0">opts := repository.OperationLogListOptions{Page: page, PageSize: pageSize, Action: strings.TrimSpace(c.Query("action")), ActorUserID: actorID, DateFrom: dateFrom, DateTo: dateTo}
        items, p, err := h.svc.ListOperationLogs(c.Request.Context(), "game", id, opts)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 500, err.Error())
                return
        }</span>
        <span class="cov0" title="0">if strings.EqualFold(strings.TrimSpace(c.Query("export")), "csv") </span><span class="cov0" title="0">{
                exportOperationLogsCSV(c, "game", id, items)
                return
        }</span>
        <span class="cov0" title="0">items = ensureSlice(items)
        writeJSON(c, 200, model.APIResponse[[]model.OperationLog]{Success: true, Code: 200, Message: "OK", Data: items, Pagination: p})</span>
}

// GamePayload defines request body for creating/updating a game.
type GamePayload struct {
        Key         string `json:"key" binding:"required"`
        Name        string `json:"name" binding:"required"`
        Category    string `json:"category"`
        IconURL     string `json:"icon_url"`
        Description string `json:"description"`
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package admin

import (
        "errors"
        "strconv"
        "strings"
        "time"

        "github.com/gin-gonic/gin"

        apierr "gamelink/internal/handler"
        "gamelink/internal/model"
        "gamelink/internal/repository"
)

func parseUintParam(c *gin.Context, key string) (uint64, error) <span class="cov8" title="1">{
        return strconv.ParseUint(c.Param(key), 10, 64)
}</span>

func queryIntDefault(c *gin.Context, key string, defaults int) (int, error) <span class="cov8" title="1">{
        value := strings.TrimSpace(c.Query(key))
        if value == "" </span><span class="cov8" title="1">{
                return defaults, nil
        }</span>
        <span class="cov8" title="1">i, err := strconv.Atoi(value)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return i, nil</span>
}

func queryUint64Ptr(c *gin.Context, key string) (*uint64, error) <span class="cov8" title="1">{
        value := strings.TrimSpace(c.Query(key))
        if value == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">parsed, err := strconv.ParseUint(value, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;parsed, nil</span>
}

func queryTimePtr(c *gin.Context, key string) (*time.Time, error) <span class="cov8" title="1">{
        value := strings.TrimSpace(c.Query(key))
        if value == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        // Try common formats: RFC3339, "2006-01-02 15:04:05", "2006-01-02", unix seconds
        <span class="cov8" title="1">if t, err := time.Parse(time.RFC3339, value); err == nil </span><span class="cov8" title="1">{
                return &amp;t, nil
        }</span>
        <span class="cov8" title="1">layouts := []string{"2006-01-02 15:04:05", "2006-01-02"}
        for _, layout := range layouts </span><span class="cov8" title="1">{
                if t, err := time.ParseInLocation(layout, value, time.Local); err == nil </span><span class="cov8" title="1">{
                        return &amp;t, nil
                }</span>
        }
        <span class="cov8" title="1">if sec, err := strconv.ParseInt(value, 10, 64); err == nil </span><span class="cov0" title="0">{
                t := time.Unix(sec, 0)
                return &amp;t, nil
        }</span>
        <span class="cov8" title="1">return nil, errors.New("invalid time format")</span>
}

func parseCSVParams(values []string) []string <span class="cov8" title="1">{
        result := make([]string, 0)
        for _, raw := range values </span><span class="cov8" title="1">{
                parts := strings.Split(raw, ",")
                for _, part := range parts </span><span class="cov8" title="1">{
                        if trimmed := strings.TrimSpace(part); trimmed != "" </span><span class="cov8" title="1">{
                                result = append(result, trimmed)
                        }</span>
                }
        }
        <span class="cov8" title="1">return result</span>
}

func writeJSON[T any](c *gin.Context, status int, payload model.APIResponse[T]) <span class="cov8" title="1">{
        c.JSON(status, payload)
}</span>

func writeJSONError(c *gin.Context, status int, message string) <span class="cov8" title="1">{
        writeJSON(c, status, model.APIResponse[any]{
                Success: false,
                Code:    status,
                Message: message,
        })
}</span>

func ensureSlice[T any](items []T) []T <span class="cov8" title="1">{
        if items == nil </span><span class="cov8" title="1">{
                return make([]T, 0)
        }</span>
        <span class="cov8" title="1">return items</span>
}

// parsePagination parses page and page_size with defaults and writes error response when invalid.
func parsePagination(c *gin.Context) (int, int, bool) <span class="cov8" title="1">{
        page, err := queryIntDefault(c, "page", 1)
        if err != nil </span><span class="cov8" title="1">{
                writeJSONError(c, 400, apierr.ErrInvalidPage)
                return 0, 0, false
        }</span>
        <span class="cov8" title="1">pageSize, err := queryIntDefault(c, "page_size", 20)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidPageSize)
                return 0, 0, false
        }</span>
        <span class="cov8" title="1">return page, pageSize, true</span>
}

// buildOrderListOptions parses query parameters into OrderListOptions; on error responds and returns false.
func buildOrderListOptions(c *gin.Context) (repository.OrderListOptions, bool) <span class="cov8" title="1">{
        page, pageSize, ok := parsePagination(c)
        if !ok </span><span class="cov0" title="0">{
                return repository.OrderListOptions{}, false
        }</span>

        <span class="cov8" title="1">statusTokens := parseCSVParams(c.QueryArray("status"))
        statuses := make([]model.OrderStatus, 0, len(statusTokens))
        for _, token := range statusTokens </span><span class="cov8" title="1">{
                statuses = append(statuses, normalizeOrderStatus(token))
        }</span>

        <span class="cov8" title="1">userID, err := queryUint64Ptr(c, "user_id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidUserID)
                return repository.OrderListOptions{}, false
        }</span>
        <span class="cov8" title="1">playerID, err := queryUint64Ptr(c, "player_id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidPlayerID)
                return repository.OrderListOptions{}, false
        }</span>
        <span class="cov8" title="1">gameID, err := queryUint64Ptr(c, "game_id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidGameID)
                return repository.OrderListOptions{}, false
        }</span>
        <span class="cov8" title="1">dateFrom, err := queryTimePtr(c, "date_from")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidDateFrom)
                return repository.OrderListOptions{}, false
        }</span>
        <span class="cov8" title="1">dateTo, err := queryTimePtr(c, "date_to")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidDateTo)
                return repository.OrderListOptions{}, false
        }</span>

        <span class="cov8" title="1">return repository.OrderListOptions{
                Page:     page,
                PageSize: pageSize,
                Statuses: statuses,
                UserID:   userID,
                PlayerID: playerID,
                GameID:   gameID,
                DateFrom: dateFrom,
                DateTo:   dateTo,
                Keyword:  strings.TrimSpace(c.Query("keyword")),
        }, true</span>
}

// buildPaymentListOptions parses query parameters into PaymentListOptions; on error responds and returns false.
func buildPaymentListOptions(c *gin.Context) (repository.PaymentListOptions, bool) <span class="cov8" title="1">{
        page, pageSize, ok := parsePagination(c)
        if !ok </span><span class="cov0" title="0">{
                return repository.PaymentListOptions{}, false
        }</span>

        <span class="cov8" title="1">statusTokens := parseCSVParams(c.QueryArray("status"))
        statuses := make([]model.PaymentStatus, 0, len(statusTokens))
        for _, token := range statusTokens </span><span class="cov8" title="1">{
                statuses = append(statuses, model.PaymentStatus(strings.ToLower(token)))
        }</span>

        <span class="cov8" title="1">methodTokens := parseCSVParams(c.QueryArray("method"))
        methods := make([]model.PaymentMethod, 0, len(methodTokens))
        for _, token := range methodTokens </span><span class="cov8" title="1">{
                methods = append(methods, model.PaymentMethod(strings.ToLower(token)))
        }</span>

        <span class="cov8" title="1">userID, err := queryUint64Ptr(c, "user_id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidUserID)
                return repository.PaymentListOptions{}, false
        }</span>
        <span class="cov8" title="1">orderID, err := queryUint64Ptr(c, "order_id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidOrderID)
                return repository.PaymentListOptions{}, false
        }</span>
        <span class="cov8" title="1">dateFrom, err := queryTimePtr(c, "date_from")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidDateFrom)
                return repository.PaymentListOptions{}, false
        }</span>
        <span class="cov8" title="1">dateTo, err := queryTimePtr(c, "date_to")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidDateTo)
                return repository.PaymentListOptions{}, false
        }</span>

        <span class="cov8" title="1">return repository.PaymentListOptions{
                Page:     page,
                PageSize: pageSize,
                Statuses: statuses,
                Methods:  methods,
                UserID:   userID,
                OrderID:  orderID,
                DateFrom: dateFrom,
                DateTo:   dateTo,
        }, true</span>
}

// normalizeOrderStatus maps legacy spellings to canonical values.
// Accepts "cancelled" (legacy) and returns "canceled".
func normalizeOrderStatus(s string) model.OrderStatus <span class="cov8" title="1">{ //nolint:misspell // accepts legacy 'cancelled'
        v := strings.TrimSpace(strings.ToLower(s))
        switch v </span>{
        case "cancelled":<span class="cov8" title="1"> // legacy spelling
                return model.OrderStatusCanceled</span>
        default:<span class="cov8" title="1">
                return model.OrderStatus(v)</span>
        }
}

// buildUserListOptions parses query parameters for user listing.
func buildUserListOptions(c *gin.Context) (repository.UserListOptions, bool) <span class="cov8" title="1">{
        page, pageSize, ok := parsePagination(c)
        if !ok </span><span class="cov0" title="0">{
                return repository.UserListOptions{}, false
        }</span>

        <span class="cov8" title="1">roleTokens := parseCSVParams(c.QueryArray("role"))
        roles := make([]model.Role, 0, len(roleTokens))
        for _, t := range roleTokens </span><span class="cov8" title="1">{
                roles = append(roles, model.Role(strings.ToLower(t)))
        }</span>

        <span class="cov8" title="1">statusTokens := parseCSVParams(c.QueryArray("status"))
        statuses := make([]model.UserStatus, 0, len(statusTokens))
        for _, t := range statusTokens </span><span class="cov8" title="1">{
                statuses = append(statuses, model.UserStatus(strings.ToLower(t)))
        }</span>

        <span class="cov8" title="1">dateFrom, err := queryTimePtr(c, "date_from")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidDateFrom)
                return repository.UserListOptions{}, false
        }</span>
        <span class="cov8" title="1">dateTo, err := queryTimePtr(c, "date_to")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidDateTo)
                return repository.UserListOptions{}, false
        }</span>

        <span class="cov8" title="1">return repository.UserListOptions{
                Page:     page,
                PageSize: pageSize,
                Roles:    roles,
                Statuses: statuses,
                DateFrom: dateFrom,
                DateTo:   dateTo,
                Keyword:  strings.TrimSpace(c.Query("keyword")),
        }, true</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package admin

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"

        "gamelink/internal/model"
        "gamelink/internal/service/item"
)

// RegisterServiceItemRoutes 注册管理端服务项目管理路�?
func RegisterServiceItemRoutes(router gin.IRouter, svc *item.ServiceItemService) <span class="cov0" title="0">{
        group := router.Group("/admin/service-items")
        </span><span class="cov0" title="0">{
                group.POST("", func(c *gin.Context) </span><span class="cov0" title="0">{ createServiceItemHandler(c, svc) }</span>)
                <span class="cov0" title="0">group.GET("", func(c *gin.Context) </span><span class="cov0" title="0">{ listServiceItemsHandler(c, svc) }</span>)
                <span class="cov0" title="0">group.GET("/:id", func(c *gin.Context) </span><span class="cov0" title="0">{ getServiceItemHandler(c, svc) }</span>)
                <span class="cov0" title="0">group.PUT("/:id", func(c *gin.Context) </span><span class="cov0" title="0">{ updateServiceItemHandler(c, svc) }</span>)
                <span class="cov0" title="0">group.DELETE("/:id", func(c *gin.Context) </span><span class="cov0" title="0">{ deleteServiceItemHandler(c, svc) }</span>)
                <span class="cov0" title="0">group.POST("/batch-update-status", func(c *gin.Context) </span><span class="cov0" title="0">{ batchUpdateStatusHandler(c, svc) }</span>)
                <span class="cov0" title="0">group.POST("/batch-update-price", func(c *gin.Context) </span><span class="cov0" title="0">{ batchUpdatePriceHandler(c, svc) }</span>)
        }
}

// createServiceItemHandler 创建服务项目
// @Summary      创建服务项目
// @Description  管理员创建服务项目（护航服务或礼物）
// @Tags         Admin - ServiceItem
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string                                true  "Bearer {token}"
// @Param        request        body      serviceitem.CreateServiceItemRequest  true  "服务项目信息"
// @Success      200            {object}  model.APIResponse[model.ServiceItem]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/service-items [post]
func createServiceItemHandler(c *gin.Context, svc *item.ServiceItemService) <span class="cov0" title="0">{
        var req item.CreateServiceItemRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">item, err := svc.CreateServiceItem(c.Request.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[model.ServiceItem]{
                Success: true,
                Code:    http.StatusOK,
                Message: "Service item created successfully",
                Data:    *item,
        })</span>
}

// listServiceItemsHandler 获取服务项目列表
// @Summary      获取服务项目列表
// @Description  管理员查看所有服务项�?
// @Tags         Admin - ServiceItem
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        category       query     string  false  "分类"
// @Param        subCategory    query     string  false  "子分�?solo/team/gift)"
// @Param        gameId         query     int     false  "游戏ID"
// @Param        isActive       query     bool    false  "是否激�?
// @Param        page           query     int     false  "页码"
// @Param        pageSize       query     int     false  "每页数量"
// @Success      200            {object}  model.APIResponse[serviceitem.ServiceItemListResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/service-items [get]
func listServiceItemsHandler(c *gin.Context, svc *item.ServiceItemService) <span class="cov0" title="0">{
        var req item.ListServiceItemsRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">resp, err := svc.ListServiceItems(c.Request.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[item.ServiceItemListResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *resp,
        })</span>
}

// getServiceItemHandler 获取服务项目详情
// @Summary      获取服务项目详情
// @Description  管理员查看服务项目详�?
// @Tags         Admin - ServiceItem
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Param        id             path      int     true  "服务项目ID"
// @Success      200            {object}  model.APIResponse[serviceitem.ServiceItemDTO]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/service-items/{id} [get]
func getServiceItemHandler(c *gin.Context, svc *item.ServiceItemService) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "Invalid service item ID")
                return
        }</span>

        <span class="cov0" title="0">resp, err := svc.GetServiceItem(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                if err == item.ErrNotFound </span><span class="cov0" title="0">{
                        writeJSONError(c, http.StatusNotFound, "Service item not found")
                        return
                }</span>
                <span class="cov0" title="0">writeJSONError(c, http.StatusInternalServerError, err.Error())
                return</span>
        }

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[item.ServiceItemDTO]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *resp,
        })</span>
}

// updateServiceItemHandler 更新服务项目
// @Summary      更新服务项目
// @Description  管理员更新服务项�?
// @Tags         Admin - ServiceItem
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string                                 true  "Bearer {token}"
// @Param        id             path      int                                    true  "服务项目ID"
// @Param        request        body      serviceitem.UpdateServiceItemRequest  true  "更新信息"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/service-items/{id} [put]
func updateServiceItemHandler(c *gin.Context, svc *item.ServiceItemService) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "Invalid service item ID")
                return
        }</span>

        <span class="cov0" title="0">var req item.UpdateServiceItemRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">err = svc.UpdateServiceItem(c.Request.Context(), id, req)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "Service item updated successfully",
        })</span>
}

// deleteServiceItemHandler 删除服务项目
// @Summary      删除服务项目
// @Description  管理员删除服务项�?
// @Tags         Admin - ServiceItem
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Param        id             path      int     true  "服务项目ID"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/service-items/{id} [delete]
func deleteServiceItemHandler(c *gin.Context, svc *item.ServiceItemService) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "Invalid service item ID")
                return
        }</span>

        <span class="cov0" title="0">err = svc.DeleteServiceItem(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "Service item deleted successfully",
        })</span>
}

// batchUpdateStatusHandler 批量更新状�?
// @Summary      批量更新状�?
// @Description  管理员批量启�?禁用服务项目
// @Tags         Admin - ServiceItem
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string                                  true  "Bearer {token}"
// @Param        request        body      serviceitem.BatchUpdateStatusRequest  true  "批量更新请求"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/service-items/batch-update-status [post]
func batchUpdateStatusHandler(c *gin.Context, svc *item.ServiceItemService) <span class="cov0" title="0">{
        var req item.BatchUpdateStatusRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">err := svc.BatchUpdateStatus(c.Request.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "Status updated successfully",
        })</span>
}

// batchUpdatePriceHandler 批量更新价格
// @Summary      批量更新价格
// @Description  管理员批量调整服务项目价�?
// @Tags         Admin - ServiceItem
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string                                 true  "Bearer {token}"
// @Param        request        body      serviceitem.BatchUpdatePriceRequest  true  "批量更新请求"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/service-items/batch-update-price [post]
func batchUpdatePriceHandler(c *gin.Context, svc *item.ServiceItemService) <span class="cov0" title="0">{
        var req item.BatchUpdatePriceRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">err := svc.BatchUpdatePrice(c.Request.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "Price updated successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package admin

import (
        "encoding/csv"
        "encoding/json"
        "errors"
        "net/http"
        "strings"
        "time"

        "github.com/gin-gonic/gin"

        apierr "gamelink/internal/handler"
        "gamelink/internal/model"
        "gamelink/internal/repository"
        adminservice "gamelink/internal/service/admin"
        service "gamelink/internal/service/admin"
        "strconv"
)

// OrderHandler 管理订单相关接口
type OrderHandler struct {
        svc *service.AdminService
}

// NewOrderHandler 创建 Handler
func NewOrderHandler(svc *service.AdminService) *OrderHandler <span class="cov8" title="1">{
        return &amp;OrderHandler{svc: svc}
}</span>

// CreateOrder
// @Summary      创建订单
// @Tags         Admin/Orders
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        request  body  CreateOrderPayload  true  "订单信息"
// @Success      201  {object}  map[string]any
// @Failure      400  {object}  map[string]any
// @Router       /admin/orders [post]
func (h *OrderHandler) CreateOrder(c *gin.Context) <span class="cov8" title="1">{
        var p CreateOrderPayload
        if err := c.ShouldBindJSON(&amp;p); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                return
        }</span>
        <span class="cov8" title="1">start, err := parseRFC3339Ptr(p.ScheduledStart)
        if err != nil </span><span class="cov8" title="1">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidScheduledStart)
                return
        }</span>
        <span class="cov8" title="1">end, err := parseRFC3339Ptr(p.ScheduledEnd)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidScheduledEnd)
                return
        }</span>
        <span class="cov8" title="1">var playerID *uint64
        if p.PlayerID != nil </span><span class="cov0" title="0">{
                playerID = p.PlayerID
        }</span>
        <span class="cov8" title="1">order, err := h.svc.CreateOrder(c.Request.Context(), service.CreateOrderInput{
                UserID:          p.UserID,
                PlayerID:        playerID,
                GameID:          p.GameID,
                Title:           p.Title,
                Description:     p.Description,
                TotalPriceCents: p.TotalPriceCents,
                Currency:        model.Currency(strings.ToUpper(strings.TrimSpace(p.Currency))),
                ScheduledStart:  start,
                ScheduledEnd:    end,
        })
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov8" title="1">writeJSON(c, http.StatusCreated, model.APIResponse[*model.Order]{Success: true, Code: http.StatusCreated, Message: "created", Data: order})</span>
}

// AssignOrder
// @Summary      指派订单的陪玩师
// @Tags         Admin/Orders
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        id       path  int                 true  "订单ID"
// @Param        request  body  AssignOrderPayload  true  "指派信息"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/orders/{id}/assign [post]
func (h *OrderHandler) AssignOrder(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">var p AssignOrderPayload
        if err := c.ShouldBindJSON(&amp;p); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                return
        }</span>
        <span class="cov8" title="1">order, err := h.svc.AssignOrder(c.Request.Context(), id, p.PlayerID)
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov8" title="1">if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov8" title="1">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[*model.Order]{Success: true, Code: http.StatusOK, Message: "updated", Data: order})</span>
}

// ConfirmOrder 确认订单�?// @Summary      确认订单
// @Description  将订单状态从 pending 置为 confirmed
// @Tags         Admin/Orders
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        id       path  int               true  "订单ID"
// @Param        request  body  orderNotePayload  false "备注（可选）"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/orders/{id}/confirm [post]
func (h *OrderHandler) ConfirmOrder(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">var payload orderNotePayload
        if c.Request.ContentLength &gt; 0 </span><span class="cov8" title="1">{
                if bindErr := c.ShouldBindJSON(&amp;payload); bindErr != nil </span><span class="cov0" title="0">{
                        writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                        return
                }</span>
        }
        <span class="cov8" title="1">order, err := h.svc.ConfirmOrder(c.Request.Context(), id, payload.Note)
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov8" title="1">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov0" title="0">if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[*model.Order]{Success: true, Code: http.StatusOK, Message: "updated", Data: order})</span>
}

// StartOrder 开始服务�?// @Summary      开始服�?// @Description  将订单状态从 confirmed 置为 in_progress，并记录开始时�?// @Tags         Admin/Orders
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        id       path  int               true  "订单ID"
// @Param        request  body  orderNotePayload  false "备注（可选）"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/orders/{id}/start [post]
func (h *OrderHandler) StartOrder(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">var payload orderNotePayload
        if c.Request.ContentLength &gt; 0 </span><span class="cov8" title="1">{
                if bindErr := c.ShouldBindJSON(&amp;payload); bindErr != nil </span><span class="cov0" title="0">{
                        writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                        return
                }</span>
        }
        <span class="cov8" title="1">order, err := h.svc.StartOrder(c.Request.Context(), id, payload.Note)
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov8" title="1">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov0" title="0">if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[*model.Order]{Success: true, Code: http.StatusOK, Message: "updated", Data: order})</span>
}

// CompleteOrder 完成订单�?// @Summary      完成订单
// @Description  将订单状态从 in_progress 置为 completed，并记录完成时间
// @Tags         Admin/Orders
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        id       path  int               true  "订单ID"
// @Param        request  body  orderNotePayload  false "备注（可选）"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/orders/{id}/complete [post]
func (h *OrderHandler) CompleteOrder(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">var payload orderNotePayload
        if c.Request.ContentLength &gt; 0 </span><span class="cov8" title="1">{
                if bindErr := c.ShouldBindJSON(&amp;payload); bindErr != nil </span><span class="cov0" title="0">{
                        writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                        return
                }</span>
        }
        <span class="cov8" title="1">order, err := h.svc.CompleteOrder(c.Request.Context(), id, payload.Note)
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov8" title="1">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov0" title="0">if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[*model.Order]{Success: true, Code: http.StatusOK, Message: "updated", Data: order})</span>
}

// ListOrders
// @Summary      列出订单
// @Description  根据状�?用户/玩家/游戏和时间范围筛选，支持分页
// @Tags         Admin/Orders
// @Security     BearerAuth
// @Param        page        query  int     false  "页码"
// @Param        pageSize   query     int       false  "每页数量"
// @Param        status      query  []string  false  "订单状态，可多�?
// @Param        userId     query     int       false  "用户ID"
// @Param        player_id   query  int     false  "玩家ID"
// @Param        gameId     query     int       false  "游戏ID"
// @Param        dateFrom   query     string    false  "开始时�?
// @Param        dateTo     query     string    false  "结束时间"
// @Produce      json
// @Success      200  {object}  map[string]any
// @Router       /admin/orders [get]
//
// ListOrders returns a paginated list of orders with filters.
func (h *OrderHandler) ListOrders(c *gin.Context) <span class="cov8" title="1">{
        opts, ok := buildOrderListOptions(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">orders, pagination, err := h.svc.ListOrders(c.Request.Context(), opts)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov8" title="1">orders = ensureSlice(orders)
        writeJSON(c, http.StatusOK, model.APIResponse[[]model.Order]{
                Success:    true,
                Code:       http.StatusOK,
                Message:    "OK",
                Data:       orders,
                Pagination: pagination,
        })</span>
}

// GetOrder
// @Summary      获取订单
// @Tags         Admin/Orders
// @Security     BearerAuth
// @Param        id   path  int  true  "订单ID"
// @Produce      json
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/orders/{id} [get]
//
// GetOrder returns a single order by id.
func (h *OrderHandler) GetOrder(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">order, err := h.svc.GetOrder(c.Request.Context(), id)
        if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov8" title="1">{
                writeJSONError(c, http.StatusNotFound, apierr.ErrOrderNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[*model.Order]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    order,
        })</span>
}

// RefundOrder 处理订单退款�?// @Summary      订单退�?// @Description  将订单状态标记为 refunded，并记录退款金额与原因，同时关联支付退�?// @Tags         Admin/Orders
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        id       path  int                  true  "订单ID"
// @Param        request  body  orderRefundPayload   true  "退款信�?
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/orders/{id}/refund [post]
func (h *OrderHandler) RefundOrder(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">var payload orderRefundPayload
        if err := c.ShouldBindJSON(&amp;payload); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                return
        }</span>
        <span class="cov8" title="1">order, err := h.svc.RefundOrder(c.Request.Context(), id, service.RefundOrderInput{
                Reason:      payload.Reason,
                AmountCents: payload.AmountCents,
                Note:        payload.Note,
        })
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov8" title="1">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov0" title="0">if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[*model.Order]{Success: true, Code: http.StatusOK, Message: "updated", Data: order})</span>
}

// GetOrderTimeline 返回订单时间线�?// @Summary      获取订单时间�?// @Description  汇总订单的状态变更、操作日志、支付事件等信息
// @Tags         Admin/Orders
// @Security     BearerAuth
// @Produce      json
// @Param        id   path  int  true  "订单ID"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/orders/{id}/timeline [get]
func (h *OrderHandler) GetOrderTimeline(c *gin.Context) <span class="cov0" title="0">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov0" title="0">items, err := h.svc.GetOrderTimeline(c.Request.Context(), id)
        if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[[]service.OrderTimelineItem]{Success: true, Code: http.StatusOK, Message: "OK", Data: ensureSlice(items)})</span>
}

// ListOrderPayments 返回订单关联的支付记录�?// @Summary      获取订单支付记录
// @Tags         Admin/Orders
// @Security     BearerAuth
// @Produce      json
// @Param        id   path  int  true  "订单ID"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/orders/{id}/payments [get]
func (h *OrderHandler) ListOrderPayments(c *gin.Context) <span class="cov0" title="0">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov0" title="0">items, err := h.svc.GetOrderPayments(c.Request.Context(), id)
        if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov0" title="0">payments := ensureSlice(items)
        writeJSON(c, http.StatusOK, model.APIResponse[[]model.Payment]{Success: true, Code: http.StatusOK, Message: "OK", Data: payments})</span>
}

// ListOrderRefunds 返回订单的退款记录�?// @Summary      获取订单退款记�?// @Tags         Admin/Orders
// @Security     BearerAuth
// @Produce      json
// @Param        id   path  int  true  "订单ID"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/orders/{id}/refunds [get]
func (h *OrderHandler) ListOrderRefunds(c *gin.Context) <span class="cov0" title="0">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov0" title="0">items, err := h.svc.GetOrderRefunds(c.Request.Context(), id)
        if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[[]service.OrderRefundItem]{Success: true, Code: http.StatusOK, Message: "OK", Data: ensureSlice(items)})</span>
}

// ListOrderReviews 返回订单评价列表�?// @Summary      获取订单评价列表
// @Tags         Admin/Orders
// @Security     BearerAuth
// @Produce      json
// @Param        id   path  int  true  "订单ID"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/orders/{id}/reviews [get]
func (h *OrderHandler) ListOrderReviews(c *gin.Context) <span class="cov0" title="0">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov0" title="0">items, err := h.svc.GetOrderReviews(c.Request.Context(), id)
        if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[[]model.Review]{Success: true, Code: http.StatusOK, Message: "OK", Data: ensureSlice(items)})</span>
}

// UpdateOrder
// @Summary      更新订单
// @Tags         Admin/Orders
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        id       path  int                true  "订单ID"
// @Param        request  body  UpdateOrderPayload true  "订单信息"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/orders/{id} [put]
//
// UpdateOrder updates order fields such as status and schedule.
func (h *OrderHandler) UpdateOrder(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>

        <span class="cov8" title="1">var payload UpdateOrderPayload
        if bindErr := c.ShouldBindJSON(&amp;payload); bindErr != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                return
        }</span>

        <span class="cov8" title="1">scheduledStart, err := parseRFC3339Ptr(payload.ScheduledStart)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidScheduledStart)
                return
        }</span>
        <span class="cov8" title="1">scheduledEnd, err := parseRFC3339Ptr(payload.ScheduledEnd)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidScheduledEnd)
                return
        }</span>

        <span class="cov8" title="1">input := service.UpdateOrderInput{
                Status:          normalizeOrderStatus(payload.Status),
                TotalPriceCents: payload.TotalPriceCents,
                Currency:        model.Currency(strings.ToUpper(strings.TrimSpace(payload.Currency))),
                ScheduledStart:  scheduledStart,
                ScheduledEnd:    scheduledEnd,
                CancelReason:    payload.CancelReason,
        }

        order, err := h.svc.UpdateOrder(c.Request.Context(), id, input)
        if errors.Is(err, service.ErrOrderInvalidTransition) </span><span class="cov8" title="1">{
                _ = c.Error(service.ErrOrderInvalidTransition)
                return
        }</span>
        <span class="cov0" title="0">if errors.Is(err, adminservice.ErrValidation) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov0" title="0">if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[*model.Order]{
                Success: true,
                Code:    http.StatusOK,
                Message: "updated",
                Data:    order,
        })</span>
}

// DeleteOrder
// @Summary      删除订单
// @Tags         Admin/Orders
// @Security     BearerAuth
// @Param        id   path  int  true  "订单ID"
// @Produce      json
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/orders/{id} [delete]
//
// DeleteOrder deletes an order by id.
func (h *OrderHandler) DeleteOrder(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">err = h.svc.DeleteOrder(c.Request.Context(), id)
        if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "deleted",
        })</span>
}

// ListOrderLogs
// @Summary      获取订单操作日志
// @Tags         Admin/Orders
// @Security     BearerAuth
// @Produce      json
// @Param        id         path   int  true  "订单ID"
// @Param        page       query  int  false "页码"
// @Param        pageSize   query     int       false  "每页数量"
// @Param        action     query  string false "动作过滤" Enums(create,assign_player,update_status,cancel,delete)
// @Param        actor_user_id query int false "操作者用户ID"
// @Param        dateFrom   query     string    false  "开始时�?
// @Param        dateTo     query     string    false  "结束时间"
// @Param        export     query  string false "导出格式" Enums(csv)
// @Param        fields     query  string false "导出列（逗号分隔），默认：id,entity_type,entity_id,actor_user_id,action,reason,metadata,created_at"
// @Param        header_lang query string false "列头语言" Enums(en,zh)
// @Success      200  {object}  map[string]any
// @Router       /admin/orders/{id}/logs [get]
func (h *OrderHandler) ListOrderLogs(c *gin.Context) <span class="cov0" title="0">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov0" title="0">page, pageSize, ok := parsePagination(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">var actorID *uint64
        if v, err := queryUint64Ptr(c, "actor_user_id"); err == nil </span><span class="cov0" title="0">{
                actorID = v
        }</span>
        <span class="cov0" title="0">var dateFrom, dateTo *time.Time
        if v, err := queryTimePtr(c, "date_from"); err == nil </span><span class="cov0" title="0">{
                dateFrom = v
        }</span> else<span class="cov0" title="0"> {
                writeJSONError(c, 400, apierr.ErrInvalidDateFrom)
                return
        }</span>
        <span class="cov0" title="0">if v, err := queryTimePtr(c, "date_to"); err == nil </span><span class="cov0" title="0">{
                dateTo = v
        }</span> else<span class="cov0" title="0"> {
                writeJSONError(c, 400, apierr.ErrInvalidDateTo)
                return
        }</span>
        <span class="cov0" title="0">opts := repository.OperationLogListOptions{Page: page, PageSize: pageSize, Action: strings.TrimSpace(c.Query("action")), ActorUserID: actorID, DateFrom: dateFrom, DateTo: dateTo}
        items, p, err := h.svc.ListOperationLogs(c.Request.Context(), "order", id, opts)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov0" title="0">if strings.EqualFold(strings.TrimSpace(c.Query("export")), "csv") </span><span class="cov0" title="0">{
                exportOperationLogsCSV(c, "order", id, items)
                return
        }</span>
        <span class="cov0" title="0">items = ensureSlice(items)
        writeJSON(c, http.StatusOK, model.APIResponse[[]model.OperationLog]{Success: true, Code: http.StatusOK, Message: "OK", Data: items, Pagination: p})</span>
}

// UpdateOrderPayload defines the request body for updating an order.
type UpdateOrderPayload struct {
        Status          string  `json:"status" binding:"required"`
        TotalPriceCents int64   `json:"total_price_cents" binding:"required"`
        Currency        string  `json:"currency" binding:"required"`
        ScheduledStart  *string `json:"scheduled_start"`
        ScheduledEnd    *string `json:"scheduled_end"`
        CancelReason    string  `json:"cancel_reason"`
}

// CreateOrderPayload defines payload for creating an order.
type CreateOrderPayload struct {
        UserID          uint64  `json:"user_id" binding:"required"`
        PlayerID        *uint64 `json:"player_id"`
        GameID          uint64  `json:"game_id" binding:"required"`
        Title           string  `json:"title"`
        Description     string  `json:"description"`
        TotalPriceCents int64   `json:"total_price_cents" binding:"required"`
        Currency        string  `json:"currency" binding:"required"`
        ScheduledStart  *string `json:"scheduled_start"`
        ScheduledEnd    *string `json:"scheduled_end"`
}

// AssignOrderPayload defines player assignment.
type AssignOrderPayload struct {
        PlayerID uint64 `json:"player_id" binding:"required"`
}

// PaymentHandler 管理支付记录
type PaymentHandler struct {
        svc *service.AdminService
}

// NewPaymentHandler 创建 Handler
func NewPaymentHandler(svc *service.AdminService) *PaymentHandler <span class="cov8" title="1">{
        return &amp;PaymentHandler{svc: svc}
}</span>

// CreatePayment
// @Summary      创建支付记录
// @Tags         Admin/Payments
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        request  body  CreatePaymentPayload  true  "支付信息"
// @Success      201  {object}  map[string]any
// @Failure      400  {object}  map[string]any
// @Router       /admin/payments [post]
func (h *PaymentHandler) CreatePayment(c *gin.Context) <span class="cov8" title="1">{
        var p CreatePaymentPayload
        if err := c.ShouldBindJSON(&amp;p); err != nil </span><span class="cov8" title="1">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                return
        }</span>
        <span class="cov8" title="1">pay, err := h.svc.CreatePayment(c.Request.Context(), service.CreatePaymentInput{
                OrderID:     p.OrderID,
                UserID:      p.UserID,
                Method:      model.PaymentMethod(strings.ToLower(strings.TrimSpace(p.Method))),
                AmountCents: p.AmountCents,
                Currency:    model.Currency(strings.ToUpper(strings.TrimSpace(p.Currency))),
                ProviderRaw: p.ProviderRaw,
        })
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov8" title="1">writeJSON(c, http.StatusCreated, model.APIResponse[*model.Payment]{Success: true, Code: http.StatusCreated, Message: "created", Data: pay})</span>
}

// CapturePayment
// @Summary      确认支付入账
// @Tags         Admin/Payments
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        id       path  int                     true  "支付ID"
// @Param        request  body  CapturePaymentPayload   true  "入账信息"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/payments/{id}/capture [post]
func (h *PaymentHandler) CapturePayment(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">var p CapturePaymentPayload
        if err := c.ShouldBindJSON(&amp;p); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                return
        }</span>
        <span class="cov8" title="1">paidAt, err := parseRFC3339Ptr(p.PaidAt)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidPaidAt)
                return
        }</span>
        <span class="cov8" title="1">pay, err := h.svc.CapturePayment(c.Request.Context(), id, service.CapturePaymentInput{
                ProviderTradeNo: p.ProviderTradeNo,
                ProviderRaw:     p.ProviderRaw,
                PaidAt:          paidAt,
        })
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov8" title="1">if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[*model.Payment]{Success: true, Code: http.StatusOK, Message: "updated", Data: pay})</span>
}

// ListPayments
// @Summary      列出支付
// @Description  根据状�?方法/用户/订单和时间范围筛选，支持分页
// @Tags         Admin/Payments
// @Security     BearerAuth
// @Param        page        query  int       false  "页码"
// @Param        pageSize   query     int       false  "每页数量"
// @Param        status      query  []string  false  "支付状�?
// @Param        method      query  []string  false  "支付方式"
// @Param        userId     query     int       false  "用户ID"
// @Param        orderId     query     int       false  "订单ID"
// @Param        dateFrom   query     string    false  "开始时�?
// @Param        dateTo     query     string    false  "结束时间"
// @Produce      json
// @Success      200  {object}  map[string]any
// @Router       /admin/payments [get]
//
// ListPayments returns a paginated list of payments with filters.
func (h *PaymentHandler) ListPayments(c *gin.Context) <span class="cov8" title="1">{
        opts, ok := buildPaymentListOptions(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">payments, pagination, err := h.svc.ListPayments(c.Request.Context(), opts)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov8" title="1">payments = ensureSlice(payments)
        writeJSON(c, http.StatusOK, model.APIResponse[[]model.Payment]{
                Success:    true,
                Code:       http.StatusOK,
                Message:    "OK",
                Data:       payments,
                Pagination: pagination,
        })</span>
}

// GetPayment
// @Summary      获取支付
// @Tags         Admin/Payments
// @Security     BearerAuth
// @Param        id   path  int  true  "支付ID"
// @Produce      json
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/payments/{id} [get]
//
// GetPayment returns a single payment by id.
func (h *PaymentHandler) GetPayment(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">payment, err := h.svc.GetPayment(c.Request.Context(), id)
        if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov8" title="1">{
                writeJSONError(c, http.StatusNotFound, apierr.ErrPaymentNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[*model.Payment]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    payment,
        })</span>
}

// UpdatePayment
// @Summary      更新支付
// @Tags         Admin/Payments
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        id       path  int                  true  "支付ID"
// @Param        request  body  UpdatePaymentPayload true  "支付信息"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/payments/{id} [put]
//
// UpdatePayment updates payment fields such as status and provider info.
func (h *PaymentHandler) UpdatePayment(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>

        <span class="cov8" title="1">var payload UpdatePaymentPayload
        if bindErr := c.ShouldBindJSON(&amp;payload); bindErr != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                return
        }</span>

        <span class="cov8" title="1">paidAt, err := parseRFC3339Ptr(payload.PaidAt)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidPaidAt)
                return
        }</span>
        <span class="cov8" title="1">refundedAt, err := parseRFC3339Ptr(payload.RefundedAt)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidRefundedAt)
                return
        }</span>

        <span class="cov8" title="1">input := service.UpdatePaymentInput{
                Status:          model.PaymentStatus(strings.TrimSpace(payload.Status)),
                ProviderTradeNo: payload.ProviderTradeNo,
                ProviderRaw:     payload.ProviderRaw,
                PaidAt:          paidAt,
                RefundedAt:      refundedAt,
        }

        payment, err := h.svc.UpdatePayment(c.Request.Context(), id, input)
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov8" title="1">if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[*model.Payment]{
                Success: true,
                Code:    http.StatusOK,
                Message: "updated",
                Data:    payment,
        })</span>
}

// DeletePayment
// @Summary      删除支付
// @Tags         Admin/Payments
// @Security     BearerAuth
// @Param        id   path  int  true  "支付ID"
// @Produce      json
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/payments/{id} [delete]
//
// DeletePayment deletes a payment record by id.
func (h *PaymentHandler) DeletePayment(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">err = h.svc.DeletePayment(c.Request.Context(), id)
        if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "deleted",
        })</span>
}

// ListPaymentLogs
// @Summary      获取支付操作日志
// @Tags         Admin/Payments
// @Security     BearerAuth
// @Produce      json
// @Param        id         path   int  true  "支付ID"
// @Param        page       query  int  false "页码"
// @Param        pageSize   query     int       false  "每页数量"
// @Param        action     query  string false "动作过滤" Enums(create,capture,update_status,refund,delete)
// @Param        actor_user_id query int false "操作者用户ID"
// @Param        dateFrom   query     string    false  "开始时�?
// @Param        dateTo     query     string    false  "结束时间"
// @Param        export     query  string false "导出格式" Enums(csv)
// @Param        fields     query  string false "导出列（逗号分隔），默认：id,entity_type,entity_id,actor_user_id,action,reason,metadata,created_at"
// @Param        header_lang query string false "列头语言" Enums(en,zh)
// @Success      200  {object}  map[string]any
// @Router       /admin/payments/{id}/logs [get]
func (h *PaymentHandler) ListPaymentLogs(c *gin.Context) <span class="cov0" title="0">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov0" title="0">page, pageSize, ok := parsePagination(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">var actorID *uint64
        if v, err := queryUint64Ptr(c, "actor_user_id"); err == nil </span><span class="cov0" title="0">{
                actorID = v
        }</span>
        <span class="cov0" title="0">var dateFrom, dateTo *time.Time
        if v, err := queryTimePtr(c, "date_from"); err == nil </span><span class="cov0" title="0">{
                dateFrom = v
        }</span> else<span class="cov0" title="0"> {
                writeJSONError(c, 400, apierr.ErrInvalidDateFrom)
                return
        }</span>
        <span class="cov0" title="0">if v, err := queryTimePtr(c, "date_to"); err == nil </span><span class="cov0" title="0">{
                dateTo = v
        }</span> else<span class="cov0" title="0"> {
                writeJSONError(c, 400, apierr.ErrInvalidDateTo)
                return
        }</span>
        <span class="cov0" title="0">opts := repository.OperationLogListOptions{Page: page, PageSize: pageSize, Action: strings.TrimSpace(c.Query("action")), ActorUserID: actorID, DateFrom: dateFrom, DateTo: dateTo}
        items, p, err := h.svc.ListOperationLogs(c.Request.Context(), "payment", id, opts)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov0" title="0">if strings.EqualFold(strings.TrimSpace(c.Query("export")), "csv") </span><span class="cov0" title="0">{
                exportOperationLogsCSV(c, "payment", id, items)
                return
        }</span>
        <span class="cov0" title="0">items = ensureSlice(items)
        writeJSON(c, http.StatusOK, model.APIResponse[[]model.OperationLog]{Success: true, Code: http.StatusOK, Message: "OK", Data: items, Pagination: p})</span>
}

// exportOperationLogsCSV writes operation logs as CSV attachment.
func exportOperationLogsCSV(c *gin.Context, entity string, entityID uint64, items []model.OperationLog) <span class="cov0" title="0">{
        // default columns
        allowed := []string{"id", "entity_type", "entity_id", "actor_user_id", "action", "reason", "metadata", "created_at"}
        // parse fields
        rawFields := strings.TrimSpace(c.Query("fields"))
        fields := allowed
        if rawFields != "" </span><span class="cov0" title="0">{
                req := parseCSVParams([]string{rawFields})
                // validate and keep order
                pick := make([]string, 0, len(req))
                for _, f := range req </span><span class="cov0" title="0">{
                        for _, a := range allowed </span><span class="cov0" title="0">{
                                if f == a </span><span class="cov0" title="0">{
                                        pick = append(pick, f)
                                        break</span>
                                }
                        }
                }
                <span class="cov0" title="0">if len(pick) &gt; 0 </span><span class="cov0" title="0">{
                        fields = pick
                }</span>
        }

        // header i18n
        <span class="cov0" title="0">lang := strings.ToLower(strings.TrimSpace(c.Query("header_lang")))
        headerMapEn := map[string]string{
                "id": "id", "entity_type": "entity_type", "entity_id": "entity_id", "actor_user_id": "actor_user_id",
                "action": "action", "reason": "reason", "metadata": "metadata", "created_at": "created_at",
        }
        headerMapZh := map[string]string{
                "id": "编号", "entity_type": "实体", "entity_id": "实体ID", "actor_user_id": "操作人ID",
                "action": "动作", "reason": "原因", "metadata": "元数据", "created_at": "创建时间",
        }
        var header []string
        for _, f := range fields </span><span class="cov0" title="0">{
                if lang == "zh" </span><span class="cov0" title="0">{
                        header = append(header, headerMapZh[f])
                }</span> else<span class="cov0" title="0"> {
                        header = append(header, headerMapEn[f])
                }</span>
        }

        <span class="cov0" title="0">filename := entity + "_" + strconv.FormatUint(entityID, 10) + "_logs.csv"
        c.Header("Content-Type", "text/csv; charset=utf-8")
        c.Header("Content-Disposition", "attachment; filename=\""+filename+"\"")
        // excel-friendly BOM when requested or zh header
        bom := strings.EqualFold(strings.TrimSpace(c.Query("bom")), "true") || lang == "zh"
        if bom </span><span class="cov0" title="0">{
                _, _ = c.Writer.Write([]byte{0xEF, 0xBB, 0xBF})
        }</span>
        <span class="cov0" title="0">w := csv.NewWriter(c.Writer)
        _ = w.Write(header)
        // timezone
        tz := strings.TrimSpace(c.Query("tz"))
        var loc *time.Location
        if tz != "" </span><span class="cov0" title="0">{
                if l, err := time.LoadLocation(tz); err == nil </span><span class="cov0" title="0">{
                        loc = l
                }</span>
        }
        <span class="cov0" title="0">for _, it := range items </span><span class="cov0" title="0">{
                row := make([]string, 0, len(fields))
                for _, f := range fields </span><span class="cov0" title="0">{
                        switch f </span>{
                        case "id":<span class="cov0" title="0">
                                row = append(row, strconv.FormatUint(it.ID, 10))</span>
                        case "entity_type":<span class="cov0" title="0">
                                row = append(row, it.EntityType)</span>
                        case "entity_id":<span class="cov0" title="0">
                                row = append(row, strconv.FormatUint(it.EntityID, 10))</span>
                        case "actor_user_id":<span class="cov0" title="0">
                                if it.ActorUserID != nil </span><span class="cov0" title="0">{
                                        row = append(row, strconv.FormatUint(*it.ActorUserID, 10))
                                }</span> else<span class="cov0" title="0"> {
                                        row = append(row, "")
                                }</span>
                        case "action":<span class="cov0" title="0">
                                row = append(row, it.Action)</span>
                        case "reason":<span class="cov0" title="0">
                                row = append(row, it.Reason)</span>
                        case "metadata":<span class="cov0" title="0">
                                row = append(row, string(it.MetadataJSON))</span>
                        case "created_at":<span class="cov0" title="0">
                                t := it.CreatedAt
                                if loc != nil </span><span class="cov0" title="0">{
                                        t = t.In(loc)
                                }</span>
                                <span class="cov0" title="0">row = append(row, t.Format(time.RFC3339))</span>
                        default:<span class="cov0" title="0">
                                row = append(row, "")</span>
                        }
                }
                <span class="cov0" title="0">_ = w.Write(row)</span>
        }
        <span class="cov0" title="0">w.Flush()</span>
}

// UpdatePaymentPayload defines the request body for updating a payment.
type UpdatePaymentPayload struct {
        Status          string          `json:"status" binding:"required"`
        ProviderTradeNo string          `json:"provider_trade_no"`
        ProviderRaw     json.RawMessage `json:"provider_raw,omitempty" swaggertype:"string" example:"{\"result\":\"update\"}"`
        PaidAt          *string         `json:"paid_at,omitempty" example:"2025-10-28T10:00:00Z"`
        RefundedAt      *string         `json:"refunded_at,omitempty" example:"2025-10-28T12:00:00Z"`
}

// CreatePaymentPayload defines create payment body.
type CreatePaymentPayload struct {
        OrderID     uint64          `json:"order_id" binding:"required"`
        UserID      uint64          `json:"user_id" binding:"required"`
        Method      string          `json:"method" binding:"required"`
        AmountCents int64           `json:"amount_cents" binding:"required"`
        Currency    string          `json:"currency" binding:"required"`
        ProviderRaw json.RawMessage `json:"provider_raw,omitempty" swaggertype:"string" example:"{\"result\":\"success\"}"`
}

// CapturePaymentPayload defines capture info.
type CapturePaymentPayload struct {
        ProviderTradeNo string          `json:"provider_trade_no"`
        ProviderRaw     json.RawMessage `json:"provider_raw,omitempty" swaggertype:"string" example:"{\"result\":\"captured\"}"`
        PaidAt          *string         `json:"paid_at" example:"2025-10-28T10:00:00Z"`
}

// RefundPayment
// @Summary      退款处�?// @Tags         Admin/Payments
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        id       path  int                    true  "支付ID"
// @Param        request  body  RefundPaymentPayload   false "退款信�?
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/payments/{id}/refund [post]
func (h *PaymentHandler) RefundPayment(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">var payload RefundPaymentPayload
        // optional body
        if c.Request.Body != nil </span><span class="cov8" title="1">{
                _ = c.ShouldBindJSON(&amp;payload)
        }</span>
        <span class="cov8" title="1">refundedAt, err := parseRFC3339Ptr(payload.RefundedAt)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidRefundedAt)
                return
        }</span>
        <span class="cov8" title="1">if refundedAt == nil </span><span class="cov0" title="0">{
                now := time.Now().UTC()
                refundedAt = &amp;now
        }</span>

        <span class="cov8" title="1">payment, err := h.svc.GetPayment(c.Request.Context(), id)
        if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        // Only allow refund from paid
        <span class="cov8" title="1">input := service.UpdatePaymentInput{
                Status:          model.PaymentStatusRefunded,
                ProviderTradeNo: payload.ProviderTradeNo,
                ProviderRaw:     payload.ProviderRaw,
                PaidAt:          payment.PaidAt,
                RefundedAt:      refundedAt,
        }
        updated, err := h.svc.UpdatePayment(c.Request.Context(), id, input)
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov8" title="1">if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[*model.Payment]{Success: true, Code: http.StatusOK, Message: "updated", Data: updated})</span>
}

// RefundPaymentPayload defines optional refund fields.
type RefundPaymentPayload struct {
        RefundedAt      *string         `json:"refunded_at,omitempty" example:"2025-10-28T12:00:00Z"`
        ProviderTradeNo string          `json:"provider_trade_no,omitempty"`
        ProviderRaw     json.RawMessage `json:"provider_raw,omitempty" swaggertype:"string" example:"{\"result\":\"refunded\"}"`
}

func parseRFC3339Ptr(value *string) (*time.Time, error) <span class="cov8" title="1">{
        if value == nil || strings.TrimSpace(*value) == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">parsed, err := time.Parse(time.RFC3339, strings.TrimSpace(*value))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;parsed, nil</span>
}

// ReviewOrder
// @Summary      审核订单（通过/拒绝�?// @Tags         Admin/Orders
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        id       path  int                    true  "订单ID"
// @Param        request  body  ReviewOrderPayload     true  "审核信息"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/orders/{id}/review [post]
func (h *OrderHandler) ReviewOrder(c *gin.Context) <span class="cov0" title="0">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov0" title="0">var payload ReviewOrderPayload
        if bindErr := c.ShouldBindJSON(&amp;payload); bindErr != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                return
        }</span>

        <span class="cov0" title="0">order, err := h.svc.GetOrder(c.Request.Context(), id)
        if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">next := model.OrderStatusConfirmed
        cancelReason := ""
        if !payload.Approved </span><span class="cov0" title="0">{
                next = model.OrderStatusCanceled
                cancelReason = strings.TrimSpace(payload.Reason)
        }</span>

        <span class="cov0" title="0">input := service.UpdateOrderInput{
                Status:          next,
                TotalPriceCents: order.TotalPriceCents,
                Currency:        order.Currency,
                ScheduledStart:  order.ScheduledStart,
                ScheduledEnd:    order.ScheduledEnd,
                CancelReason:    cancelReason,
        }
        updated, err := h.svc.UpdateOrder(c.Request.Context(), id, input)
        if errors.Is(err, service.ErrOrderInvalidTransition) </span><span class="cov0" title="0">{
                _ = c.Error(service.ErrOrderInvalidTransition)
                return
        }</span>
        <span class="cov0" title="0">if errors.Is(err, adminservice.ErrValidation) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov0" title="0">if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[*model.Order]{Success: true, Code: http.StatusOK, Message: "updated", Data: updated})</span>
}

// CancelOrder
// @Summary      取消订单
// @Tags         Admin/Orders
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        id       path  int                  true  "订单ID"
// @Param        request  body  CancelOrderPayload   true  "取消原因"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/orders/{id}/cancel [post]
func (h *OrderHandler) CancelOrder(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">var payload CancelOrderPayload
        if bindErr := c.ShouldBindJSON(&amp;payload); bindErr != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                return
        }</span>

        <span class="cov8" title="1">order, err := h.svc.GetOrder(c.Request.Context(), id)
        if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">input := service.UpdateOrderInput{
                Status:          model.OrderStatusCanceled,
                TotalPriceCents: order.TotalPriceCents,
                Currency:        order.Currency,
                ScheduledStart:  order.ScheduledStart,
                ScheduledEnd:    order.ScheduledEnd,
                CancelReason:    strings.TrimSpace(payload.Reason),
        }
        updated, err := h.svc.UpdateOrder(c.Request.Context(), id, input)
        if errors.Is(err, service.ErrOrderInvalidTransition) </span><span class="cov0" title="0">{
                _ = c.Error(service.ErrOrderInvalidTransition)
                return
        }</span>
        <span class="cov8" title="1">if errors.Is(err, adminservice.ErrValidation) </span><span class="cov8" title="1">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov0" title="0">if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[*model.Order]{Success: true, Code: http.StatusOK, Message: "updated", Data: updated})</span>
}

// ReviewOrderPayload defines approval decision.
type ReviewOrderPayload struct {
        Approved bool   `json:"approved"`
        Reason   string `json:"reason"`
}

// CancelOrderPayload defines cancel reason.
type CancelOrderPayload struct {
        Reason string `json:"reason"`
}

type orderNotePayload struct {
        Note string `json:"note"`
}

type orderRefundPayload struct {
        Reason      string `json:"reason" binding:"required"`
        AmountCents *int64 `json:"amount_cents,omitempty"`
        Note        string `json:"note"`
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package admin

import (
        "errors"
        "net/http"

        "github.com/gin-gonic/gin"

        "gamelink/internal/model"
        "gamelink/internal/repository"
        permissionservice "gamelink/internal/service/permission"
)

// PermissionHandler 权限管理处理器
type PermissionHandler struct {
        permissionSvc *permissionservice.PermissionService
}

// NewPermissionHandler 创建权限处理器实例
func NewPermissionHandler(permissionSvc *permissionservice.PermissionService) *PermissionHandler <span class="cov8" title="1">{
        return &amp;PermissionHandler{permissionSvc: permissionSvc}
}</span>

// ListPermissions 获取权限列表
func (h *PermissionHandler) ListPermissions(c *gin.Context) <span class="cov8" title="1">{
        // TODO: 实现keyword, method, group过滤功能
        _ = c.Query("keyword")
        _ = c.Query("method")
        _ = c.Query("group")

        page, pageSize, ok := parsePagination(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var permissions []model.Permission
        var total int64
        var err error

        // 直接调用ListPermissionsPaged
        permissions, total, err = h.permissionSvc.ListPermissionsPaged(c.Request.Context(), page, pageSize)

        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "成功",
                Data: gin.H{
                        "items":      ensureSlice(permissions),
                        "page":       page,
                        "pageSize":   pageSize,
                        "totalCount": total,
                },
        })</span>
}

// GetPermission 获取权限详情
func (h *PermissionHandler) GetPermission(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "无效的权限ID")
                return
        }</span>

        <span class="cov8" title="1">permission, err := h.permissionSvc.GetPermission(c.Request.Context(), id)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, repository.ErrNotFound) </span><span class="cov8" title="1">{
                        writeJSONError(c, http.StatusNotFound, "权限不存在")
                }</span> else<span class="cov0" title="0"> {
                        writeJSONError(c, http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[*model.Permission]{
                Success: true,
                Code:    http.StatusOK,
                Message: "成功",
                Data:    permission,
        })</span>
}

// CreatePermission 创建权限
func (h *PermissionHandler) CreatePermission(c *gin.Context) <span class="cov8" title="1">{
        var req struct {
                Method      model.HTTPMethod `json:"method" binding:"required"`
                Path        string           `json:"path" binding:"required,max=255"`
                Code        string           `json:"code" binding:"max=128"`
                Group       string           `json:"group" binding:"max=64"`
                Description string           `json:"description" binding:"max=255"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                writeJSONError(c, http.StatusBadRequest, "参数验证失败")
                return
        }</span>

        <span class="cov8" title="1">permission := &amp;model.Permission{
                Method:      req.Method,
                Path:        req.Path,
                Code:        req.Code,
                Group:       req.Group,
                Description: req.Description,
        }

        if err := h.permissionSvc.CreatePermission(c.Request.Context(), permission); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusCreated, model.APIResponse[*model.Permission]{
                Success: true,
                Code:    http.StatusCreated,
                Message: "权限创建成功",
                Data:    permission,
        })</span>
}

// UpdatePermission 更新权限
func (h *PermissionHandler) UpdatePermission(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "无效的权限ID")
                return
        }</span>

        <span class="cov8" title="1">var req struct {
                Code        string `json:"code" binding:"max=128"`
                Group       string `json:"group" binding:"max=64"`
                Description string `json:"description" binding:"max=255"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "参数验证失败")
                return
        }</span>

        <span class="cov8" title="1">permission := &amp;model.Permission{
                Base:        model.Base{ID: id},
                Code:        req.Code,
                Group:       req.Group,
                Description: req.Description,
        }

        if err := h.permissionSvc.UpdatePermission(c.Request.Context(), permission); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">updatedPermission, err := h.permissionSvc.GetPermission(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[*model.Permission]{
                Success: true,
                Code:    http.StatusOK,
                Message: "权限更新成功",
                Data:    updatedPermission,
        })</span>
}

// DeletePermission 删除权限
func (h *PermissionHandler) DeletePermission(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "无效的权限ID")
                return
        }</span>

        <span class="cov8" title="1">if err := h.permissionSvc.DeletePermission(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "权限删除成功",
                Data:    nil,
        })</span>
}

// GetRolePermissions 获取角色的权限列表
func (h *PermissionHandler) GetRolePermissions(c *gin.Context) <span class="cov8" title="1">{
        roleID, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov8" title="1">{
                writeJSONError(c, http.StatusBadRequest, "无效的角色ID")
                return
        }</span>

        <span class="cov0" title="0">permissions, err := h.permissionSvc.ListPermissionsByRoleID(c.Request.Context(), roleID)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[[]model.Permission]{
                Success: true,
                Code:    http.StatusOK,
                Message: "成功",
                Data:    ensureSlice(permissions),
        })</span>
}

// GetUserPermissions 获取用户的权限列表
func (h *PermissionHandler) GetUserPermissions(c *gin.Context) <span class="cov8" title="1">{
        userID, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov8" title="1">{
                writeJSONError(c, http.StatusBadRequest, "无效的用户ID")
                return
        }</span>

        <span class="cov0" title="0">permissions, err := h.permissionSvc.ListPermissionsByUserID(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[[]model.Permission]{
                Success: true,
                Code:    http.StatusOK,
                Message: "成功",
                Data:    ensureSlice(permissions),
        })</span>
}

// GetPermissionGroups 获取所有权限分组列表
func (h *PermissionHandler) GetPermissionGroups(c *gin.Context) <span class="cov8" title="1">{
        groups, err := h.permissionSvc.ListPermissionGroups(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[[]string]{
                Success: true,
                Code:    http.StatusOK,
                Message: "成功",
                Data:    ensureSlice(groups),
        })</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package admin

import (
        "errors"
        "net/http"
        "strings"
        "time"

        "github.com/gin-gonic/gin"

        apierr "gamelink/internal/handler"
        "gamelink/internal/model"
        "gamelink/internal/repository"
        adminservice "gamelink/internal/service/admin"
)

// PlayerHandler 处理陪玩资料管理接口�?
type PlayerHandler struct {
        svc *adminservice.AdminService
}

// NewPlayerHandler 创建Handler
func NewPlayerHandler(svc *adminservice.AdminService) *PlayerHandler <span class="cov8" title="1">{
        return &amp;PlayerHandler{svc: svc}
}</span>

// ListPlayers
// @Summary      列出玩家资料
// @Tags         Admin/Players
// @Security     BearerAuth
// @Param        page       query  int  false  "页码"
// @Param        pageSize   query     int       false  "每页数量"
// @Produce      json
// @Success      200  {object}  map[string]any
// @Router       /admin/players [get]
//
// ListPlayers returns a paginated list of players.
func (h *PlayerHandler) ListPlayers(c *gin.Context) <span class="cov8" title="1">{
        page, err := queryIntDefault(c, "page", 1)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidPage)
                return
        }</span>
        <span class="cov8" title="1">pageSize, err := queryIntDefault(c, "page_size", 20)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidPageSize)
                return
        }</span>

        <span class="cov8" title="1">players, pagination, err := h.svc.ListPlayersPaged(c.Request.Context(), page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov8" title="1">players = ensureSlice(players)
        writeJSON(c, http.StatusOK, model.APIResponse[[]model.Player]{
                Success:    true,
                Code:       http.StatusOK,
                Message:    "OK",
                Data:       players,
                Pagination: pagination,
        })</span>
}

// GetPlayer
// @Summary      获取玩家资料
// @Tags         Admin/Players
// @Security     BearerAuth
// @Param        id   path  int  true  "玩家ID"
// @Produce      json
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/players/{id} [get]
//
// GetPlayer returns a single player by id.
func (h *PlayerHandler) GetPlayer(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">player, err := h.svc.GetPlayer(c.Request.Context(), id)
        if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov8" title="1">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[*model.Player]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    player,
        })</span>
}

// CreatePlayer
// @Summary      新建玩家资料
// @Tags         Admin/Players
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        request  body  CreatePlayerPayload  true  "玩家信息"
// @Success      201  {object}  map[string]any
// @Failure      400  {object}  map[string]any
// @Router       /admin/players [post]
//
// CreatePlayer creates a new player profile.
func (h *PlayerHandler) CreatePlayer(c *gin.Context) <span class="cov8" title="1">{
        var payload CreatePlayerPayload
        if bindErr := c.ShouldBindJSON(&amp;payload); bindErr != nil </span><span class="cov8" title="1">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                return
        }</span>

        <span class="cov8" title="1">player, err := h.svc.CreatePlayer(c.Request.Context(), adminservice.CreatePlayerInput{
                UserID:             payload.UserID,
                Nickname:           payload.Nickname,
                Bio:                payload.Bio,
                Rank:               payload.Rank,
                HourlyRateCents:    payload.HourlyRateCents,
                MainGameID:         payload.MainGameID,
                VerificationStatus: model.VerificationStatus(payload.VerificationStatus),
        })
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusCreated, model.APIResponse[*model.Player]{
                Success: true,
                Code:    http.StatusCreated,
                Message: "created",
                Data:    player,
        })</span>
}

// UpdatePlayer
// @Summary      更新玩家资料
// @Tags         Admin/Players
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        id       path  int                   true  "玩家ID"
// @Param        request  body  UpdatePlayerPayload   true  "玩家信息"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/players/{id} [put]
//
// UpdatePlayer updates player profile.
func (h *PlayerHandler) UpdatePlayer(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>

        <span class="cov8" title="1">var payload UpdatePlayerPayload
        if bindErr := c.ShouldBindJSON(&amp;payload); bindErr != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                return
        }</span>

        <span class="cov8" title="1">player, err := h.svc.UpdatePlayer(c.Request.Context(), id, adminservice.UpdatePlayerInput{
                Nickname:           payload.Nickname,
                Bio:                payload.Bio,
                Rank:               payload.Rank,
                HourlyRateCents:    payload.HourlyRateCents,
                MainGameID:         payload.MainGameID,
                VerificationStatus: model.VerificationStatus(payload.VerificationStatus),
        })
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov8" title="1">if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov8" title="1">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[*model.Player]{
                Success: true,
                Code:    http.StatusOK,
                Message: "updated",
                Data:    player,
        })</span>
}

// DeletePlayer
// @Summary      删除玩家资料
// @Tags         Admin/Players
// @Security     BearerAuth
// @Param        id   path  int  true  "玩家ID"
// @Produce      json
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/players/{id} [delete]
//
// DeletePlayer deletes a player profile by id.
func (h *PlayerHandler) DeletePlayer(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">if err := h.svc.DeletePlayer(c.Request.Context(), id); errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "deleted",
        })</span>
}

// ListPlayerLogs
// @Summary      获取玩家操作日志
// @Tags         Admin/Players
// @Security     BearerAuth
// @Produce      json
// @Param        id           path   int  true  "玩家ID"
// @Param        page         query  int  false "页码"
// @Param        pageSize   query     int       false  "每页数量"
// @Param        action       query  string false "动作过滤" Enums(create,update,delete)
// @Param        actor_user_id query int   false "操作者用户ID"
// @Param        dateFrom   query     string    false  "开始时�?
// @Param        dateTo     query     string    false  "结束时间"
// @Param        export       query  string false "导出格式" Enums(csv)
// @Param        fields       query  string false "导出列（逗号分隔�?
// @Param        header_lang  query  string false "列头语言" Enums(en,zh)
// @Success      200  {object}  map[string]any
// @Router       /admin/players/{id}/logs [get]
func (h *PlayerHandler) ListPlayerLogs(c *gin.Context) <span class="cov0" title="0">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov0" title="0">page, pageSize, ok := parsePagination(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">var actorID *uint64
        if v, err := queryUint64Ptr(c, "actor_user_id"); err == nil </span><span class="cov0" title="0">{
                actorID = v
        }</span>
        <span class="cov0" title="0">var dateFrom, dateTo *time.Time
        if v, err := queryTimePtr(c, "date_from"); err == nil </span><span class="cov0" title="0">{
                dateFrom = v
        }</span> else<span class="cov0" title="0"> {
                writeJSONError(c, 400, apierr.ErrInvalidDateFrom)
                return
        }</span>
        <span class="cov0" title="0">if v, err := queryTimePtr(c, "date_to"); err == nil </span><span class="cov0" title="0">{
                dateTo = v
        }</span> else<span class="cov0" title="0"> {
                writeJSONError(c, 400, apierr.ErrInvalidDateTo)
                return
        }</span>
        <span class="cov0" title="0">opts := repository.OperationLogListOptions{Page: page, PageSize: pageSize, Action: strings.TrimSpace(c.Query("action")), ActorUserID: actorID, DateFrom: dateFrom, DateTo: dateTo}
        items, p, err := h.svc.ListOperationLogs(c.Request.Context(), "player", id, opts)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 500, err.Error())
                return
        }</span>
        <span class="cov0" title="0">if strings.EqualFold(strings.TrimSpace(c.Query("export")), "csv") </span><span class="cov0" title="0">{
                exportOperationLogsCSV(c, "player", id, items)
                return
        }</span>
        <span class="cov0" title="0">items = ensureSlice(items)
        writeJSON(c, 200, model.APIResponse[[]model.OperationLog]{Success: true, Code: 200, Message: "OK", Data: items, Pagination: p})</span>
}

// UpdatePlayerVerification
// @Summary      更新玩家认证状�?
// @Tags         Admin/Players
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        id       path  int  true  "玩家ID"
// @Param        request  body  map[string]string  true  "{verification_status}"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/players/{id}/verification [put]
func (h *PlayerHandler) UpdatePlayerVerification(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">var payload struct {
                VerificationStatus string `json:"verification_status" binding:"required"`
        }
        if bindErr := c.ShouldBindJSON(&amp;payload); bindErr != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                return
        }</span>

        <span class="cov8" title="1">player, err := h.svc.GetPlayer(c.Request.Context(), id)
        if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">out, err := h.svc.UpdatePlayer(c.Request.Context(), id, adminservice.UpdatePlayerInput{
                Nickname:           player.Nickname,
                Bio:                player.Bio,
                HourlyRateCents:    player.HourlyRateCents,
                MainGameID:         player.MainGameID,
                VerificationStatus: model.VerificationStatus(payload.VerificationStatus),
        })
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[*model.Player]{Success: true, Code: http.StatusOK, Message: "updated", Data: out})</span>
}

// UpdatePlayerGames
// @Summary      更新玩家主游�?
// @Tags         Admin/Players
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        id       path  int  true  "玩家ID"
// @Param        request  body  map[string]uint64  true  "{main_game_id}"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/players/{id}/games [put]
func (h *PlayerHandler) UpdatePlayerGames(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">var payload struct {
                MainGameID uint64 `json:"main_game_id" binding:"required"`
        }
        if bindErr := c.ShouldBindJSON(&amp;payload); bindErr != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                return
        }</span>

        <span class="cov8" title="1">player, err := h.svc.GetPlayer(c.Request.Context(), id)
        if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">out, err := h.svc.UpdatePlayer(c.Request.Context(), id, adminservice.UpdatePlayerInput{
                Nickname:           player.Nickname,
                Bio:                player.Bio,
                HourlyRateCents:    player.HourlyRateCents,
                MainGameID:         payload.MainGameID,
                VerificationStatus: player.VerificationStatus,
        })
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov8" title="1">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[*model.Player]{Success: true, Code: http.StatusOK, Message: "updated", Data: out})</span>
}

// UpdatePlayerSkillTags
// @Summary      更新玩家技能标�?
// @Tags         Admin/Players
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        id       path  int            true  "玩家ID"
// @Param        request  body  SkillTagsBody  true  "标签集合"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/players/{id}/skill-tags [put]
func (h *PlayerHandler) UpdatePlayerSkillTags(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">var body SkillTagsBody
        if bindErr := c.ShouldBindJSON(&amp;body); bindErr != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                return
        }</span>
        // Ensure player exists first
        <span class="cov8" title="1">if _, err := h.svc.GetPlayer(c.Request.Context(), id); errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov8" title="1">if err := h.svc.UpdatePlayerSkillTags(c.Request.Context(), id, body.Tags); err != nil </span><span class="cov8" title="1">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{Success: true, Code: http.StatusOK, Message: "updated"})</span>
}

type SkillTagsBody struct {
        Tags []string `json:"tags" binding:"required"`
}

// CreatePlayerPayload defines the request body for creating a player.
type CreatePlayerPayload struct {
        UserID             uint64 `json:"user_id" binding:"required"`
        Nickname           string `json:"nickname"`
        Bio                string `json:"bio"`
        Rank               string `json:"rank"`
        HourlyRateCents    int64  `json:"hourly_rate_cents"`
        MainGameID         uint64 `json:"main_game_id"`
        VerificationStatus string `json:"verification_status" binding:"required"`
}

// UpdatePlayerPayload defines the request body for updating a player.
type UpdatePlayerPayload struct {
        Nickname           string `json:"nickname"`
        Bio                string `json:"bio"`
        Rank               string `json:"rank"`
        HourlyRateCents    int64  `json:"hourly_rate_cents"`
        MainGameID         uint64 `json:"main_game_id"`
        VerificationStatus string `json:"verification_status" binding:"required"`
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package admin

import (
        "encoding/json"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"

        "gamelink/internal/model"
        rankingrepo "gamelink/internal/repository/ranking"
        commissionservice "gamelink/internal/service/commission"
)

// RegisterRankingCommissionRoutes 注册管理端排名抽成配置路由
func RegisterRankingCommissionRoutes(router gin.IRouter, repo rankingrepo.RankingCommissionRepository) <span class="cov0" title="0">{
        group := router.Group("/admin/ranking-commission")
        </span><span class="cov0" title="0">{
                group.POST("/configs", func(c *gin.Context) </span><span class="cov0" title="0">{ createRankingCommissionConfigHandler(c, repo) }</span>)
                <span class="cov0" title="0">group.GET("/configs", func(c *gin.Context) </span><span class="cov0" title="0">{ listRankingCommissionConfigsHandler(c, repo) }</span>)
                <span class="cov0" title="0">group.GET("/configs/:id", func(c *gin.Context) </span><span class="cov0" title="0">{ getRankingCommissionConfigHandler(c, repo) }</span>)
                <span class="cov0" title="0">group.PUT("/configs/:id", func(c *gin.Context) </span><span class="cov0" title="0">{ updateRankingCommissionConfigHandler(c, repo) }</span>)
                <span class="cov0" title="0">group.DELETE("/configs/:id", func(c *gin.Context) </span><span class="cov0" title="0">{ deleteRankingCommissionConfigHandler(c, repo) }</span>)
        }
}

// CreateRankingCommissionConfigRequest 创建排名抽成配置请求
type CreateRankingCommissionConfigRequest struct {
        Name        string                        `json:"name" binding:"required"`
        RankingType model.RankingType             `json:"rankingType" binding:"required,oneof=income order_count"`
        Month       string                        `json:"month" binding:"required"` // YYYY-MM
        Rules       []model.RankingCommissionRule `json:"rules" binding:"required,min=1"`
        Description string                        `json:"description"`
}

// createRankingCommissionConfigHandler 创建排名抽成配置
// @Summary      创建排名抽成配置
// @Description  管理员配置排名抽成规则（支持阶梯抽成�?
// @Tags         Admin - RankingCommission
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string                                   true  "Bearer {token}"
// @Param        request        body      CreateRankingCommissionConfigRequest  true  "配置信息"
// @Success      200            {object}  model.APIResponse[model.RankingCommissionConfig]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/ranking-commission/configs [post]
func createRankingCommissionConfigHandler(c *gin.Context, repo rankingrepo.RankingCommissionRepository) <span class="cov0" title="0">{
        var req CreateRankingCommissionConfigRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        // 验证规则
        <span class="cov0" title="0">if err := commissionservice.ValidateRankingRules(req.Rules); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "Invalid rules: "+err.Error())
                return
        }</span>

        // 序列化规�?
        <span class="cov0" title="0">rulesJSON, err := json.Marshal(req.Rules)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "Failed to serialize rules")
                return
        }</span>

        // 创建配置
        <span class="cov0" title="0">config := &amp;model.RankingCommissionConfig{
                Name:        req.Name,
                RankingType: req.RankingType,
                Period:      "monthly",
                Month:       req.Month,
                RulesJSON:   string(rulesJSON),
                Description: req.Description,
                IsActive:    true,
        }

        if err := repo.CreateConfig(c.Request.Context(), config); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[model.RankingCommissionConfig]{
                Success: true,
                Code:    http.StatusOK,
                Message: "Ranking commission config created successfully",
                Data:    *config,
        })</span>
}

// listRankingCommissionConfigsHandler 获取排名抽成配置列表
// @Summary      获取排名抽成配置列表
// @Description  管理员查看所有排名抽成配�?
// @Tags         Admin - RankingCommission
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        month          query     string  false  "月份筛�?
// @Param        rankingType    query     string  false  "排名类型"
// @Param        page           query     int     false  "页码"
// @Param        pageSize       query     int     false  "每页数量"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/ranking-commission/configs [get]
func listRankingCommissionConfigsHandler(c *gin.Context, repo rankingrepo.RankingCommissionRepository) <span class="cov0" title="0">{
        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        pageSize, _ := strconv.Atoi(c.DefaultQuery("pageSize", "20"))

        opts := rankingrepo.RankingCommissionConfigListOptions{
                Page:     page,
                PageSize: pageSize,
        }

        if month := c.Query("month"); month != "" </span><span class="cov0" title="0">{
                opts.Month = &amp;month
        }</span>

        <span class="cov0" title="0">if rankingTypeStr := c.Query("rankingType"); rankingTypeStr != "" </span><span class="cov0" title="0">{
                rankingType := model.RankingType(rankingTypeStr)
                opts.RankingType = &amp;rankingType
        }</span>

        <span class="cov0" title="0">configs, total, err := repo.ListConfigs(c.Request.Context(), opts)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        // 解析每个配置的规�?
        <span class="cov0" title="0">type ConfigDTO struct {
                model.RankingCommissionConfig
                Rules []model.RankingCommissionRule `json:"rules"`
        }

        configDTOs := make([]ConfigDTO, 0, len(configs))
        for _, config := range configs </span><span class="cov0" title="0">{
                var rules []model.RankingCommissionRule
                json.Unmarshal([]byte(config.RulesJSON), &amp;rules)

                configDTOs = append(configDTOs, ConfigDTO{
                        RankingCommissionConfig: config,
                        Rules:                   rules,
                })
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data: map[string]interface{}{
                        "configs": configDTOs,
                        "total":   total,
                },
        })</span>
}

// getRankingCommissionConfigHandler 获取排名抽成配置详情
// @Summary      获取排名抽成配置详情
// @Description  管理员查看排名抽成配置详�?
// @Tags         Admin - RankingCommission
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Param        id             path      int     true  "配置ID"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/ranking-commission/configs/{id} [get]
func getRankingCommissionConfigHandler(c *gin.Context, repo rankingrepo.RankingCommissionRepository) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "Invalid config ID")
                return
        }</span>

        <span class="cov0" title="0">config, err := repo.GetConfig(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusNotFound, "Config not found")
                return
        }</span>

        // 解析规则
        <span class="cov0" title="0">var rules []model.RankingCommissionRule
        json.Unmarshal([]byte(config.RulesJSON), &amp;rules)

        writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data: map[string]interface{}{
                        "config": config,
                        "rules":  rules,
                },
        })</span>
}

// UpdateRankingCommissionConfigRequest 更新配置请求
type UpdateRankingCommissionConfigRequest struct {
        Name        *string                        `json:"name"`
        Rules       *[]model.RankingCommissionRule `json:"rules"`
        Description *string                        `json:"description"`
        IsActive    *bool                          `json:"isActive"`
}

// updateRankingCommissionConfigHandler 更新排名抽成配置
// @Summary      更新排名抽成配置
// @Description  管理员更新排名抽成配�?
// @Tags         Admin - RankingCommission
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string                                   true  "Bearer {token}"
// @Param        id             path      int                                      true  "配置ID"
// @Param        request        body      UpdateRankingCommissionConfigRequest  true  "更新信息"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/ranking-commission/configs/{id} [put]
func updateRankingCommissionConfigHandler(c *gin.Context, repo rankingrepo.RankingCommissionRepository) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "Invalid config ID")
                return
        }</span>

        <span class="cov0" title="0">var req UpdateRankingCommissionConfigRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">config, err := repo.GetConfig(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusNotFound, "Config not found")
                return
        }</span>

        // 更新字段
        <span class="cov0" title="0">if req.Name != nil </span><span class="cov0" title="0">{
                config.Name = *req.Name
        }</span>
        <span class="cov0" title="0">if req.Description != nil </span><span class="cov0" title="0">{
                config.Description = *req.Description
        }</span>
        <span class="cov0" title="0">if req.IsActive != nil </span><span class="cov0" title="0">{
                config.IsActive = *req.IsActive
        }</span>
        <span class="cov0" title="0">if req.Rules != nil </span><span class="cov0" title="0">{
                // 验证规则
                if err := commissionservice.ValidateRankingRules(*req.Rules); err != nil </span><span class="cov0" title="0">{
                        writeJSONError(c, http.StatusBadRequest, "Invalid rules: "+err.Error())
                        return
                }</span>

                // 序列化规�?
                <span class="cov0" title="0">rulesJSON, err := json.Marshal(*req.Rules)
                if err != nil </span><span class="cov0" title="0">{
                        writeJSONError(c, http.StatusBadRequest, "Failed to serialize rules")
                        return
                }</span>
                <span class="cov0" title="0">config.RulesJSON = string(rulesJSON)</span>
        }

        <span class="cov0" title="0">if err := repo.UpdateConfig(c.Request.Context(), config); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "Config updated successfully",
        })</span>
}

// deleteRankingCommissionConfigHandler 删除排名抽成配置
// @Summary      删除排名抽成配置
// @Description  管理员删除排名抽成配�?
// @Tags         Admin - RankingCommission
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Param        id             path      int     true  "配置ID"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/ranking-commission/configs/{id} [delete]
func deleteRankingCommissionConfigHandler(c *gin.Context, repo rankingrepo.RankingCommissionRepository) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "Invalid config ID")
                return
        }</span>

        <span class="cov0" title="0">if err := repo.DeleteConfig(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "Config deleted successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package admin

import (
        "errors"
        "strings"
        "time"

        "github.com/gin-gonic/gin"

        apierr "gamelink/internal/handler"
        "gamelink/internal/model"
        "gamelink/internal/repository"
        adminservice "gamelink/internal/service/admin"
)

// ReviewHandler 管理评价接口�?
type ReviewHandler struct{ svc *adminservice.AdminService }

func NewReviewHandler(s *adminservice.AdminService) *ReviewHandler <span class="cov8" title="1">{ return &amp;ReviewHandler{svc: s} }</span>

// ListReviews
// @Summary      评价列表
// @Tags         Admin/Reviews
// @Security     BearerAuth
// @Produce      json
// @Param        page       query  int  false  "页码"
// @Param        pageSize   query     int       false  "每页数量"
// @Param        orderId     query     int       false  "订单ID"
// @Param        userId     query     int       false  "用户ID"
// @Param        playerId   query     int       false  "陪玩师ID"
// @Param        dateFrom   query     string    false  "开始时�?
// @Param        dateTo     query     string    false  "结束时间"
// @Success      200  {object}  map[string]any
// @Router       /admin/reviews [get]
func (h *ReviewHandler) ListReviews(c *gin.Context) <span class="cov8" title="1">{
        page, pageSize, ok := parsePagination(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">var orderID, userID, playerID *uint64
        if v, err := queryUint64Ptr(c, "order_id"); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidOrderID)
                return
        }</span> else<span class="cov8" title="1"> {
                orderID = v
        }</span>
        <span class="cov8" title="1">if v, err := queryUint64Ptr(c, "user_id"); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidUserID)
                return
        }</span> else<span class="cov8" title="1"> {
                userID = v
        }</span>
        <span class="cov8" title="1">if v, err := queryUint64Ptr(c, "player_id"); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidPlayerID)
                return
        }</span> else<span class="cov8" title="1"> {
                playerID = v
        }</span>
        <span class="cov8" title="1">dateFrom, err := queryTimePtr(c, "date_from")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidDateFrom)
                return
        }</span>
        <span class="cov8" title="1">dateTo, err := queryTimePtr(c, "date_to")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidDateTo)
                return
        }</span>
        <span class="cov8" title="1">items, p, err := h.svc.ListReviews(c.Request.Context(), repository.ReviewListOptions{Page: page, PageSize: pageSize, OrderID: orderID, UserID: userID, PlayerID: playerID, DateFrom: dateFrom, DateTo: dateTo})
        if err != nil </span><span class="cov8" title="1">{
                writeJSONError(c, 500, err.Error())
                return
        }</span>
        <span class="cov0" title="0">items = ensureSlice(items)
        writeJSON(c, 200, model.APIResponse[[]model.Review]{Success: true, Code: 200, Message: "OK", Data: items, Pagination: p})</span>
}

// GetReview
// @Summary      获取评价
// @Tags         Admin/Reviews
// @Security     BearerAuth
// @Produce      json
// @Param        id   path  int  true  "评价ID"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/reviews/{id} [get]
func (h *ReviewHandler) GetReview(c *gin.Context) <span class="cov0" title="0">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov0" title="0">item, err := h.svc.GetReview(c.Request.Context(), id)
        if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 500, err.Error())
                return
        }</span>
        <span class="cov0" title="0">writeJSON(c, 200, model.APIResponse[*model.Review]{Success: true, Code: 200, Message: "OK", Data: item})</span>
}

// CreateReview
// @Summary      创建评价
// @Tags         Admin/Reviews
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        request  body  CreateReviewPayload  true  "评价"
// @Success      201  {object}  map[string]any
// @Failure      400  {object}  map[string]any
// @Router       /admin/reviews [post]
func (h *ReviewHandler) CreateReview(c *gin.Context) <span class="cov8" title="1">{
        var p CreateReviewPayload
        if err := c.ShouldBindJSON(&amp;p); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidJSONPayload)
                return
        }</span>
        <span class="cov8" title="1">r := model.Review{OrderID: p.OrderID, UserID: p.UserID, PlayerID: p.PlayerID, Score: model.Rating(p.Score), Content: strings.TrimSpace(p.Content)}
        out, err := h.svc.CreateReview(c.Request.Context(), r)
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                writeJSONError(c, 500, err.Error())
                return
        }</span>
        <span class="cov0" title="0">writeJSON(c, 201, model.APIResponse[*model.Review]{Success: true, Code: 201, Message: "created", Data: out})</span>
}

// UpdateReview
// @Summary      更新评价
// @Tags         Admin/Reviews
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        id       path  int                    true  "评价ID"
// @Param        request  body  UpdateReviewPayload    true  "评价"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/reviews/{id} [put]
func (h *ReviewHandler) UpdateReview(c *gin.Context) <span class="cov0" title="0">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov0" title="0">var p UpdateReviewPayload
        if err := c.ShouldBindJSON(&amp;p); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidJSONPayload)
                return
        }</span>
        <span class="cov0" title="0">out, err := h.svc.UpdateReview(c.Request.Context(), id, model.Rating(p.Score), p.Content)
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov0" title="0">if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 500, err.Error())
                return
        }</span>
        <span class="cov0" title="0">writeJSON(c, 200, model.APIResponse[*model.Review]{Success: true, Code: 200, Message: "updated", Data: out})</span>
}

// DeleteReview
// @Summary      删除评价
// @Tags         Admin/Reviews
// @Security     BearerAuth
// @Produce      json
// @Param        id   path  int  true  "评价ID"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/reviews/{id} [delete]
func (h *ReviewHandler) DeleteReview(c *gin.Context) <span class="cov0" title="0">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov0" title="0">err = h.svc.DeleteReview(c.Request.Context(), id)
        if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 500, err.Error())
                return
        }</span>
        <span class="cov0" title="0">writeJSON(c, 200, model.APIResponse[any]{Success: true, Code: 200, Message: "deleted"})</span>
}

// ListReviewLogs
// @Summary      获取评价操作日志
// @Tags         Admin/Reviews
// @Security     BearerAuth
// @Produce      json
// @Param        id           path   int  true  "评价ID"
// @Param        page         query  int  false "页码"
// @Param        pageSize   query     int       false  "每页数量"
// @Param        action       query  string false "动作过滤" Enums(create,update,delete)
// @Param        actor_user_id query int   false "操作者用户ID"
// @Param        dateFrom   query     string    false  "开始时�?
// @Param        dateTo     query     string    false  "结束时间"
// @Param        export       query  string false "导出格式" Enums(csv)
// @Param        fields       query  string false "导出列（逗号分隔�?
// @Param        header_lang  query  string false "列头语言" Enums(en,zh)
// @Success      200  {object}  map[string]any
// @Router       /admin/reviews/{id}/logs [get]
func (h *ReviewHandler) ListReviewLogs(c *gin.Context) <span class="cov0" title="0">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov0" title="0">page, pageSize, ok := parsePagination(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">var actorID *uint64
        if v, err := queryUint64Ptr(c, "actor_user_id"); err == nil </span><span class="cov0" title="0">{
                actorID = v
        }</span>
        <span class="cov0" title="0">var dateFrom, dateTo *time.Time
        if v, err := queryTimePtr(c, "date_from"); err == nil </span><span class="cov0" title="0">{
                dateFrom = v
        }</span> else<span class="cov0" title="0"> {
                writeJSONError(c, 400, apierr.ErrInvalidDateFrom)
                return
        }</span>
        <span class="cov0" title="0">if v, err := queryTimePtr(c, "date_to"); err == nil </span><span class="cov0" title="0">{
                dateTo = v
        }</span> else<span class="cov0" title="0"> {
                writeJSONError(c, 400, apierr.ErrInvalidDateTo)
                return
        }</span>
        <span class="cov0" title="0">opts := repository.OperationLogListOptions{Page: page, PageSize: pageSize, Action: strings.TrimSpace(c.Query("action")), ActorUserID: actorID, DateFrom: dateFrom, DateTo: dateTo}
        items, p, err := h.svc.ListOperationLogs(c.Request.Context(), "review", id, opts)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 500, err.Error())
                return
        }</span>
        <span class="cov0" title="0">if strings.EqualFold(strings.TrimSpace(c.Query("export")), "csv") </span><span class="cov0" title="0">{
                exportOperationLogsCSV(c, "review", id, items)
                return
        }</span>
        <span class="cov0" title="0">items = ensureSlice(items)
        writeJSON(c, 200, model.APIResponse[[]model.OperationLog]{Success: true, Code: 200, Message: "OK", Data: items, Pagination: p})</span>
}

// ListPlayerReviews
// @Summary      获取陪玩师的评价
// @Tags         Admin/Players
// @Security     BearerAuth
// @Produce      json
// @Param        id         path   int  true  "陪玩师ID"
// @Param        page       query  int  false  "页码"
// @Param        pageSize   query     int       false  "每页数量"
// @Success      200  {object}  map[string]any
// @Router       /admin/players/{id}/reviews [get]
func (h *ReviewHandler) ListPlayerReviews(c *gin.Context) <span class="cov0" title="0">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov0" title="0">page, pageSize, ok := parsePagination(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">pid := id
        items, p, err := h.svc.ListReviews(c.Request.Context(), repository.ReviewListOptions{Page: page, PageSize: pageSize, PlayerID: &amp;pid})
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 500, err.Error())
                return
        }</span>
        <span class="cov0" title="0">items = ensureSlice(items)
        writeJSON(c, 200, model.APIResponse[[]model.Review]{Success: true, Code: 200, Message: "OK", Data: items, Pagination: p})</span>
}

type CreateReviewPayload struct {
        OrderID  uint64 `json:"order_id" binding:"required"`
        UserID   uint64 `json:"user_id" binding:"required"`
        PlayerID uint64 `json:"player_id" binding:"required"`
        Score    uint8  `json:"score" binding:"required"`
        Content  string `json:"content"`
}

type UpdateReviewPayload struct {
        Score   uint8  `json:"score" binding:"required"`
        Content string `json:"content"`
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package admin

import (
        "errors"
        "net/http"

        "github.com/gin-gonic/gin"

        "gamelink/internal/model"
        "gamelink/internal/repository"
        roleservice "gamelink/internal/service/role"
)

// RoleHandler 角色管理处理器
type RoleHandler struct {
        roleSvc *roleservice.RoleService
}

// NewRoleHandler 创建角色处理器实例
func NewRoleHandler(roleSvc *roleservice.RoleService) *RoleHandler <span class="cov8" title="1">{
        return &amp;RoleHandler{roleSvc: roleSvc}
}</span>

// ListRoles 获取角色列表
func (h *RoleHandler) ListRoles(c *gin.Context) <span class="cov8" title="1">{
        withPermissions := c.Query("with_permissions") == "true"
        keyword := c.Query("keyword")
        isSystemStr := c.Query("isSystem")

        page, pageSize, ok := parsePagination(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var roles []model.RoleModel
        var total int64
        var err error

        if withPermissions </span><span class="cov8" title="1">{
                roles, err = h.roleSvc.ListRolesWithPermissions(c.Request.Context())
                total = int64(len(roles))
        }</span> else<span class="cov8" title="1"> {
                // 解析 isSystem 参数
                var isSystem *bool
                if isSystemStr != "" </span><span class="cov0" title="0">{
                        val := isSystemStr == "true"
                        isSystem = &amp;val
                }</span>

                // 如果有过滤条件，使用过滤查询
                <span class="cov8" title="1">if keyword != "" || isSystem != nil </span><span class="cov0" title="0">{
                        roles, total, err = h.roleSvc.ListRolesPagedWithFilter(c.Request.Context(), page, pageSize, keyword, isSystem)
                }</span> else<span class="cov8" title="1"> {
                        roles, total, err = h.roleSvc.ListRolesPaged(c.Request.Context(), page, pageSize)
                }</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "成功",
                Data: gin.H{
                        "items":      ensureSlice(roles),
                        "page":       page,
                        "pageSize":   pageSize,
                        "totalCount": total,
                },
        })</span>
}

// GetRole 获取角色详情
func (h *RoleHandler) GetRole(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "无效的角色ID")
                return
        }</span>

        <span class="cov8" title="1">withPermissions := c.Query("with_permissions") == "true"

        var role *model.RoleModel
        if withPermissions </span><span class="cov0" title="0">{
                role, err = h.roleSvc.GetRoleWithPermissions(c.Request.Context(), id)
        }</span> else<span class="cov8" title="1"> {
                role, err = h.roleSvc.GetRole(c.Request.Context(), id)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, repository.ErrNotFound) </span><span class="cov8" title="1">{
                        writeJSONError(c, http.StatusNotFound, "角色不存在")
                }</span> else<span class="cov0" title="0"> {
                        writeJSONError(c, http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[*model.RoleModel]{
                Success: true,
                Code:    http.StatusOK,
                Message: "成功",
                Data:    role,
        })</span>
}

// CreateRole 创建角色
func (h *RoleHandler) CreateRole(c *gin.Context) <span class="cov8" title="1">{
        var req struct {
                Slug        string `json:"slug" binding:"required,max=64"`
                Name        string `json:"name" binding:"required,max=128"`
                Description string `json:"description" binding:"max=255"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                writeJSONError(c, http.StatusBadRequest, "参数验证失败")
                return
        }</span>

        <span class="cov8" title="1">role := &amp;model.RoleModel{
                Slug:        req.Slug,
                Name:        req.Name,
                Description: req.Description,
                IsSystem:    false,
        }

        if err := h.roleSvc.CreateRole(c.Request.Context(), role); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusCreated, model.APIResponse[*model.RoleModel]{
                Success: true,
                Code:    http.StatusCreated,
                Message: "角色创建成功",
                Data:    role,
        })</span>
}

// UpdateRole 更新角色
func (h *RoleHandler) UpdateRole(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "无效的角色ID")
                return
        }</span>

        <span class="cov8" title="1">var req struct {
                Name        string `json:"name" binding:"omitempty,max=128"`
                Description string `json:"description" binding:"max=255"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "参数验证失败")
                return
        }</span>

        <span class="cov8" title="1">role := &amp;model.RoleModel{
                Base:        model.Base{ID: id},
                Name:        req.Name,
                Description: req.Description,
        }

        if err := h.roleSvc.UpdateRole(c.Request.Context(), role); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">updatedRole, err := h.roleSvc.GetRole(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[*model.RoleModel]{
                Success: true,
                Code:    http.StatusOK,
                Message: "角色更新成功",
                Data:    updatedRole,
        })</span>
}

// DeleteRole 删除角色
func (h *RoleHandler) DeleteRole(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "无效的角色ID")
                return
        }</span>

        <span class="cov8" title="1">if err := h.roleSvc.DeleteRole(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "角色删除成功",
                Data:    nil,
        })</span>
}

// AssignPermissions 为角色分配权限
func (h *RoleHandler) AssignPermissions(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "无效的角色ID")
                return
        }</span>

        <span class="cov8" title="1">var req struct {
                PermissionIDs []uint64 `json:"permissionIds" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                writeJSONError(c, http.StatusBadRequest, "参数验证失败")
                return
        }</span>

        <span class="cov0" title="0">if err := h.roleSvc.AssignPermissionsToRole(c.Request.Context(), id, req.PermissionIDs); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "权限分配成功",
                Data:    nil,
        })</span>
}

// AssignRolesToUser 为用户分配角色
func (h *RoleHandler) AssignRolesToUser(c *gin.Context) <span class="cov8" title="1">{
        var req struct {
                UserID  uint64   `json:"userId" binding:"required"`
                RoleIDs []uint64 `json:"roleIds" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                writeJSONError(c, http.StatusBadRequest, "参数验证失败")
                return
        }</span>

        <span class="cov0" title="0">if err := h.roleSvc.AssignRolesToUser(c.Request.Context(), req.UserID, req.RoleIDs); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "角色分配成功",
                Data:    nil,
        })</span>
}

// GetUserRoles 获取用户的角色列表
func (h *RoleHandler) GetUserRoles(c *gin.Context) <span class="cov8" title="1">{
        userID, err := parseUintParam(c, "user_id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "无效的用户ID")
                return
        }</span>

        <span class="cov8" title="1">roles, err := h.roleSvc.ListRolesByUserID(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[[]model.RoleModel]{
                Success: true,
                Code:    http.StatusOK,
                Message: "成功",
                Data:    ensureSlice(roles),
        })</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package admin

import (
        "os"
        "strings"

        "github.com/gin-gonic/gin"

        "gamelink/internal/config"
        mw "gamelink/internal/handler/middleware"
        "gamelink/internal/model"
        adminservice "gamelink/internal/service/admin"
        statsservice "gamelink/internal/service/stats"
)

// RegisterRoutes 注册后台管理相关路由
// 使用细粒度权限控制（method+path 级别）
func RegisterRoutes(router gin.IRouter, svc *adminservice.AdminService, pm *mw.PermissionMiddleware) <span class="cov0" title="0">{
        gameHandler := NewGameHandler(svc)
        userHandler := NewUserHandler(svc)
        playerHandler := NewPlayerHandler(svc)
        orderHandler := NewOrderHandler(svc)
        paymentHandler := NewPaymentHandler(svc)
        reviewHandler := NewReviewHandler(svc)

        group := router.Group("/admin")
        // 所有管理接口均需要认�?+ 速率限制
        cfg := config.Load()
        if os.Getenv("APP_ENV") == "production" </span><span class="cov0" title="0">{
                group.Use(pm.RequireAuth(), mw.RateLimitAdmin())
        }</span> else<span class="cov0" title="0"> {
                // 使用配置中的 admin_auth.mode
                switch strings.ToLower(cfg.AdminAuth.Mode) </span>{
                case "jwt":<span class="cov0" title="0">
                        group.Use(pm.RequireAuth(), mw.RateLimitAdmin())</span>
                default:<span class="cov0" title="0">
                        // 开发模式：保留旧的 AdminAuth（Bearer Token�?
                        group.Use(mw.AdminAuth(), mw.RateLimitAdmin())</span>
                }
        }
        <span class="cov0" title="0">{
                // 游戏管理 - 使用细粒度权�?
                group.GET("/games", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/games"), gameHandler.ListGames)
                group.POST("/games", pm.RequirePermission(model.HTTPMethodPOST, "/api/v1/admin/games"), gameHandler.CreateGame)
                group.GET("/games/:id", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/games/:id"), gameHandler.GetGame)
                group.PUT("/games/:id", pm.RequirePermission(model.HTTPMethodPUT, "/api/v1/admin/games/:id"), gameHandler.UpdateGame)
                group.DELETE("/games/:id", pm.RequirePermission(model.HTTPMethodDELETE, "/api/v1/admin/games/:id"), gameHandler.DeleteGame)
                group.GET("/games/:id/logs", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/games/:id/logs"), gameHandler.ListGameLogs)

                // 用户管理 - 使用细粒度权�?
                group.GET("/users", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/users"), userHandler.ListUsers)
                group.POST("/users", pm.RequirePermission(model.HTTPMethodPOST, "/api/v1/admin/users"), userHandler.CreateUser)
                group.POST("/users/with-player", pm.RequirePermission(model.HTTPMethodPOST, "/api/v1/admin/users/with-player"), userHandler.CreateUserWithPlayer)
                group.GET("/users/:id", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/users/:id"), userHandler.GetUser)
                group.PUT("/users/:id", pm.RequirePermission(model.HTTPMethodPUT, "/api/v1/admin/users/:id"), userHandler.UpdateUser)
                group.DELETE("/users/:id", pm.RequirePermission(model.HTTPMethodDELETE, "/api/v1/admin/users/:id"), userHandler.DeleteUser)
                group.PUT("/users/:id/status", pm.RequirePermission(model.HTTPMethodPUT, "/api/v1/admin/users/:id/status"), userHandler.UpdateUserStatus)
                group.PUT("/users/:id/role", pm.RequirePermission(model.HTTPMethodPUT, "/api/v1/admin/users/:id/role"), userHandler.UpdateUserRole)
                group.GET("/users/:id/orders", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/users/:id/orders"), userHandler.ListUserOrders)
                group.GET("/users/:id/logs", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/users/:id/logs"), userHandler.ListUserLogs)

                // 陪玩师管�?- 使用细粒度权�?
                group.GET("/players", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/players"), playerHandler.ListPlayers)
                group.POST("/players", pm.RequirePermission(model.HTTPMethodPOST, "/api/v1/admin/players"), playerHandler.CreatePlayer)
                group.GET("/players/:id", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/players/:id"), playerHandler.GetPlayer)
                group.PUT("/players/:id", pm.RequirePermission(model.HTTPMethodPUT, "/api/v1/admin/players/:id"), playerHandler.UpdatePlayer)
                group.DELETE("/players/:id", pm.RequirePermission(model.HTTPMethodDELETE, "/api/v1/admin/players/:id"), playerHandler.DeletePlayer)
                group.PUT("/players/:id/verification", pm.RequirePermission(model.HTTPMethodPUT, "/api/v1/admin/players/:id/verification"), playerHandler.UpdatePlayerVerification)
                group.PUT("/players/:id/games", pm.RequirePermission(model.HTTPMethodPUT, "/api/v1/admin/players/:id/games"), playerHandler.UpdatePlayerGames)
                group.PUT("/players/:id/skill-tags", pm.RequirePermission(model.HTTPMethodPUT, "/api/v1/admin/players/:id/skill-tags"), playerHandler.UpdatePlayerSkillTags)
                group.GET("/players/:id/logs", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/players/:id/logs"), playerHandler.ListPlayerLogs)

                // 订单管理 - 使用细粒度权�?
                group.GET("/orders", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/orders"), orderHandler.ListOrders)
                group.POST("/orders", pm.RequirePermission(model.HTTPMethodPOST, "/api/v1/admin/orders"), orderHandler.CreateOrder)
                group.GET("/orders/:id", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/orders/:id"), orderHandler.GetOrder)
                group.PUT("/orders/:id", pm.RequirePermission(model.HTTPMethodPUT, "/api/v1/admin/orders/:id"), orderHandler.UpdateOrder)
                group.DELETE("/orders/:id", pm.RequirePermission(model.HTTPMethodDELETE, "/api/v1/admin/orders/:id"), orderHandler.DeleteOrder)
                group.POST("/orders/:id/review", pm.RequirePermission(model.HTTPMethodPOST, "/api/v1/admin/orders/:id/review"), orderHandler.ReviewOrder)
                group.POST("/orders/:id/cancel", pm.RequirePermission(model.HTTPMethodPOST, "/api/v1/admin/orders/:id/cancel"), orderHandler.CancelOrder)
                group.POST("/orders/:id/assign", pm.RequirePermission(model.HTTPMethodPOST, "/api/v1/admin/orders/:id/assign"), orderHandler.AssignOrder)
                group.POST("/orders/:id/confirm", pm.RequirePermission(model.HTTPMethodPOST, "/api/v1/admin/orders/:id/confirm"), orderHandler.ConfirmOrder)
                group.POST("/orders/:id/start", pm.RequirePermission(model.HTTPMethodPOST, "/api/v1/admin/orders/:id/start"), orderHandler.StartOrder)
                group.POST("/orders/:id/complete", pm.RequirePermission(model.HTTPMethodPOST, "/api/v1/admin/orders/:id/complete"), orderHandler.CompleteOrder)
                group.POST("/orders/:id/refund", pm.RequirePermission(model.HTTPMethodPOST, "/api/v1/admin/orders/:id/refund"), orderHandler.RefundOrder)
                group.GET("/orders/:id/logs", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/orders/:id/logs"), orderHandler.ListOrderLogs)
                group.GET("/orders/:id/timeline", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/orders/:id/timeline"), orderHandler.GetOrderTimeline)
                group.GET("/orders/:id/payments", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/orders/:id/payments"), orderHandler.ListOrderPayments)
                group.GET("/orders/:id/refunds", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/orders/:id/refunds"), orderHandler.ListOrderRefunds)
                group.GET("/orders/:id/reviews", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/orders/:id/reviews"), orderHandler.ListOrderReviews)

                // 支付管理 - 使用细粒度权�?
                group.GET("/payments", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/payments"), paymentHandler.ListPayments)
                group.POST("/payments", pm.RequirePermission(model.HTTPMethodPOST, "/api/v1/admin/payments"), paymentHandler.CreatePayment)
                group.GET("/payments/:id", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/payments/:id"), paymentHandler.GetPayment)
                group.PUT("/payments/:id", pm.RequirePermission(model.HTTPMethodPUT, "/api/v1/admin/payments/:id"), paymentHandler.UpdatePayment)
                group.DELETE("/payments/:id", pm.RequirePermission(model.HTTPMethodDELETE, "/api/v1/admin/payments/:id"), paymentHandler.DeletePayment)
                group.POST("/payments/:id/refund", pm.RequirePermission(model.HTTPMethodPOST, "/api/v1/admin/payments/:id/refund"), paymentHandler.RefundPayment)
                group.POST("/payments/:id/capture", pm.RequirePermission(model.HTTPMethodPOST, "/api/v1/admin/payments/:id/capture"), paymentHandler.CapturePayment)
                group.GET("/payments/:id/logs", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/payments/:id/logs"), paymentHandler.ListPaymentLogs)

                // 评价管理 - 使用细粒度权�?
                group.GET("/reviews", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/reviews"), reviewHandler.ListReviews)
                group.POST("/reviews", pm.RequirePermission(model.HTTPMethodPOST, "/api/v1/admin/reviews"), reviewHandler.CreateReview)
                group.GET("/reviews/:id", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/reviews/:id"), reviewHandler.GetReview)
                group.PUT("/reviews/:id", pm.RequirePermission(model.HTTPMethodPUT, "/api/v1/admin/reviews/:id"), reviewHandler.UpdateReview)
                group.DELETE("/reviews/:id", pm.RequirePermission(model.HTTPMethodDELETE, "/api/v1/admin/reviews/:id"), reviewHandler.DeleteReview)
                group.GET("/players/:id/reviews", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/players/:id/reviews"), reviewHandler.ListPlayerReviews)
                group.GET("/reviews/:id/logs", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/reviews/:id/logs"), reviewHandler.ListReviewLogs)
        }</span>
}

// RegisterStatsRoutes 注册统计相关路由�?
// 使用细粒度权限控制（method+path 级别）�?
func RegisterStatsRoutes(router gin.IRouter, stats *statsservice.StatsService, pm *mw.PermissionMiddleware) <span class="cov0" title="0">{
        h := NewStatsHandler(stats)
        group := router.Group("/admin")
        // 统计接口均需要认�?+ 速率限制
        cfg := config.Load()
        if os.Getenv("APP_ENV") == "production" </span><span class="cov0" title="0">{
                group.Use(pm.RequireAuth(), mw.RateLimitAdmin())
        }</span> else<span class="cov0" title="0"> {
                // 使用配置中的 admin_auth.mode
                switch strings.ToLower(cfg.AdminAuth.Mode) </span>{
                case "jwt":<span class="cov0" title="0">
                        group.Use(pm.RequireAuth(), mw.RateLimitAdmin())</span>
                default:<span class="cov0" title="0">
                        group.Use(mw.AdminAuth(), mw.RateLimitAdmin())</span>
                }
        }
        // 统计接口 - 使用细粒度权�?
        <span class="cov0" title="0">group.GET("/stats/dashboard", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/stats/dashboard"), h.Dashboard)
        group.GET("/stats/revenue-trend", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/stats/revenue-trend"), h.RevenueTrend)
        group.GET("/stats/user-growth", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/stats/user-growth"), h.UserGrowth)
        group.GET("/stats/orders", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/stats/orders"), h.OrdersSummary)
        group.GET("/stats/top-players", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/stats/top-players"), h.TopPlayers)
        group.GET("/stats/audit/overview", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/stats/audit/overview"), h.AuditOverview)
        group.GET("/stats/audit/trend", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/stats/audit/trend"), h.AuditTrend)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package admin

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"

        "gamelink/internal/model"
        "gamelink/internal/repository"
        commissionrepo "gamelink/internal/repository/commission"
        serviceitemrepo "gamelink/internal/repository/serviceitem"
)

// RegisterStatsAnalysisRoutes 注册管理端统计分析路由
func RegisterStatsAnalysisRoutes(
        router gin.IRouter,
        orderRepo repository.OrderRepository,
        commissionRepo commissionrepo.CommissionRepository,
        serviceItemRepo serviceitemrepo.ServiceItemRepository,
) <span class="cov0" title="0">{
        group := router.Group("/admin/stats")
        </span><span class="cov0" title="0">{
                group.GET("/service-items", func(c *gin.Context) </span><span class="cov0" title="0">{
                        getServiceItemStatsHandler(c, orderRepo, serviceItemRepo)
                }</span>)
                <span class="cov0" title="0">group.GET("/top-players", func(c *gin.Context) </span><span class="cov0" title="0">{
                        getTopPlayersHandler(c, commissionRepo)
                }</span>)
                <span class="cov0" title="0">group.GET("/gift-stats", func(c *gin.Context) </span><span class="cov0" title="0">{
                        getAdminGiftStatsHandler(c, orderRepo, serviceItemRepo)
                }</span>)
                <span class="cov0" title="0">group.GET("/revenue-by-game", func(c *gin.Context) </span><span class="cov0" title="0">{
                        getRevenueByGameHandler(c, orderRepo)
                }</span>)
        }
}

// getServiceItemStatsHandler 服务项目统计
// @Summary      服务项目统计
// @Description  统计各服务项目的销售情况
// @Tags         Admin - Stats
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/stats/service-items [get]
func getServiceItemStatsHandler(
        c *gin.Context,
        orderRepo repository.OrderRepository,
        serviceItemRepo serviceitemrepo.ServiceItemRepository,
) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        // 获取所有服务项
        items, _, err := serviceItemRepo.List(ctx, serviceitemrepo.ServiceItemListOptions{
                Page:     1,
                PageSize: 1000,
        })
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        // 统计每个服务项目的订单数和收益
        <span class="cov0" title="0">type ItemStats struct {
                ItemID       uint64 `json:"itemId"`
                ItemCode     string `json:"itemCode"`
                ItemName     string `json:"itemName"`
                SubCategory  string `json:"subCategory"`
                OrderCount   int64  `json:"orderCount"`
                TotalRevenue int64  `json:"totalRevenue"`
        }

        stats := make([]ItemStats, 0, len(items))
        for _, item := range items </span><span class="cov0" title="0">{
                // 查询该服务项目的所有订单
                orders, _, _ := orderRepo.List(ctx, repository.OrderListOptions{
                        // TODO: 需要添加 ItemID 过滤
                        Statuses: []model.OrderStatus{model.OrderStatusCompleted},
                        Page:     1,
                        PageSize: 10000,
                })

                var orderCount int64
                var totalRevenue int64
                for _, order := range orders </span><span class="cov0" title="0">{
                        if order.ItemID == item.ID </span><span class="cov0" title="0">{
                                orderCount++
                                totalRevenue += order.TotalPriceCents
                        }</span>
                }

                <span class="cov0" title="0">stats = append(stats, ItemStats{
                        ItemID:       item.ID,
                        ItemCode:     item.ItemCode,
                        ItemName:     item.Name,
                        SubCategory:  string(item.SubCategory),
                        OrderCount:   orderCount,
                        TotalRevenue: totalRevenue,
                })</span>
        }

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data: map[string]interface{}{
                        "items": stats,
                },
        })</span>
}

// getTopPlayersHandler 获取Top陪玩�?// @Summary      获取Top陪玩�?// @Description  按收入排名获取Top陪玩�?// @Tags         Admin - Stats
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        month          query     string  false  "月份(YYYY-MM)"
// @Param        limit          query     int     false  "数量"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/stats/top-players [get]
func getTopPlayersHandler(c *gin.Context, commissionRepo commissionrepo.CommissionRepository) <span class="cov0" title="0">{
        month := c.DefaultQuery("month", time.Now().Format("2006-01"))
        limit := 10

        // TODO: 实现Top陪玩师查询
        // 暂时返回空数据
        _ = month

        writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data: map[string]interface{}{
                        "players": []interface{}{},
                        "month":   month,
                        "limit":   limit,
                },
        })
}</span>

// getAdminGiftStatsHandler 获取礼物统计
// @Summary      获取礼物统计
// @Description  统计礼物的销售情�?// @Tags         Admin - Stats
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/stats/gift-stats [get]
func getAdminGiftStatsHandler(
        c *gin.Context,
        orderRepo repository.OrderRepository,
        serviceItemRepo serviceitemrepo.ServiceItemRepository,
) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        // 获取所有礼物
        gifts, _, err := serviceItemRepo.GetGifts(ctx, 1, 1000)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">type GiftStat struct {
                GiftID       uint64 `json:"giftId"`
                GiftName     string `json:"giftName"`
                TotalSent    int64  `json:"totalSent"`
                TotalRevenue int64  `json:"totalRevenue"`
        }

        giftStats := make([]GiftStat, 0, len(gifts))
        for _, gift := range gifts </span><span class="cov0" title="0">{
                // 统计该礼物的销量
                orders, _, _ := orderRepo.List(ctx, repository.OrderListOptions{
                        Statuses: []model.OrderStatus{model.OrderStatusCompleted},
                        Page:     1,
                        PageSize: 10000,
                })

                var totalSent int64
                var totalRevenue int64
                for _, order := range orders </span><span class="cov0" title="0">{
                        if order.ItemID == gift.ID &amp;&amp; order.IsGiftOrder() </span><span class="cov0" title="0">{
                                totalSent += int64(order.Quantity)
                                totalRevenue += order.TotalPriceCents
                        }</span>
                }

                <span class="cov0" title="0">giftStats = append(giftStats, GiftStat{
                        GiftID:       gift.ID,
                        GiftName:     gift.Name,
                        TotalSent:    totalSent,
                        TotalRevenue: totalRevenue,
                })</span>
        }

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data: map[string]interface{}{
                        "gifts": giftStats,
                },
        })</span>
}

// getRevenueByGameHandler 按游戏统计收�?// @Summary      按游戏统计收�?// @Description  统计各游戏的订单和收入情�?// @Tags         Admin - Stats
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/stats/revenue-by-game [get]
func getRevenueByGameHandler(c *gin.Context, orderRepo repository.OrderRepository) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        // 获取所有已完成订单
        orders, _, err := orderRepo.List(ctx, repository.OrderListOptions{
                Statuses: []model.OrderStatus{model.OrderStatusCompleted},
                Page:     1,
                PageSize: 10000,
        })
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        // 按游戏ID分组统计
        <span class="cov0" title="0">gameStats := make(map[uint64]struct {
                OrderCount int64
                Revenue    int64
        })

        for _, order := range orders </span><span class="cov0" title="0">{
                gameID := order.GetGameID()
                if gameID &gt; 0 </span><span class="cov0" title="0">{
                        stats := gameStats[gameID]
                        stats.OrderCount++
                        stats.Revenue += order.TotalPriceCents
                        gameStats[gameID] = stats
                }</span>
        }

        // 转换为数组
        <span class="cov0" title="0">type GameRevenue struct {
                GameID       uint64 `json:"gameId"`
                OrderCount   int64  `json:"orderCount"`
                TotalRevenue int64  `json:"totalRevenue"`
        }

        result := make([]GameRevenue, 0, len(gameStats))
        for gameID, stats := range gameStats </span><span class="cov0" title="0">{
                result = append(result, GameRevenue{
                        GameID:       gameID,
                        OrderCount:   stats.OrderCount,
                        TotalRevenue: stats.Revenue,
                })
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data: map[string]interface{}{
                        "games": result,
                },
        })</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package admin

import (
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"

        "gamelink/internal/model"
        "gamelink/internal/service/stats"
)

// StatsHandler 统计数据Handler
type StatsHandler struct {
        svc *stats.StatsService
}

// NewStatsHandler 创建统计Handler
func NewStatsHandler(svc *stats.StatsService) *StatsHandler <span class="cov0" title="0">{
        return &amp;StatsHandler{svc: svc}
}</span>

// Dashboard 获取仪表板数据
// @Summary      仪表板数据
// @Description  获取平台统计数据总览
// @Tags         Admin - Stats
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Failure      500            {object}  model.APIResponse[any]
// @Router       /admin/stats/dashboard [get]
func (h *StatsHandler) Dashboard(c *gin.Context) <span class="cov0" title="0">{
        dashboard, err := h.svc.Dashboard(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    dashboard,
        })</span>
}

// RevenueTrend 获取收入趋势
// @Summary      收入趋势
// @Description  获取指定天数的收入趋势
// @Tags         Admin - Stats
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        days           query     int     false  "天数" default(7)
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Failure      500            {object}  model.APIResponse[any]
// @Router       /admin/stats/revenue-trend [get]
func (h *StatsHandler) RevenueTrend(c *gin.Context) <span class="cov0" title="0">{
        days := 7
        if daysStr := c.Query("days"); daysStr != "" </span><span class="cov0" title="0">{
                if val, err := strconv.Atoi(daysStr); err == nil &amp;&amp; val &gt; 0 </span><span class="cov0" title="0">{
                        days = val
                }</span>
        }

        <span class="cov0" title="0">trend, err := h.svc.RevenueTrend(c.Request.Context(), days)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    trend,
        })</span>
}

// UserGrowth 获取用户增长趋势
// @Summary      用户增长趋势
// @Description  获取指定天数的用户增长趋势
// @Tags         Admin - Stats
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        days           query     int     false  "天数" default(7)
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Failure      500            {object}  model.APIResponse[any]
// @Router       /admin/stats/user-growth [get]
func (h *StatsHandler) UserGrowth(c *gin.Context) <span class="cov0" title="0">{
        days := 7
        if daysStr := c.Query("days"); daysStr != "" </span><span class="cov0" title="0">{
                if val, err := strconv.Atoi(daysStr); err == nil &amp;&amp; val &gt; 0 </span><span class="cov0" title="0">{
                        days = val
                }</span>
        }

        <span class="cov0" title="0">trend, err := h.svc.UserGrowth(c.Request.Context(), days)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    trend,
        })</span>
}

// OrdersSummary 获取订单状态汇总
// @Summary      订单状态汇总
// @Description  获取各状态订单数量统计
// @Tags         Admin - Stats
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Failure      500            {object}  model.APIResponse[any]
// @Router       /admin/stats/orders [get]
func (h *StatsHandler) OrdersSummary(c *gin.Context) <span class="cov0" title="0">{
        stats, err := h.svc.OrdersByStatus(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    stats,
        })</span>
}

// TopPlayers 获取顶级陪玩师
// @Summary      顶级陪玩师
// @Description  获取收入最高的陪玩师列表
// @Tags         Admin - Stats
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        limit          query     int     false  "数量限制" default(10)
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Failure      500            {object}  model.APIResponse[any]
// @Router       /admin/stats/top-players [get]
func (h *StatsHandler) TopPlayers(c *gin.Context) <span class="cov0" title="0">{
        limit := 10
        if limitStr := c.Query("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if val, err := strconv.Atoi(limitStr); err == nil &amp;&amp; val &gt; 0 </span><span class="cov0" title="0">{
                        limit = val
                }</span>
        }

        <span class="cov0" title="0">players, err := h.svc.TopPlayers(c.Request.Context(), limit)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    players,
        })</span>
}

// AuditOverview 获取审计概览
// @Summary      审计概览
// @Description  获取审计日志统计概览
// @Tags         Admin - Stats
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        from           query     string  false  "开始日期"
// @Param        to             query     string  false  "结束日期"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Failure      500            {object}  model.APIResponse[any]
// @Router       /admin/stats/audit/overview [get]
func (h *StatsHandler) AuditOverview(c *gin.Context) <span class="cov0" title="0">{
        var from, to *time.Time

        if fromStr := c.Query("from"); fromStr != "" </span><span class="cov0" title="0">{
                if t, err := time.Parse(time.RFC3339, fromStr); err == nil </span><span class="cov0" title="0">{
                        from = &amp;t
                }</span>
        }

        <span class="cov0" title="0">if toStr := c.Query("to"); toStr != "" </span><span class="cov0" title="0">{
                if t, err := time.Parse(time.RFC3339, toStr); err == nil </span><span class="cov0" title="0">{
                        to = &amp;t
                }</span>
        }

        <span class="cov0" title="0">entityStats, actionStats, err := h.svc.AuditOverview(c.Request.Context(), from, to)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data: gin.H{
                        "entityStats": entityStats,
                        "actionStats": actionStats,
                },
        })</span>
}

// AuditTrend 获取审计趋势
// @Summary      审计趋势
// @Description  获取审计日志时间趋势
// @Tags         Admin - Stats
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        from           query     string  false  "开始日期"
// @Param        to             query     string  false  "结束日期"
// @Param        entity         query     string  false  "实体类型"
// @Param        action         query     string  false  "操作类型"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Failure      500            {object}  model.APIResponse[any]
// @Router       /admin/stats/audit/trend [get]
func (h *StatsHandler) AuditTrend(c *gin.Context) <span class="cov0" title="0">{
        var from, to *time.Time

        if fromStr := c.Query("from"); fromStr != "" </span><span class="cov0" title="0">{
                if t, err := time.Parse(time.RFC3339, fromStr); err == nil </span><span class="cov0" title="0">{
                        from = &amp;t
                }</span>
        }

        <span class="cov0" title="0">if toStr := c.Query("to"); toStr != "" </span><span class="cov0" title="0">{
                if t, err := time.Parse(time.RFC3339, toStr); err == nil </span><span class="cov0" title="0">{
                        to = &amp;t
                }</span>
        }

        <span class="cov0" title="0">entity := c.Query("entity")
        action := c.Query("action")

        trend, err := h.svc.AuditTrend(c.Request.Context(), from, to, entity, action)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    trend,
        })</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package admin

import (
    "database/sql"
    "os"
    "strings"

    "github.com/gin-gonic/gin"

    "gamelink/internal/cache"
    "gamelink/internal/config"
    mw "gamelink/internal/handler/middleware"
    "gamelink/internal/model"
)

// RegisterSystemRoutes 注册系统信息相关路由（管理端）
// 使用细粒度权限控制（method+path 级别）
func RegisterSystemRoutes(router gin.IRouter, cfg config.AppConfig, sqlDB *sql.DB, cacheClient cache.Cache, pm *mw.PermissionMiddleware) <span class="cov0" title="0">{
    h := NewSystemInfoHandler(cfg, sqlDB, cacheClient)

    group := router.Group("/admin")
    // 系统信息接口均需要认证 + 速率限制
    if os.Getenv("APP_ENV") == "production" </span><span class="cov0" title="0">{
        group.Use(pm.RequireAuth(), mw.RateLimitAdmin())
    }</span> else<span class="cov0" title="0"> {
        // 使用配置中的 admin_auth.mode
        switch strings.ToLower(cfg.AdminAuth.Mode) </span>{
        case "jwt":<span class="cov0" title="0">
            group.Use(pm.RequireAuth(), mw.RateLimitAdmin())</span>
        default:<span class="cov0" title="0">
            group.Use(mw.AdminAuth(), mw.RateLimitAdmin())</span>
        }
    }

    // 系统信息接口 - 使用细粒度权限
    <span class="cov0" title="0">group.GET("/system/config", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/system/config"), h.Config)
    group.GET("/system/db", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/system/db"), h.DBStatus)
    group.GET("/system/cache", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/system/cache"), h.CacheStatus)
    group.GET("/system/resources", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/system/resources"), h.Resources)
    group.GET("/system/version", pm.RequirePermission(model.HTTPMethodGET, "/api/v1/admin/system/version"), h.Version)</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package admin

import (
        "database/sql"
        "net/http"
        "runtime"

        "github.com/gin-gonic/gin"

        "gamelink/internal/cache"
        "gamelink/internal/config"
        "gamelink/internal/model"
)

// SystemInfoHandler 系统信息Handler
type SystemInfoHandler struct {
        cfg         config.AppConfig
        sqlDB       *sql.DB
        cacheClient cache.Cache
}

// NewSystemInfoHandler 创建系统信息Handler
func NewSystemInfoHandler(cfg config.AppConfig, sqlDB *sql.DB, cacheClient cache.Cache) *SystemInfoHandler <span class="cov0" title="0">{
        return &amp;SystemInfoHandler{
                cfg:         cfg,
                sqlDB:       sqlDB,
                cacheClient: cacheClient,
        }
}</span>

// Config 获取系统配置
// @Summary      系统配置
// @Description  获取系统配置信息
// @Tags         Admin - System
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/system/config [get]
func (h *SystemInfoHandler) Config(c *gin.Context) <span class="cov0" title="0">{
        configInfo := gin.H{
                "databaseType":  h.cfg.Database.Type,
                "cacheType":     h.cfg.Cache.Type,
                "adminAuthMode": h.cfg.AdminAuth.Mode,
        }

        writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    configInfo,
        })
}</span>

// DBStatus 获取数据库状态
// @Summary      数据库状态
// @Description  获取数据库连接状态
// @Tags         Admin - System
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Failure      500            {object}  model.APIResponse[any]
// @Router       /admin/system/db [get]
func (h *SystemInfoHandler) DBStatus(c *gin.Context) <span class="cov0" title="0">{
        stats := h.sqlDB.Stats()

        dbStatus := gin.H{
                "openConnections": stats.OpenConnections,
                "inUse":           stats.InUse,
                "idle":            stats.Idle,
                "maxOpenConns":    stats.MaxOpenConnections,
        }

        writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    dbStatus,
        })
}</span>

// CacheStatus 获取缓存状态
// @Summary      缓存状态
// @Description  获取缓存连接状态
// @Tags         Admin - System
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Failure      500            {object}  model.APIResponse[any]
// @Router       /admin/system/cache [get]
func (h *SystemInfoHandler) CacheStatus(c *gin.Context) <span class="cov0" title="0">{
        // 简单测试缓存连接
        testKey := "system:health:check"
        _, _, err := h.cacheClient.Get(c.Request.Context(), testKey)

        cacheStatus := gin.H{
                "connected": err == nil,
                "type":      h.cfg.Cache.Type,
        }

        writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    cacheStatus,
        })
}</span>

// Resources 获取系统资源信息
// @Summary      系统资源
// @Description  获取系统资源使用情况
// @Tags         Admin - System
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/system/resources [get]
func (h *SystemInfoHandler) Resources(c *gin.Context) <span class="cov0" title="0">{
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)

        resources := gin.H{
                "goroutines":   runtime.NumGoroutine(),
                "allocMB":      m.Alloc / 1024 / 1024,
                "totalAllocMB": m.TotalAlloc / 1024 / 1024,
                "sysMB":        m.Sys / 1024 / 1024,
                "numGC":        m.NumGC,
                "cpuCores":     runtime.NumCPU(),
        }

        writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    resources,
        })
}</span>

// Version 获取系统版本
// @Summary      系统版本
// @Description  获取系统版本信息
// @Tags         Admin - System
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/system/version [get]
func (h *SystemInfoHandler) Version(c *gin.Context) <span class="cov0" title="0">{
        version := gin.H{
                "version":   "1.0.0",
                "goVersion": runtime.Version(),
                "buildTime": "2024-11-06",
        }

        writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    version,
        })
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package admin

import (
        "errors"
        "net/http"
        "net/mail"
        "regexp"
        "strings"
        "time"

        "github.com/gin-gonic/gin"

        apierr "gamelink/internal/handler"
        "gamelink/internal/model"
        "gamelink/internal/repository"
        adminservice "gamelink/internal/service/admin"
)

// UserHandler 处理后台用户管理接口�?
type UserHandler struct {
        svc *adminservice.AdminService
}

// NewUserHandler 创建Handler
func NewUserHandler(svc *adminservice.AdminService) *UserHandler <span class="cov8" title="1">{
        return &amp;UserHandler{svc: svc}
}</span>

// ListUsers
// @Summary      列出用户
// @Description  分页列出用户，支持按角色/状�?时间范围/关键字筛�?
// @Tags         Admin/Users
// @Security     BearerAuth
// @Param        page       query     int       false  "页码"
// @Param        pageSize   query     int       false  "每页数量"
// @Param        role       query     []string  false  "角色过滤，可多�?
// @Param        status     query     []string  false  "状态过滤，可多�?
// @Param        dateFrom   query     string    false  "开始时�?
// @Param        dateTo     query     string    false  "结束时间"
// @Param        keyword    query     string    false  "关键字（匹配 name/email/phone�?
// @Produce      json
// @Success      200  {object}  map[string]any
// @Router       /admin/users [get]
//
// ListUsers returns a paginated list of users.
func (h *UserHandler) ListUsers(c *gin.Context) <span class="cov8" title="1">{
        opts, ok := buildUserListOptions(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">users, pagination, err := h.svc.ListUsersWithOptions(c.Request.Context(), opts)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov8" title="1">users = ensureSlice(users)
        writeJSON(c, http.StatusOK, model.APIResponse[[]model.User]{
                Success:    true,
                Code:       http.StatusOK,
                Message:    "OK",
                Data:       users,
                Pagination: pagination,
        })</span>
}

// GetUser
// @Summary      获取用户
// @Tags         Admin/Users
// @Security     BearerAuth
// @Param        id   path      int  true  "用户ID"
// @Produce      json
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/users/{id} [get]
//
// GetUser returns a single user by id.
func (h *UserHandler) GetUser(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">user, err := h.svc.GetUser(c.Request.Context(), id)
        if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[*model.User]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    user,
        })</span>
}

// CreateUser
// @Summary      创建用户
// @Tags         Admin/Users
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        request  body  CreateUserPayload  true  "用户信息"
// @Success      201  {object}  map[string]any
// @Failure      400  {object}  map[string]any
// @Router       /admin/users [post]
//
// CreateUser creates a new user.
func (h *UserHandler) CreateUser(c *gin.Context) <span class="cov8" title="1">{
        var payload CreateUserPayload
        if bindErr := c.ShouldBindJSON(&amp;payload); bindErr != nil </span><span class="cov8" title="1">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                return
        }</span>

        <span class="cov8" title="1">if payload.Email != "" &amp;&amp; !isValidEmail(payload.Email) </span><span class="cov8" title="1">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidEmailFormat)
                return
        }</span>
        <span class="cov8" title="1">if payload.Phone != "" &amp;&amp; !isValidPhone(payload.Phone) </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidPhoneFormat)
                return
        }</span>

        <span class="cov8" title="1">user, err := h.svc.CreateUser(c.Request.Context(), adminservice.CreateUserInput{
                Phone:     payload.Phone,
                Email:     payload.Email,
                Password:  payload.Password,
                Name:      payload.Name,
                AvatarURL: payload.AvatarURL,
                Role:      model.Role(payload.Role),
                Status:    model.UserStatus(payload.Status),
        })
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusCreated, model.APIResponse[*model.User]{
                Success: true,
                Code:    http.StatusCreated,
                Message: "created",
                Data:    user,
        })</span>
}

// UpdateUser
// @Summary      更新用户
// @Tags         Admin/Users
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        id       path  int                  true  "用户ID"
// @Param        request  body  UpdateUserPayload    true  "用户信息"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/users/{id} [put]
//
// UpdateUser updates user profile and optional password.
func (h *UserHandler) UpdateUser(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>

        <span class="cov8" title="1">var payload UpdateUserPayload
        if bindErr := c.ShouldBindJSON(&amp;payload); bindErr != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                return
        }</span>

        <span class="cov8" title="1">if payload.Email != "" &amp;&amp; !isValidEmail(payload.Email) </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidEmailFormat)
                return
        }</span>
        <span class="cov8" title="1">if payload.Phone != "" &amp;&amp; !isValidPhone(payload.Phone) </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidPhoneFormat)
                return
        }</span>

        <span class="cov8" title="1">var passwordPtr *string
        if payload.Password != nil </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(*payload.Password)
                if trimmed != "" </span><span class="cov0" title="0">{
                        passwordCopy := trimmed
                        passwordPtr = &amp;passwordCopy
                }</span>
        }

        <span class="cov8" title="1">user, err := h.svc.UpdateUser(c.Request.Context(), id, adminservice.UpdateUserInput{
                Phone:     payload.Phone,
                Email:     payload.Email,
                Name:      payload.Name,
                AvatarURL: payload.AvatarURL,
                Role:      model.Role(payload.Role),
                Status:    model.UserStatus(payload.Status),
                Password:  passwordPtr,
        })
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov8" title="1">if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[*model.User]{
                Success: true,
                Code:    http.StatusOK,
                Message: "updated",
                Data:    user,
        })</span>
}

// DeleteUser
// @Summary      删除用户
// @Tags         Admin/Users
// @Security     BearerAuth
// @Param        id   path  int  true  "用户ID"
// @Produce      json
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/users/{id} [delete]
//
// DeleteUser deletes a user by id.
func (h *UserHandler) DeleteUser(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">err = h.svc.DeleteUser(c.Request.Context(), id)
        if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "deleted",
        })</span>
}

// ListUserLogs
// @Summary      获取用户操作日志
// @Tags         Admin/Users
// @Security     BearerAuth
// @Produce      json
// @Param        id           path   int  true  "用户ID"
// @Param        page         query  int  false "页码"
// @Param        pageSize   query     int       false  "每页数量"
// @Param        action       query  string false "动作过滤" Enums(create,update,delete)
// @Param        actor_user_id query int   false "操作者用户ID"
// @Param        dateFrom   query     string    false  "开始时�?
// @Param        dateTo     query     string    false  "结束时间"
// @Param        export       query  string false "导出格式" Enums(csv)
// @Param        fields       query  string false "导出列（逗号分隔�?
// @Param        header_lang  query  string false "列头语言" Enums(en,zh)
// @Success      200  {object}  map[string]any
// @Router       /admin/users/{id}/logs [get]
func (h *UserHandler) ListUserLogs(c *gin.Context) <span class="cov0" title="0">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 400, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov0" title="0">page, pageSize, ok := parsePagination(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">var actorID *uint64
        if v, err := queryUint64Ptr(c, "actor_user_id"); err == nil </span><span class="cov0" title="0">{
                actorID = v
        }</span>
        <span class="cov0" title="0">var dateFrom, dateTo *time.Time
        if v, err := queryTimePtr(c, "date_from"); err == nil </span><span class="cov0" title="0">{
                dateFrom = v
        }</span> else<span class="cov0" title="0"> {
                writeJSONError(c, 400, apierr.ErrInvalidDateFrom)
                return
        }</span>
        <span class="cov0" title="0">if v, err := queryTimePtr(c, "date_to"); err == nil </span><span class="cov0" title="0">{
                dateTo = v
        }</span> else<span class="cov0" title="0"> {
                writeJSONError(c, 400, apierr.ErrInvalidDateTo)
                return
        }</span>
        <span class="cov0" title="0">opts := repository.OperationLogListOptions{Page: page, PageSize: pageSize, Action: strings.TrimSpace(c.Query("action")), ActorUserID: actorID, DateFrom: dateFrom, DateTo: dateTo}
        items, p, err := h.svc.ListOperationLogs(c.Request.Context(), "user", id, opts)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, 500, err.Error())
                return
        }</span>
        <span class="cov0" title="0">if strings.EqualFold(strings.TrimSpace(c.Query("export")), "csv") </span><span class="cov0" title="0">{
                exportOperationLogsCSV(c, "user", id, items)
                return
        }</span>
        <span class="cov0" title="0">items = ensureSlice(items)
        writeJSON(c, 200, model.APIResponse[[]model.OperationLog]{Success: true, Code: 200, Message: "OK", Data: items, Pagination: p})</span>
}

// UpdateUserStatus
// @Summary      更新用户状�?
// @Tags         Admin/Users
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        id       path  int  true  "用户ID"
// @Param        request  body  map[string]string  true  "{status}"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/users/{id}/status [put]
func (h *UserHandler) UpdateUserStatus(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">var payload struct {
                Status string `json:"status" binding:"required"`
        }
        if bindErr := c.ShouldBindJSON(&amp;payload); bindErr != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                return
        }</span>
        <span class="cov8" title="1">out, err := h.svc.UpdateUserStatus(c.Request.Context(), id, model.UserStatus(payload.Status))
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov8" title="1">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov0" title="0">if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov0" title="0">if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[*model.User]{Success: true, Code: http.StatusOK, Message: "updated", Data: out})</span>
}

// UpdateUserRole
// @Summary      更新用户角色
// @Tags         Admin/Users
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        id       path  int  true  "用户ID"
// @Param        request  body  map[string]string  true  "{role}"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/users/{id}/role [put]
func (h *UserHandler) UpdateUserRole(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        <span class="cov8" title="1">var payload struct {
                Role string `json:"role" binding:"required"`
        }
        if bindErr := c.ShouldBindJSON(&amp;payload); bindErr != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                return
        }</span>
        <span class="cov8" title="1">out, err := h.svc.UpdateUserRole(c.Request.Context(), id, model.Role(payload.Role))
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov8" title="1">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov0" title="0">if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov0" title="0">if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[*model.User]{Success: true, Code: http.StatusOK, Message: "updated", Data: out})</span>
}

// ListUserOrders
// @Summary      获取用户的订�?
// @Tags         Admin/Users
// @Security     BearerAuth
// @Produce      json
// @Param        id         path   int      true   "用户ID"
// @Param        page       query  int      false  "页码"
// @Param        pageSize   query     int       false  "每页数量"
// @Param        status     query  []string false  "订单状�?
// @Param        dateFrom   query     string    false  "开始时�?
// @Param        dateTo     query     string    false  "结束时间"
// @Success      200  {object}  map[string]any
// @Failure      404  {object}  map[string]any
// @Router       /admin/users/{id}/orders [get]
func (h *UserHandler) ListUserOrders(c *gin.Context) <span class="cov8" title="1">{
        id, err := parseUintParam(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>
        // Ensure user exists
        <span class="cov8" title="1">_, err = h.svc.GetUser(c.Request.Context(), id)
        if errors.Is(err, adminservice.ErrNotFound) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        // Build options from query, then enforce user scope
        <span class="cov8" title="1">opts, ok := buildOrderListOptions(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        // Force user scope
        <span class="cov8" title="1">uid := id
        opts.UserID = &amp;uid
        orders, pagination, err := h.svc.ListOrders(c.Request.Context(), opts)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov8" title="1">orders = ensureSlice(orders)
        writeJSON(c, http.StatusOK, model.APIResponse[[]model.Order]{Success: true, Code: http.StatusOK, Message: "OK", Data: orders, Pagination: pagination})</span>
}

// CreateUserPayload defines the request body for creating a user.
type CreateUserPayload struct {
        Phone     string `json:"phone"`
        Email     string `json:"email"`
        Password  string `json:"password" binding:"required,min=6"`
        Name      string `json:"name" binding:"required"`
        AvatarURL string `json:"avatar_url"`
        Role      string `json:"role" binding:"required"`
        Status    string `json:"status" binding:"required"`
}

// UpdateUserPayload defines the request body for updating a user.
type UpdateUserPayload struct {
        Phone     string  `json:"phone"`
        Email     string  `json:"email"`
        Name      string  `json:"name" binding:"required"`
        AvatarURL string  `json:"avatar_url"`
        Role      string  `json:"role" binding:"required"`
        Status    string  `json:"status" binding:"required"`
        Password  *string `json:"password"`
}

// CreateUserWithPlayerPayload defines a combined create payload.
type CreateUserWithPlayerPayload struct {
        Phone     string `json:"phone"`
        Email     string `json:"email"`
        Password  string `json:"password" binding:"required,min=6"`
        Name      string `json:"name" binding:"required"`
        AvatarURL string `json:"avatar_url"`
        Role      string `json:"role" binding:"required"`
        Status    string `json:"status" binding:"required"`

        Player struct {
                Nickname           string `json:"nickname"`
                Bio                string `json:"bio"`
                HourlyRateCents    int64  `json:"hourly_rate_cents"`
                MainGameID         uint64 `json:"main_game_id"`
                VerificationStatus string `json:"verification_status" binding:"required"`
        } `json:"player" binding:"required"`
}

// CreateUserWithPlayer creates a user and a player profile transactionally.
func (h *UserHandler) CreateUserWithPlayer(c *gin.Context) <span class="cov8" title="1">{
        var payload CreateUserWithPlayerPayload
        if bindErr := c.ShouldBindJSON(&amp;payload); bindErr != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidJSONPayload)
                return
        }</span>
        <span class="cov8" title="1">if payload.Email != "" &amp;&amp; !isValidEmail(payload.Email) </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidEmailFormat)
                return
        }</span>
        <span class="cov8" title="1">if payload.Phone != "" &amp;&amp; !isValidPhone(payload.Phone) </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, apierr.ErrInvalidPhoneFormat)
                return
        }</span>

        <span class="cov8" title="1">user, player, err := h.svc.RegisterUserAndPlayer(c.Request.Context(),
                adminservice.CreateUserInput{
                        Phone:     payload.Phone,
                        Email:     payload.Email,
                        Password:  payload.Password,
                        Name:      payload.Name,
                        AvatarURL: payload.AvatarURL,
                        Role:      model.Role(payload.Role),
                        Status:    model.UserStatus(payload.Status),
                },
                adminservice.CreatePlayerInput{
                        Nickname:           payload.Player.Nickname,
                        Bio:                payload.Player.Bio,
                        HourlyRateCents:    payload.Player.HourlyRateCents,
                        MainGameID:         payload.Player.MainGameID,
                        VerificationStatus: model.VerificationStatus(payload.Player.VerificationStatus),
                },
        )
        if errors.Is(err, adminservice.ErrValidation) </span><span class="cov0" title="0">{
                _ = c.Error(adminservice.ErrValidation)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov0" title="0">writeJSON(c, http.StatusCreated, model.APIResponse[map[string]any]{
                Success: true,
                Code:    http.StatusCreated,
                Message: "created",
                Data:    map[string]any{"user": user, "player": player},
        })</span>
}

var phoneRegexp = regexp.MustCompile(`^1[3-9]\d{9}$`)

func isValidPhone(p string) bool <span class="cov8" title="1">{
        p = strings.TrimSpace(p)
        return phoneRegexp.MatchString(p)
}</span>

func isValidEmail(e string) bool <span class="cov8" title="1">{
        e = strings.TrimSpace(e)
        if e == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if _, err := mail.ParseAddress(e); err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package admin

import (
        "context"
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"

        "gamelink/internal/model"
        withdrawrepo "gamelink/internal/repository/withdraw"
)

// WithdrawAdminService 提现管理服务接口
type WithdrawAdminService interface {
        GetWithdraws(ctx context.Context, opts withdrawrepo.WithdrawListOptions) ([]model.Withdraw, int64, error)
        GetWithdraw(ctx context.Context, id uint64) (*model.Withdraw, error)
        ApproveWithdraw(ctx context.Context, id uint64, adminID uint64, remark string) error
        RejectWithdraw(ctx context.Context, id uint64, adminID uint64, reason string) error
        CompleteWithdraw(ctx context.Context, id uint64, adminID uint64) error
}

// RegisterWithdrawRoutes 注册管理端提现管理路由
func RegisterWithdrawRoutes(router gin.IRouter, withdrawRepo withdrawrepo.WithdrawRepository) <span class="cov0" title="0">{
        group := router.Group("/admin/withdraws")
        </span><span class="cov0" title="0">{
                group.GET("", func(c *gin.Context) </span><span class="cov0" title="0">{ listWithdrawsHandler(c, withdrawRepo) }</span>)
                <span class="cov0" title="0">group.GET("/:id", func(c *gin.Context) </span><span class="cov0" title="0">{ getWithdrawHandler(c, withdrawRepo) }</span>)
                <span class="cov0" title="0">group.POST("/:id/approve", func(c *gin.Context) </span><span class="cov0" title="0">{ approveWithdrawHandler(c, withdrawRepo) }</span>)
                <span class="cov0" title="0">group.POST("/:id/reject", func(c *gin.Context) </span><span class="cov0" title="0">{ rejectWithdrawHandler(c, withdrawRepo) }</span>)
                <span class="cov0" title="0">group.POST("/:id/complete", func(c *gin.Context) </span><span class="cov0" title="0">{ completeWithdrawHandler(c, withdrawRepo) }</span>)
        }
}

// listWithdrawsHandler 获取提现申请列表
// @Summary      获取提现申请列表
// @Description  管理员查看所有提现申请
// @Tags         Admin - Withdraw
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        status         query     string  false  "状态筛�?
// @Param        playerId       query     int     false  "陪玩师ID"
// @Param        page           query     int     false  "页码"
// @Param        pageSize       query     int     false  "每页数量"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/withdraws [get]
func listWithdrawsHandler(c *gin.Context, repo withdrawrepo.WithdrawRepository) <span class="cov0" title="0">{
        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        pageSize, _ := strconv.Atoi(c.DefaultQuery("pageSize", "20"))

        opts := withdrawrepo.WithdrawListOptions{
                Page:     page,
                PageSize: pageSize,
        }

        // 状态筛选
        if status := c.Query("status"); status != "" </span><span class="cov0" title="0">{
                s := model.WithdrawStatus(status)
                opts.Status = &amp;s
        }</span>

        // 陪玩师筛选
        <span class="cov0" title="0">if playerIDStr := c.Query("playerId"); playerIDStr != "" </span><span class="cov0" title="0">{
                if playerID, err := strconv.ParseUint(playerIDStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                        opts.PlayerID = &amp;playerID
                }</span>
        }

        <span class="cov0" title="0">withdraws, total, err := repo.List(c.Request.Context(), opts)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data: map[string]interface{}{
                        "withdraws": withdraws,
                        "total":     total,
                },
        })</span>
}

// getWithdrawHandler 获取提现详情
// @Summary      获取提现详情
// @Description  管理员查看提现详�?// @Tags         Admin - Withdraw
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Param        id             path      int     true  "提现ID"
// @Success      200            {object}  model.APIResponse[model.Withdraw]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/withdraws/{id} [get]
func getWithdrawHandler(c *gin.Context, repo withdrawrepo.WithdrawRepository) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "Invalid withdraw ID")
                return
        }</span>

        <span class="cov0" title="0">withdraw, err := repo.Get(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusNotFound, "Withdraw not found")
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[model.Withdraw]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *withdraw,
        })</span>
}

// ApproveWithdrawRequest 批准提现请求
type ApproveWithdrawRequest struct {
        Remark string `json:"remark"`
}

// approveWithdrawHandler 批准提现
// @Summary      批准提现
// @Description  管理员批准提现申�?// @Tags         Admin - Withdraw
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string                   true  "Bearer {token}"
// @Param        id             path      int                      true  "提现ID"
// @Param        request        body      ApproveWithdrawRequest  false  "审核备注"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/withdraws/{id}/approve [post]
func approveWithdrawHandler(c *gin.Context, repo withdrawrepo.WithdrawRepository) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "Invalid withdraw ID")
                return
        }</span>

        <span class="cov0" title="0">adminID, _ := c.Get("user_id")
        adminUserID := adminID.(uint64)

        var req ApproveWithdrawRequest
        c.ShouldBindJSON(&amp;req)

        withdraw, err := repo.Get(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusNotFound, "Withdraw not found")
                return
        }</span>

        // 只能审批待处理的提现
        <span class="cov0" title="0">if withdraw.Status != model.WithdrawStatusPending </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "Can only approve pending withdraws")
                return
        }</span>

        // 更新状态
        <span class="cov0" title="0">now := time.Now()
        withdraw.Status = model.WithdrawStatusApproved
        withdraw.ProcessedBy = &amp;adminUserID
        withdraw.ProcessedAt = &amp;now
        withdraw.AdminRemark = req.Remark

        if err := repo.Update(c.Request.Context(), withdraw); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "Withdraw approved successfully",
        })</span>
}

// RejectWithdrawRequest 拒绝提现请求
type RejectWithdrawRequest struct {
        Reason string `json:"reason" binding:"required"`
}

// rejectWithdrawHandler 拒绝提现
// @Summary      拒绝提现
// @Description  管理员拒绝提现申�?// @Tags         Admin - Withdraw
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string                  true  "Bearer {token}"
// @Param        id             path      int                     true  "提现ID"
// @Param        request        body      RejectWithdrawRequest  true  "拒绝原因"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/withdraws/{id}/reject [post]
func rejectWithdrawHandler(c *gin.Context, repo withdrawrepo.WithdrawRepository) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "Invalid withdraw ID")
                return
        }</span>

        <span class="cov0" title="0">adminID, _ := c.Get("user_id")
        adminUserID := adminID.(uint64)

        var req RejectWithdrawRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">withdraw, err := repo.Get(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusNotFound, "Withdraw not found")
                return
        }</span>

        // 只能审批待处理的提现
        <span class="cov0" title="0">if withdraw.Status != model.WithdrawStatusPending </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "Can only reject pending withdraws")
                return
        }</span>

        // 更新状态
        <span class="cov0" title="0">now := time.Now()
        withdraw.Status = model.WithdrawStatusRejected
        withdraw.ProcessedBy = &amp;adminUserID
        withdraw.ProcessedAt = &amp;now
        withdraw.RejectReason = req.Reason

        if err := repo.Update(c.Request.Context(), withdraw); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "Withdraw rejected",
        })</span>
}

// completeWithdrawHandler 完成提现（已打款�?// @Summary      完成提现
// @Description  管理员标记提现已完成（已打款�?// @Tags         Admin - Withdraw
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Param        id             path      int     true  "提现ID"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /admin/withdraws/{id}/complete [post]
func completeWithdrawHandler(c *gin.Context, repo withdrawrepo.WithdrawRepository) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "Invalid withdraw ID")
                return
        }</span>

        <span class="cov0" title="0">adminID, _ := c.Get("user_id")
        adminUserID := adminID.(uint64)

        withdraw, err := repo.Get(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusNotFound, "Withdraw not found")
                return
        }</span>

        // 只能完成已批准的提现
        <span class="cov0" title="0">if withdraw.Status != model.WithdrawStatusApproved </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusBadRequest, "Can only complete approved withdraws")
                return
        }</span>

        // 更新状态
        <span class="cov0" title="0">now := time.Now()
        withdraw.Status = model.WithdrawStatusCompleted
        withdraw.CompletedAt = &amp;now
        if withdraw.ProcessedBy == nil </span><span class="cov0" title="0">{
                withdraw.ProcessedBy = &amp;adminUserID
        }</span>

        <span class="cov0" title="0">if err := repo.Update(c.Request.Context(), withdraw); err != nil </span><span class="cov0" title="0">{
                writeJSONError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "Withdraw completed successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package handler

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"

        "gamelink/internal/auth"
        "gamelink/internal/model"
        "gamelink/internal/service"
        authservice "gamelink/internal/service/auth"
)

// RegisterAuthRoutes registers authentication endpoints under the given router group.
// Routes:
// POST /auth/login    -&gt; body {username, password}
// POST /auth/refresh  -&gt; Authorization: Bearer &lt;token&gt;
// POST /auth/logout   -&gt; stateless logout, client discards token
// GET  /auth/me       -&gt; return current user info (JWT required)
func RegisterAuthRoutes(router gin.IRouter, svc *authservice.AuthService) <span class="cov8" title="1">{
        auth := router.Group("/auth")
        auth.POST("/login", func(c *gin.Context) </span><span class="cov8" title="1">{ loginHandler(c, svc) }</span>)
        <span class="cov8" title="1">auth.POST("/register", func(c *gin.Context) </span><span class="cov8" title="1">{ registerHandler(c, svc) }</span>)
        <span class="cov8" title="1">auth.POST("/refresh", func(c *gin.Context) </span><span class="cov8" title="1">{ refreshHandler(c, svc) }</span>)
        <span class="cov8" title="1">auth.POST("/logout", logoutHandler)

        auth.GET("/me", func(c *gin.Context) </span><span class="cov8" title="1">{ meHandler(c, svc) }</span>)
}

type loginRequest struct {
        Username string `json:"username" binding:"required"`
        Password string `json:"password" binding:"required"`
}

type loginResponse struct {
        Token     string     `json:"token"`
        ExpiresAt time.Time  `json:"expires_at"`
        User      model.User `json:"user"`
}

type tokenPayload struct {
        Token string `json:"token"`
}

type registerRequest struct {
        Phone    string `json:"phone"`
        Email    string `json:"email"`
        Password string `json:"password" binding:"required,min=6"`
        Name     string `json:"name" binding:"required"`
}

// Login
// @Summary      登录
// @Description  用户名（邮箱或手机号）+ 密码登录，返回 JWT
// @Tags         Auth
// @Accept       json
// @Produce      json
// @Param        request  body      loginRequest  true  "登录凭据"
// @Success      200      {object}  loginResponse
// @Failure      400      {object}  map[string]any
// @Failure      401      {object}  map[string]any
// @Router       /auth/login [post]
func loginHandler(c *gin.Context, svc *authservice.AuthService) <span class="cov8" title="1">{
        var req loginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                respondError(c, http.StatusBadRequest, ErrInvalidJSONPayload)
                return
        }</span>
        <span class="cov8" title="1">resp, err := svc.Login(c.Request.Context(), authservice.LoginRequest{Username: req.Username, Password: req.Password})
        if err != nil </span><span class="cov8" title="1">{
                status := http.StatusUnauthorized
                switch err </span>{
                case service.ErrInvalidCredentials:<span class="cov8" title="1">
                        status = http.StatusUnauthorized</span>
                case service.ErrUserDisabled:<span class="cov0" title="0">
                        status = http.StatusForbidden</span>
                default:<span class="cov0" title="0">
                        status = http.StatusUnauthorized</span>
                }
                <span class="cov8" title="1">respondJSON(c, status, model.APIResponse[any]{Success: false, Code: status, Message: err.Error()})
                return</span>
        }
        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[loginResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    loginResponse{Token: resp.Token, ExpiresAt: resp.ExpiresAt, User: resp.User},
        })</span>
}

// Register
// @Summary      注册
// @Description  邮箱或手机号 + 密码注册，默认角色为 user
// @Tags         Auth
// @Accept       json
// @Produce      json
// @Param        request  body      registerRequest  true  "注册信息"
// @Success      200      {object}  loginResponse
// @Failure      400      {object}  map[string]any
// @Router       /auth/register [post]
func registerHandler(c *gin.Context, svc *authservice.AuthService) <span class="cov8" title="1">{
        var req registerRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                respondError(c, http.StatusBadRequest, ErrInvalidJSONPayload)
                return
        }</span>
        <span class="cov8" title="1">resp, err := svc.Register(c.Request.Context(), authservice.RegisterRequest{
                Phone:    req.Phone,
                Email:    req.Email,
                Password: req.Password,
                Name:     req.Name,
                Role:     model.RoleUser,
        })
        if err != nil </span><span class="cov8" title="1">{
                respondError(c, http.StatusBadRequest, err.Error())
                return
        }</span>
        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[loginResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    loginResponse{Token: resp.Token, ExpiresAt: resp.ExpiresAt, User: resp.User},
        })</span>
}

// Me
// @Summary      获取当前用户信息
// @Tags         Auth
// @Security     BearerAuth
// @Produce      json
// @Success      200  {object}  loginResponse
// @Failure      401  {object}  map[string]any
// @Router       /auth/me [get]
func meHandler(c *gin.Context, svc *authservice.AuthService) <span class="cov8" title="1">{
        user, err := svc.Me(c.Request.Context(), c.GetHeader("Authorization"))
        if err != nil </span><span class="cov8" title="1">{
                status := http.StatusUnauthorized
                if err == service.ErrUserDisabled </span><span class="cov0" title="0">{
                        status = http.StatusForbidden
                }</span>
                <span class="cov8" title="1">respondError(c, status, err.Error())
                return</span>
        }
        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[loginResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    loginResponse{Token: "", ExpiresAt: time.Time{}, User: *user},
        })</span>
}

// Refresh
// @Summary      刷新 Token
// @Description  使用 Authorization: Bearer &lt;token&gt; 刷新 JWT
// @Tags         Auth
// @Produce      json
// @Security     BearerAuth
// @Success      200  {object}  tokenPayload
// @Failure      401  {object}  map[string]any
// @Router       /auth/refresh [post]
func refreshHandler(c *gin.Context, svc *authservice.AuthService) <span class="cov8" title="1">{
        token, err := auth.ExtractTokenFromHeader(c.GetHeader("Authorization"))
        if err != nil </span><span class="cov8" title="1">{
                respondError(c, http.StatusUnauthorized, err.Error())
                return
        }</span>
        <span class="cov0" title="0">newToken, err := svc.RefreshToken(c.Request.Context(), token)
        if err != nil </span><span class="cov0" title="0">{
                status := http.StatusUnauthorized
                if err == service.ErrUserDisabled </span><span class="cov0" title="0">{
                        status = http.StatusForbidden
                }</span>
                <span class="cov0" title="0">respondError(c, status, err.Error())
                return</span>
        }

        <span class="cov0" title="0">respondJSON(c, http.StatusOK, model.APIResponse[tokenPayload]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    tokenPayload{Token: newToken},
        })</span>
}

// Logout
// @Summary      登出（前端丢弃 Token）
// @Tags         Auth
// @Security     BearerAuth
// @Success      200  {object}  map[string]any
// @Router       /auth/logout [post]
func logoutHandler(c *gin.Context) <span class="cov8" title="1">{
        respondJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "logged out",
        })
}</span>

// local helpers for uniform envelope
func respondJSON[T any](c *gin.Context, status int, payload model.APIResponse[T]) <span class="cov8" title="1">{
        c.JSON(status, payload)
}</span>
func respondError(c *gin.Context, status int, msg string) <span class="cov8" title="1">{
        respondJSON(c, status, model.APIResponse[any]{Success: false, Code: status, Message: msg})
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package handler

import "github.com/gin-gonic/gin"

// RegisterHealth 注册健康检查路由。
func RegisterHealth(router gin.IRoutes) <span class="cov8" title="1">{
        router.GET("/healthz", Health)
}</span>

// Health 返回服务运行状态。
func Health(c *gin.Context) <span class="cov8" title="1">{
        c.JSON(200, gin.H{"status": "ok"})
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package middleware

import (
    "net/http"
    "os"
    "strconv"

    "github.com/gin-gonic/gin"

    "gamelink/internal/logging"
)

// AdminAuth enforces a simple bearer token for admin endpoints.
// Behavior:
// - If APP_ENV=production and ADMIN_TOKEN is empty -&gt; reject all with 503 to avoid unsafe exposure.
// - If ADMIN_TOKEN is set -&gt; require Authorization: Bearer &lt;ADMIN_TOKEN&gt;.
// - Otherwise (development) -&gt; pass-through.
func AdminAuth() gin.HandlerFunc <span class="cov8" title="1">{
        env := os.Getenv("APP_ENV")
        token := os.Getenv("ADMIN_TOKEN")

        // If production and no token configured, block access.
        if env == "production" &amp;&amp; token == "" </span><span class="cov8" title="1">{
                return func(c *gin.Context) </span><span class="cov8" title="1">{
                        c.AbortWithStatusJSON(http.StatusServiceUnavailable, gin.H{
                                "success": false,
                                "code":    http.StatusServiceUnavailable,
                                "message": "admin auth not configured",
                        })
                }</span>
        }

    // If no token configured (development), allow requests and optional actor injection
    <span class="cov8" title="1">if token == "" </span><span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
            // In non-production, allow an optional X-Admin-User-ID to mark actor for audit.
            if os.Getenv("APP_ENV") != "production" </span><span class="cov8" title="1">{
                if v := c.GetHeader("X-Admin-User-ID"); v != "" </span><span class="cov8" title="1">{
                    if id, err := strconv.ParseUint(v, 10, 64); err == nil &amp;&amp; id != 0 </span><span class="cov8" title="1">{
                        c.Request = c.Request.WithContext(logging.WithActorUserID(c.Request.Context(), id))
                    }</span>
                }
            }
            <span class="cov8" title="1">c.Next()</span>
        }
    }

        // Enforce bearer token
        <span class="cov8" title="1">prefix := "Bearer "
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                auth := c.GetHeader("Authorization")
                if auth != prefix+token </span><span class="cov8" title="1">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "code":    http.StatusUnauthorized,
                                "message": "unauthorized",
                        })
                        return
                }</span>
                <span class="cov8" title="1">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package middleware

import (
        "net/http"
        "os"
        "strings"

        "github.com/gin-gonic/gin"
)

// CORS 中间件处理跨域请求
//
// 技术原理：
// 1. 浏览器在发送跨域请求前会先发送OPTIONS预检请求
// 2. 后端需要返回正确的CORS头信息，告诉浏览器允许哪些跨域请求
// 3. 对于简单请求，浏览器直接发送请求并检查响应头
// 4. 对于复杂请求（如PUT、DELETE等），浏览器先发送OPTIONS预检请求
//
// 常见CORS头：
// - Access-Control-Allow-Origin: 允许的源（*表示所有源）
// - Access-Control-Allow-Methods: 允许的HTTP方法
// - Access-Control-Allow-Headers: 允许的请求头
// - Access-Control-Allow-Credentials: 是否允许携带认证信息
func CORS() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                method := c.Request.Method
                origin := c.Request.Header.Get("Origin")

                // 设置允许的源
                // 开发环境：允许所有源
                // 生产环境：应该配置具体的域名
                allowedOrigins := getAllowedOrigins()

                // 检查请求源是否在允许列表中
                allowed := false
                for _, allowedOrigin := range allowedOrigins </span><span class="cov8" title="1">{
                        if allowedOrigin == "*" || allowedOrigin == origin </span><span class="cov8" title="1">{
                                allowed = true
                                break</span>
                        }
                }

                <span class="cov8" title="1">if allowed </span><span class="cov8" title="1">{
                        // 设置CORS响应头
                        c.Header("Access-Control-Allow-Origin", origin)
                        c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                        c.Header("Access-Control-Allow-Headers", "Origin, Content-Type, Accept, Authorization")
                        c.Header("Access-Control-Allow-Credentials", "true")
                        c.Header("Access-Control-Max-Age", "86400") // 预检请求缓存24小时
                }</span>

                // 处理预检请求（OPTIONS）
                <span class="cov8" title="1">if method == "OPTIONS" </span><span class="cov8" title="1">{
                        c.AbortWithStatus(http.StatusNoContent)
                        return
                }</span>

                <span class="cov8" title="1">c.Next()</span>
        }
}

// getAllowedOrigins 根据环境获取允许的源
func getAllowedOrigins() []string <span class="cov8" title="1">{
        env := os.Getenv("APP_ENV")
        raw := strings.TrimSpace(os.Getenv("CORS_ALLOWED_ORIGINS"))

        // parse comma-separated list
        parse := func(s string) []string </span><span class="cov8" title="1">{
                if s == "" </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">parts := strings.Split(s, ",")
                out := make([]string, 0, len(parts))
                for _, p := range parts </span><span class="cov8" title="1">{
                        if v := strings.TrimSpace(p); v != "" </span><span class="cov8" title="1">{
                                out = append(out, v)
                        }</span>
                }
                <span class="cov8" title="1">return out</span>
        }

        <span class="cov8" title="1">if env == "production" </span><span class="cov8" title="1">{
                // In production, default to EMPTY (deny) unless explicitly configured.
                // This prevents insecure wildcard. Set CORS_ALLOWED_ORIGINS to a comma-separated list.
                return parse(raw)
        }</span>

        // Development: allow configured list if present, otherwise wildcard.
        <span class="cov8" title="1">if list := parse(raw); len(list) &gt; 0 </span><span class="cov0" title="0">{
                return list
        }</span>
        <span class="cov8" title="1">return []string{"*"}</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package middleware

import (
        "bytes"
        "crypto/aes"
        "crypto/cipher"
        "crypto/sha256"
        "encoding/base64"
        "encoding/hex"
        "encoding/json"
        "errors"
        "io"
        "log/slog"
        "net/http"
        "strconv"
        "strings"

        "github.com/gin-gonic/gin"

        "gamelink/internal/config"
        "gamelink/internal/model"
)

type encryptedRequest struct {
        Encrypted bool   `json:"encrypted"`
        Payload   string `json:"payload"`
        Timestamp int64  `json:"timestamp"`
        Signature string `json:"signature"`
}

// Crypto 提供与前端 AES-256-CBC 加密协议对接的请求解密能力。
// 满足 config.Crypto 中的配置时会尝试解密请求体，并在成功后将明文请求体重新写入 gin.Context。
func Crypto(cfg config.CryptoConfig) gin.HandlerFunc <span class="cov8" title="1">{
        if !cfg.Enabled </span><span class="cov0" title="0">{
                return func(c *gin.Context) </span><span class="cov0" title="0">{
                        c.Next()
                }</span>
        }

        <span class="cov8" title="1">block, err := aes.NewCipher([]byte(cfg.SecretKey))
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to init crypto middleware", "error", err)
                return func(c *gin.Context) </span><span class="cov0" title="0">{
                        abortWithCryptoError(c, http.StatusInternalServerError, "后端加密配置错误")
                }</span>
        }

        <span class="cov8" title="1">methods := make(map[string]struct{}, len(cfg.Methods))
        for _, m := range cfg.Methods </span><span class="cov8" title="1">{
                methods[strings.ToUpper(strings.TrimSpace(m))] = struct{}{}
        }</span>
        <span class="cov8" title="1">excludePaths := cfg.ExcludePaths
        iv := []byte(cfg.IV)

        return func(c *gin.Context) </span><span class="cov8" title="1">{
                if !shouldProcessRequest(c, methods, excludePaths) </span><span class="cov8" title="1">{
                        c.Next()
                        return
                }</span>

                <span class="cov8" title="1">if c.Request.Body == nil </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                <span class="cov8" title="1">originalBody := c.Request.Body
                bodyBytes, err := io.ReadAll(originalBody)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Warn("crypto middleware: read body failed", "error", err)
                        abortWithCryptoError(c, http.StatusBadRequest, "无法读取请求体")
                        return
                }</span>
                <span class="cov8" title="1">_ = originalBody.Close()

                if len(bytes.TrimSpace(bodyBytes)) == 0 </span><span class="cov0" title="0">{
                        restoreRequestBody(c, bodyBytes)
                        c.Next()
                        return
                }</span>

                <span class="cov8" title="1">var req encryptedRequest
                if err := json.Unmarshal(bodyBytes, &amp;req); err != nil || !req.Encrypted </span><span class="cov0" title="0">{
                        restoreRequestBody(c, bodyBytes)
                        c.Next()
                        return
                }</span>

                <span class="cov8" title="1">plain, err := decryptPayload(block, iv, req.Payload)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Warn("crypto middleware: decrypt failed", "error", err)
                        abortWithCryptoError(c, http.StatusBadRequest, "请求数据解密失败")
                        return
                }</span>

                <span class="cov8" title="1">if cfg.UseSignature </span><span class="cov8" title="1">{
                        if req.Signature == "" || req.Timestamp == 0 </span><span class="cov0" title="0">{
                                abortWithCryptoError(c, http.StatusBadRequest, "缺少签名或时间戳")
                                return
                        }</span>
                        <span class="cov8" title="1">expected := generateSignature(plain, req.Timestamp, cfg.SecretKey)
                        if !strings.EqualFold(expected, req.Signature) </span><span class="cov8" title="1">{
                                slog.Warn("crypto middleware: signature mismatch", "expected", expected, "got", req.Signature)
                                abortWithCryptoError(c, http.StatusBadRequest, "请求签名验证失败")
                                return
                        }</span>
                }

                <span class="cov8" title="1">restoreRequestBody(c, plain)
                c.Set("crypto.encrypted", true)
                c.Set("crypto.timestamp", req.Timestamp)
                if req.Signature != "" </span><span class="cov8" title="1">{
                        c.Set("crypto.signature", req.Signature)
                }</span>
                <span class="cov8" title="1">c.Set("crypto.raw_payload", string(plain))
                c.Next()</span>
        }
}

func shouldProcessRequest(c *gin.Context, methods map[string]struct{}, excludePaths []string) bool <span class="cov8" title="1">{
        method := strings.ToUpper(c.Request.Method)
        if len(methods) &gt; 0 </span><span class="cov8" title="1">{
                if _, ok := methods[method]; !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">path := c.Request.URL.Path
        for _, exclude := range excludePaths </span><span class="cov8" title="1">{
                exclude = strings.TrimSpace(exclude)
                if exclude == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.Contains(path, exclude) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func decryptPayload(block cipher.Block, iv []byte, payload string) ([]byte, error) <span class="cov8" title="1">{
        raw, err := base64.StdEncoding.DecodeString(payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(iv) &lt; block.BlockSize() </span><span class="cov0" title="0">{
                return nil, errors.New("invalid iv length")
        }</span>
        <span class="cov8" title="1">if len(raw) == 0 || len(raw)%block.BlockSize() != 0 </span><span class="cov0" title="0">{
                return nil, errors.New("ciphertext length is not aligned with block size")
        }</span>

        <span class="cov8" title="1">plain := make([]byte, len(raw))
        copyIV := make([]byte, block.BlockSize())
        copy(copyIV, iv[:block.BlockSize()])
        mode := cipher.NewCBCDecrypter(block, copyIV)
        mode.CryptBlocks(plain, raw)

        return pkcs7Unpad(plain, block.BlockSize())</span>
}

func pkcs7Unpad(data []byte, blockSize int) ([]byte, error) <span class="cov8" title="1">{
        if len(data) == 0 || len(data)%blockSize != 0 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid padded data size")
        }</span>
        <span class="cov8" title="1">padding := int(data[len(data)-1])
        if padding == 0 || padding &gt; blockSize </span><span class="cov0" title="0">{
                return nil, errors.New("invalid padding size")
        }</span>
        <span class="cov8" title="1">for i := len(data) - padding; i &lt; len(data); i++ </span><span class="cov8" title="1">{
                if data[i] != byte(padding) </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid padding bytes")
                }</span>
        }
        <span class="cov8" title="1">return data[:len(data)-padding], nil</span>
}

func generateSignature(plain []byte, timestamp int64, secret string) string <span class="cov8" title="1">{
        message := string(plain) + strconv.FormatInt(timestamp, 10) + secret
        hash := sha256.Sum256([]byte(message))
        return hex.EncodeToString(hash[:])
}</span>

func restoreRequestBody(c *gin.Context, data []byte) <span class="cov8" title="1">{
        c.Request.Body = io.NopCloser(bytes.NewReader(data))
        c.Request.ContentLength = int64(len(data))
        c.Request.Header.Set("Content-Length", strconv.Itoa(len(data)))
}</span>

func abortWithCryptoError(c *gin.Context, status int, message string) <span class="cov8" title="1">{
        c.AbortWithStatusJSON(status, model.APIResponse[any]{
                Success: false,
                Code:    status,
                Message: message,
        })
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package middleware

import (
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"

        "gamelink/internal/apierr"
        "gamelink/internal/model"
        "gamelink/internal/repository"
        "gamelink/internal/service"
)

// ErrorMap inspects gin errors and maps known errors to standard envelope responses.
// Only applies when handler hasn't already written a response.
func ErrorMap() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                c.Next()
                if c.Writer.Written() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">if len(c.Errors) == 0 </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">err := c.Errors[0].Err
                switch err </span>{
                case service.ErrValidation:<span class="cov8" title="1">
                        c.JSON(http.StatusBadRequest, model.APIResponse[any]{Success: false, Code: http.StatusBadRequest, Message: "validation failed"})
                        return</span>
                case service.ErrOrderInvalidTransition:<span class="cov0" title="0">
                        c.JSON(http.StatusConflict, model.APIResponse[any]{Success: false, Code: http.StatusConflict, Message: apierr.ErrOrderInvalidTransition})
                        return</span>
                case service.ErrUserNotFound:<span class="cov0" title="0">
                        c.JSON(http.StatusNotFound, model.APIResponse[any]{Success: false, Code: http.StatusNotFound, Message: apierr.ErrUserNotFound})
                        return</span>
                case service.ErrNotFound, repository.ErrNotFound:<span class="cov8" title="1">
                        // Return domain-specific not found messages based on route path
                        path := c.FullPath()
                        if path == "" </span><span class="cov0" title="0">{
                                path = c.Request.URL.Path
                        }</span>
                        <span class="cov8" title="1">msg := domainNotFoundMessage(path)
                        c.JSON(http.StatusNotFound, model.APIResponse[any]{Success: false, Code: http.StatusNotFound, Message: msg})
                        return</span>
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusInternalServerError, model.APIResponse[any]{Success: false, Code: http.StatusInternalServerError, Message: "internal server error"})
                        return</span>
                }
        }
}

// domainNotFoundMessage returns a stable message for 404 based on route path.
func domainNotFoundMessage(path string) string <span class="cov8" title="1">{
        p := strings.ToLower(path)
        switch </span>{
        case strings.Contains(p, "/users"):<span class="cov8" title="1">
                return apierr.ErrUserNotFound</span>
        case strings.Contains(p, "/orders"):<span class="cov0" title="0">
                return apierr.ErrOrderNotFound</span>
        case strings.Contains(p, "/payments"):<span class="cov0" title="0">
                return apierr.ErrPaymentNotFound</span>
        case strings.Contains(p, "/players"):<span class="cov0" title="0">
                return apierr.ErrPlayerNotFound</span>
        case strings.Contains(p, "/games"):<span class="cov0" title="0">
                return apierr.ErrGameNotFound</span>
        default:<span class="cov8" title="1">
                return "not found"</span>
        }
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package middleware

import (
    "net/http"
    "os"
    "time"

    "github.com/gin-gonic/gin"

    "gamelink/internal/auth"
    "gamelink/internal/logging"
)

// JWTAuth JWT认证中间件
//
// 使用方法：
// router.Use(middleware.JWTAuth())
// 或者
// adminGroup.Use(middleware.JWTAuth())
func JWTAuth() gin.HandlerFunc <span class="cov8" title="1">{
        // 从环境变量获取JWT密钥
        secretKey := os.Getenv("JWT_SECRET_KEY")
        if secretKey == "" </span><span class="cov8" title="1">{
                if os.Getenv("APP_ENV") == "production" </span><span class="cov8" title="1">{
                        return func(c *gin.Context) </span><span class="cov8" title="1">{
                                c.AbortWithStatusJSON(http.StatusServiceUnavailable, gin.H{
                                        "success": false,
                                        "code":    http.StatusServiceUnavailable,
                                        "message": "jwt not configured",
                                })
                        }</span>
                }
                // 开发环境使用默认值
                <span class="cov0" title="0">secretKey = "gamelink-default-secret-key-change-in-production"</span>
        }

        // Token有效期（24小时）
        <span class="cov8" title="1">tokenDuration := 24 * time.Hour

        // 创建JWT管理器
        jwtManager := auth.NewJWTManager(secretKey, tokenDuration)

        return func(c *gin.Context) </span><span class="cov8" title="1">{
                // 从请求头获取Authorization
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "code":    http.StatusUnauthorized,
                                "message": "缺少Authorization头",
                        })
                        c.Abort()
                        return
                }</span>

                // 提取Token
                <span class="cov8" title="1">tokenString, err := auth.ExtractTokenFromHeader(authHeader)
                if err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "code":    http.StatusUnauthorized,
                                "message": err.Error(),
                        })
                        c.Abort()
                        return
                }</span>

                // 验证Token
                <span class="cov8" title="1">claims, err := jwtManager.VerifyToken(tokenString)
                if err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "code":    http.StatusUnauthorized,
                                "message": "无效的Token: " + err.Error(),
                        })
                        c.Abort()
                        return
                }</span>

                // 检查Token是否过期
                <span class="cov8" title="1">if auth.IsTokenExpired(claims) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "code":    http.StatusUnauthorized,
                                "message": "Token已过期",
                        })
                        c.Abort()
                        return
                }</span>

        // 将用户信息存储到Context中，供后续处理使用
        <span class="cov8" title="1">c.Set("user_id", claims.UserID)
        c.Set("user_role", claims.Role)
        c.Set("jwt_claims", claims)
        // 注入 actor 到 request context，便于服务层审计日志使用
        c.Request = c.Request.WithContext(logging.WithActorUserID(c.Request.Context(), claims.UserID))

                // 检查Token剩余时间，如果快要过期，在响应头中提示前端刷新Token
                remainingTime := auth.GetTokenRemainingTime(claims)
                if remainingTime &lt; 1*time.Hour </span><span class="cov8" title="1">{
                        c.Header("X-Token-Refresh", "true")
                        c.Header("X-Token-Remaining", remainingTime.String())
                }</span>

                <span class="cov8" title="1">c.Next()</span>
        }
}

// RequireRole 要求特定角色的中间件
//
// 使用方法：
// router.Use(middleware.RequireRole("admin"))
// 或者
// adminGroup.Use(middleware.RequireRole("admin", "moderator"))
func RequireRole(allowedRoles ...string) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                // 获取用户角色
                userRole, exists := c.Get("user_role")
                if !exists </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "code":    http.StatusUnauthorized,
                                "message": "用户未认证",
                        })
                        c.Abort()
                        return
                }</span>

                // 检查用户角色是否在允许的角色列表中
                <span class="cov8" title="1">roleStr, ok := userRole.(string)
                if !ok </span><span class="cov8" title="1">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "code":    http.StatusInternalServerError,
                                "message": "用户角色格式错误",
                        })
                        c.Abort()
                        return
                }</span>

                // 检查角色权限
                <span class="cov8" title="1">hasPermission := false
                for _, allowedRole := range allowedRoles </span><span class="cov8" title="1">{
                        if roleStr == allowedRole </span><span class="cov8" title="1">{
                                hasPermission = true
                                break</span>
                        }
                }

                <span class="cov8" title="1">if !hasPermission </span><span class="cov8" title="1">{
                        c.JSON(http.StatusForbidden, gin.H{
                                "success": false,
                                "code":    http.StatusForbidden,
                                "message": "权限不足",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">c.Next()</span>
        }
}

// OptionalAuth 可选认证中间件
//
// 如果提供了Token则验证，如果没有提供Token则允许继续
// 适用于那些既可以登录访问也可以匿名访问的接口
func OptionalAuth() gin.HandlerFunc <span class="cov8" title="1">{
        // 从环境变量获取JWT密钥
        secretKey := os.Getenv("JWT_SECRET_KEY")
        if secretKey == "" </span><span class="cov8" title="1">{
                if os.Getenv("APP_ENV") == "production" </span><span class="cov8" title="1">{
                        // 生产环境未配置则视为未认证通过（但 optional 允许继续）
                        return func(c *gin.Context) </span><span class="cov8" title="1">{ c.Next() }</span>
                }
                <span class="cov0" title="0">secretKey = "gamelink-default-secret-key-change-in-production"</span>
        }

        <span class="cov8" title="1">tokenDuration := 24 * time.Hour
        jwtManager := auth.NewJWTManager(secretKey, tokenDuration)

        return func(c *gin.Context) </span><span class="cov8" title="1">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov8" title="1">{
                        // 没有提供Token，继续执行
                        c.Next()
                        return
                }</span>

                // 尝试验证Token
                <span class="cov8" title="1">tokenString, err := auth.ExtractTokenFromHeader(authHeader)
                if err != nil </span><span class="cov8" title="1">{
                        // Token格式错误，继续执行（匿名访问）
                        c.Next()
                        return
                }</span>

                <span class="cov8" title="1">claims, err := jwtManager.VerifyToken(tokenString)
                if err != nil </span><span class="cov8" title="1">{
                        // Token无效，继续执行（匿名访问）
                        c.Next()
                        return
                }</span>

                <span class="cov8" title="1">if auth.IsTokenExpired(claims) </span><span class="cov0" title="0">{
                        // Token过期，继续执行（匿名访问）
                        c.Next()
                        return
                }</span>

        // Token有效，将用户信息存储到Context中
        <span class="cov8" title="1">c.Set("user_id", claims.UserID)
        c.Set("user_role", claims.Role)
        c.Set("jwt_claims", claims)
        c.Set("is_authenticated", true)
        // 注入 actor
        c.Request = c.Request.WithContext(logging.WithActorUserID(c.Request.Context(), claims.UserID))

                c.Next()</span>
        }
}

// GetUserID 从Context中获取用户ID
func GetUserID(c *gin.Context) (uint64, bool) <span class="cov8" title="1">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov8" title="1">{
                return 0, false
        }</span>

        <span class="cov8" title="1">id, ok := userID.(uint64)
        return id, ok</span>
}

// GetUserRole 从Context中获取用户角色
func GetUserRole(c *gin.Context) (string, bool) <span class="cov8" title="1">{
        userRole, exists := c.Get("user_role")
        if !exists </span><span class="cov8" title="1">{
                return "", false
        }</span>

        <span class="cov8" title="1">role, ok := userRole.(string)
        return role, ok</span>
}

// IsAuthenticated 检查用户是否已认证
func IsAuthenticated(c *gin.Context) bool <span class="cov8" title="1">{
        isAuthenticated, exists := c.Get("is_authenticated")
        if !exists </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">authenticated, ok := isAuthenticated.(bool)
        return ok &amp;&amp; authenticated</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package middleware

import (
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"

        "gamelink/internal/metrics"
)

// MetricsMiddleware records HTTP metrics.
func MetricsMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        // ensure metrics are initialized
        metrics.Init(prometheus.DefaultRegisterer)
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                start := time.Now()
                c.Next()
                path := c.FullPath()
                if path == "" </span><span class="cov8" title="1">{
                        path = c.Request.URL.Path
                }</span>
                <span class="cov8" title="1">method := c.Request.Method
                status := strconv.Itoa(c.Writer.Status())
                metrics.HTTPRequestsTotal.WithLabelValues(method, path, status).Inc()
                metrics.HTTPRequestDuration.WithLabelValues(method, path).Observe(time.Since(start).Seconds())</span>
        }
}

// MetricsHandler exposes /metrics endpoint using promhttp.DefaultGatherer.
func MetricsHandler() gin.HandlerFunc <span class="cov8" title="1">{
        metrics.Init(prometheus.DefaultRegisterer)
        h := promhttp.Handler()
        return func(c *gin.Context) </span><span class="cov8" title="1">{ h.ServeHTTP(c.Writer, c.Request) }</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package middleware

import (
    "net/http"
    "strings"

    "github.com/gin-gonic/gin"

    "gamelink/internal/auth"
    "gamelink/internal/model"
    roleservice "gamelink/internal/service/role"
    permissionservice "gamelink/internal/service/permission"
)

const (
        // UserIDKey 在 Gin Context 中存储用户 ID 的键
        UserIDKey = "user_id"
        // UserRoleKey 在 Gin Context 中存储用户角色的键
        UserRoleKey = "user_role"
        // UserPermissionsKey 在 Gin Context 中存储用户权限的键
        UserPermissionsKey = "user_permissions"
)

// PermissionMiddleware 权限中间件配置。
type PermissionMiddleware struct {
    jwtManager    *auth.JWTManager
    permissionSvc *permissionservice.PermissionService
    roleSvc       *roleservice.RoleService
}

// NewPermissionMiddleware 创建权限中间件实例。
func NewPermissionMiddleware(
    jwtManager *auth.JWTManager,
    permissionSvc *permissionservice.PermissionService,
    roleSvc *roleservice.RoleService,
) *PermissionMiddleware <span class="cov0" title="0">{
    return &amp;PermissionMiddleware{
        jwtManager:    jwtManager,
        permissionSvc: permissionSvc,
        roleSvc:       roleSvc,
    }
}</span>

// RequireAuth 要求用户已登录（验证 JWT）。
func (m *PermissionMiddleware) RequireAuth() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // 提取 Token
                authHeader := c.GetHeader("Authorization")
                token, err := auth.ExtractTokenFromHeader(authHeader)
                if err != nil </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "code":    http.StatusUnauthorized,
                                "message": "未授权：" + err.Error(),
                        })
                        return
                }</span>

                // 验证 Token
                <span class="cov0" title="0">claims, err := m.jwtManager.VerifyToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "code":    http.StatusUnauthorized,
                                "message": "Token 无效：" + err.Error(),
                        })
                        return
                }</span>

                // 检查是否过期
                <span class="cov0" title="0">if auth.IsTokenExpired(claims) </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "code":    http.StatusUnauthorized,
                                "message": "Token 已过期",
                        })
                        return
                }</span>

                // 将用户信息存入上下文
                <span class="cov0" title="0">c.Set(UserIDKey, claims.UserID)
                c.Set(UserRoleKey, claims.Role)

                c.Next()</span>
        }
}

// RequireRole 要求用户拥有指定角色（向后兼容，使用旧的 role 字段）。
func (m *PermissionMiddleware) RequireRole(requiredRole string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // 先执行认证
                m.RequireAuth()(c)
                if c.IsAborted() </span><span class="cov0" title="0">{
                        return
                }</span>

                // 获取用户角色
                <span class="cov0" title="0">role, exists := c.Get(UserRoleKey)
                if !exists </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusForbidden, gin.H{
                                "success": false,
                                "code":    http.StatusForbidden,
                                "message": "无法获取用户角色",
                        })
                        return
                }</span>

                // 检查角色
                <span class="cov0" title="0">if role.(string) != requiredRole </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusForbidden, gin.H{
                                "success": false,
                                "code":    http.StatusForbidden,
                                "message": "权限不足：需要 " + requiredRole + " 角色",
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// RequirePermission 要求用户拥有指定权限（使用 method+path 或 code）。
// 注意：此中间件假设在 group 级别已经执行了 RequireAuth()，不会重复执行认证。
func (m *PermissionMiddleware) RequirePermission(method model.HTTPMethod, path string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // 获取用户 ID（应该已经由 RequireAuth 设置）
                userID, exists := c.Get(UserIDKey)
                if !exists </span><span class="cov0" title="0">{
                        // 如果没有用户信息，说明认证中间件没有执行，返回 401
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "code":    http.StatusUnauthorized,
                                "message": "未授权：请先登录",
                        })
                        return
                }</span>

                <span class="cov0" title="0">uid := userID.(uint64)

                // 检查是否为超级管理员（拥有所有权限）
                isSuperAdmin, err := m.roleSvc.CheckUserIsSuperAdmin(c.Request.Context(), uid)
                if err == nil &amp;&amp; isSuperAdmin </span><span class="cov0" title="0">{
                        // 超级管理员放行
                        c.Next()
                        return
                }</span>

                // 使用 method+path 检查权限
                <span class="cov0" title="0">hasPermission, checkErr := m.permissionSvc.CheckUserHasPermission(
                        c.Request.Context(),
                        uid,
                        method,
                        path,
                )

                if checkErr != nil </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "code":    http.StatusInternalServerError,
                                "message": "权限检查失败",
                        })
                        return
                }</span>

                <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusForbidden, gin.H{
                                "success": false,
                                "code":    http.StatusForbidden,
                                "message": "权限不足",
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// RequireAnyRole 要求用户拥有任一指定角色。
func (m *PermissionMiddleware) RequireAnyRole(roles ...string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // 先执行认证
                m.RequireAuth()(c)
                if c.IsAborted() </span><span class="cov0" title="0">{
                        return
                }</span>

                // 获取用户 ID
                <span class="cov0" title="0">userID, exists := c.Get(UserIDKey)
                if !exists </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusForbidden, gin.H{
                                "success": false,
                                "code":    http.StatusForbidden,
                                "message": "无法获取用户信息",
                        })
                        return
                }</span>

                <span class="cov0" title="0">uid := userID.(uint64)

                // 检查用户是否拥有任一角色
                for _, roleSlug := range roles </span><span class="cov0" title="0">{
                        hasRole, err := m.roleSvc.CheckUserHasRole(c.Request.Context(), uid, roleSlug)
                        if err == nil &amp;&amp; hasRole </span><span class="cov0" title="0">{
                                c.Next()
                                return
                        }</span>
                }

                <span class="cov0" title="0">c.AbortWithStatusJSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "code":    http.StatusForbidden,
                        "message": "权限不足：需要以下角色之一：" + strings.Join(roles, ", "),
                })</span>
        }
}

// 注意：GetUserID 和 GetUserRole 已在 jwt_auth.go 中定义
</pre>
		
		<pre class="file" id="file41" style="display: none">package middleware

import (
    "context"
    "fmt"
    "log"
    "strings"

    "github.com/gin-gonic/gin"

    "gamelink/internal/model"
    permissionservice "gamelink/internal/service/permission"
)

// APISyncConfig API 同步配置。
type APISyncConfig struct {
        // GroupFilter 只同步匹配该前缀的路由分组，如 "/api/v1/admin"
        GroupFilter string
        // SkipPaths 跳过的路径列表
        SkipPaths []string
        // DryRun 是否为演练模式（不实际写入数据库）
        DryRun bool
}

// SyncAPIPermissions 同步 API 路由到权限表。
// 在应用启动后调用，遍历所有路由并注册到 permissions 表。
func SyncAPIPermissions(router *gin.Engine, permissionSvc *permissionservice.PermissionService, cfg APISyncConfig) error <span class="cov0" title="0">{
        routes := router.Routes()

        var permissions []model.Permission
        for _, route := range routes </span><span class="cov0" title="0">{
                // 跳过不匹配的分组
                if cfg.GroupFilter != "" &amp;&amp; !strings.HasPrefix(route.Path, cfg.GroupFilter) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 跳过指定路径
                <span class="cov0" title="0">if shouldSkip(route.Path, cfg.SkipPaths) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 提取分组（取路径的第三级，如 /api/v1/admin/games -&gt; /admin/games）
                <span class="cov0" title="0">group := extractGroup(route.Path)

                // 生成语义化 code（如 admin.games.list）
                code := generatePermissionCode(route.Method, route.Path)

                perm := model.Permission{
                        Method:      model.HTTPMethod(route.Method),
                        Path:        route.Path,
                        Code:        code,
                        Group:       group,
                        Description: fmt.Sprintf("%s %s", route.Method, route.Path),
                }

                permissions = append(permissions, perm)</span>
        }

        <span class="cov0" title="0">if cfg.DryRun </span><span class="cov0" title="0">{
                log.Printf("[DryRun] Would sync %d permissions:", len(permissions))
                for _, p := range permissions </span><span class="cov0" title="0">{
                        log.Printf("  - [%s] %s (code: %s, group: %s)", p.Method, p.Path, p.Code, p.Group)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // 批量 upsert 权限
        <span class="cov0" title="0">ctx := context.Background()
        for _, perm := range permissions </span><span class="cov0" title="0">{
                // 创建局部副本，避免 range 变量复用问题
                p := perm
                if err := permissionSvc.UpsertPermission(ctx, &amp;p); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to upsert permission %s %s: %v", p.Method, p.Path, err)
                        // 继续处理其他权限
                }</span>
        }

        <span class="cov0" title="0">log.Printf("Synced %d API permissions to database", len(permissions))
        return nil</span>
}

// shouldSkip 检查路径是否应该跳过。
func shouldSkip(path string, skipPaths []string) bool <span class="cov0" title="0">{
        for _, skip := range skipPaths </span><span class="cov0" title="0">{
                if strings.HasPrefix(path, skip) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// extractGroup 提取路由分组。
// 例如：/api/v1/admin/games/:id -&gt; /admin/games
func extractGroup(path string) string <span class="cov0" title="0">{
        parts := strings.Split(path, "/")
        if len(parts) &lt; 4 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // 移除 /api/v1 前缀
        <span class="cov0" title="0">if parts[1] == "api" &amp;&amp; strings.HasPrefix(parts[2], "v") </span><span class="cov0" title="0">{
                parts = parts[3:]
        }</span>

        // 找到第一个非参数部分作为分组
        <span class="cov0" title="0">var groupParts []string
        for _, part := range parts </span><span class="cov0" title="0">{
                if part == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                // 跳过路径参数（:id, :slug 等）
                <span class="cov0" title="0">if strings.HasPrefix(part, ":") </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">groupParts = append(groupParts, part)</span>
        }

        <span class="cov0" title="0">if len(groupParts) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return "/" + strings.Join(groupParts, "/")</span>
}

// generatePermissionCode 生成权限的语义化标识。
// 例如：GET /api/v1/admin/games -&gt; admin.games.list
//
//        POST /api/v1/admin/games -&gt; admin.games.create
//        GET /api/v1/admin/games/:id -&gt; admin.games.read
//        PUT /api/v1/admin/games/:id -&gt; admin.games.update
//        DELETE /api/v1/admin/games/:id -&gt; admin.games.delete
func generatePermissionCode(method, path string) string <span class="cov0" title="0">{
        parts := strings.Split(path, "/")

        // 移除空字符串和 api/v1 前缀
        var cleanParts []string
        for i, part := range parts </span><span class="cov0" title="0">{
                if part == "" || part == "api" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if strings.HasPrefix(part, "v") &amp;&amp; i == 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                // 跳过路径参数
                <span class="cov0" title="0">if strings.HasPrefix(part, ":") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">cleanParts = append(cleanParts, part)</span>
        }

        <span class="cov0" title="0">if len(cleanParts) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // 判断是否有 ID 参数（资源详情操作）
        <span class="cov0" title="0">hasIDParam := strings.Contains(path, "/:id") || strings.Contains(path, "/:") &amp;&amp; strings.HasSuffix(path, "/:id")

        // 根据 HTTP 方法和是否有 ID 参数确定操作类型
        var action string
        switch method </span>{
        case "GET":<span class="cov0" title="0">
                if hasIDParam </span><span class="cov0" title="0">{
                        action = "read"
                }</span> else<span class="cov0" title="0"> {
                        action = "list"
                }</span>
        case "POST":<span class="cov0" title="0">
                action = "create"</span>
        case "PUT", "PATCH":<span class="cov0" title="0">
                action = "update"</span>
        case "DELETE":<span class="cov0" title="0">
                action = "delete"</span>
        default:<span class="cov0" title="0">
                action = strings.ToLower(method)</span>
        }

        // 组合：resource.action，如 admin.games.list
        <span class="cov0" title="0">return strings.Join(cleanParts, ".") + "." + action</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package middleware

import (
        "fmt"
        "net/http"
        "os"
        "strconv"
        "sync"

        "github.com/gin-gonic/gin"
        "golang.org/x/time/rate"
)

var (
        rlOnce     sync.Once
        rlRPS      float64
        rlBurst    int
        rlMu       sync.Mutex
        rlLimiters map[string]*rate.Limiter
)

func initLimiter() <span class="cov8" title="1">{
        rlRPS = 20.0
        rlBurst = 40
        if v := os.Getenv("ADMIN_RATE_RPS"); v != "" </span><span class="cov8" title="1">{
                if f, err := strconv.ParseFloat(v, 64); err == nil &amp;&amp; f &gt; 0 </span><span class="cov8" title="1">{
                        rlRPS = f
                }</span>
        }
        <span class="cov8" title="1">if v := os.Getenv("ADMIN_RATE_BURST"); v != "" </span><span class="cov8" title="1">{
                if i, err := strconv.Atoi(v); err == nil &amp;&amp; i &gt; 0 </span><span class="cov8" title="1">{
                        rlBurst = i
                }</span>
        }
        <span class="cov8" title="1">rlLimiters = make(map[string]*rate.Limiter)</span>
}

func getLimiter(key string) *rate.Limiter <span class="cov8" title="1">{
        rlMu.Lock()
        defer rlMu.Unlock()
        if l, ok := rlLimiters[key]; ok </span><span class="cov8" title="1">{
                return l
        }</span>
        <span class="cov8" title="1">l := rate.NewLimiter(rate.Limit(rlRPS), rlBurst)
        rlLimiters[key] = l
        return l</span>
}

// RateLimitAdmin applies a token-bucket rate limit per user or IP for admin endpoints.
func RateLimitAdmin() gin.HandlerFunc <span class="cov8" title="1">{
        rlOnce.Do(initLimiter)
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                // Prefer authenticated user id when available, else fall back to client IP
                if uid, ok := c.Get("user_id"); ok </span><span class="cov8" title="1">{
                        key := fmt.Sprintf("user:%v", uid)
                        if !getLimiter(key).Allow() </span><span class="cov8" title="1">{
                                c.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{
                                        "success": false,
                                        "code":    http.StatusTooManyRequests,
                                        "message": "rate limit exceeded",
                                })
                                return
                        }</span>
                        <span class="cov8" title="1">c.Next()
                        return</span>
                }
                <span class="cov8" title="1">key := "ip:" + c.ClientIP()
                if !getLimiter(key).Allow() </span><span class="cov8" title="1">{
                        c.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{
                                "success": false,
                                "code":    http.StatusTooManyRequests,
                                "message": "rate limit exceeded",
                        })
                        return
                }</span>
                <span class="cov8" title="1">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package middleware

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

// Recovery returns a custom JSON recovery middleware that outputs
// a unified API envelope on panic.
func Recovery() gin.HandlerFunc <span class="cov8" title="1">{
        return gin.CustomRecovery(func(c *gin.Context, recovered interface{}) </span><span class="cov8" title="1">{
                c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "code":    http.StatusInternalServerError,
                        "message": "internal server error",
                })
        }</span>)
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package middleware

import (
        "crypto/rand"
        "encoding/hex"

        "github.com/gin-gonic/gin"

        "gamelink/internal/logging"
)

// RequestID ensures every request carries an X-Request-ID, setting it on the
// response and injecting into context for downstream logging.
func RequestID() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                rid := c.GetHeader("X-Request-ID")
                if rid == "" </span><span class="cov8" title="1">{
                        rid = randomID()
                }</span>
                <span class="cov8" title="1">c.Header("X-Request-ID", rid)
                c.Set("request_id", rid)
                c.Request = c.Request.WithContext(logging.WithRequestID(c.Request.Context(), rid))
                c.Next()</span>
        }
}

func randomID() string <span class="cov8" title="1">{
        var b [16]byte
        if _, err := rand.Read(b[:]); err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(b[:])</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package middleware

import (
        "log/slog"
        "time"

        "github.com/gin-gonic/gin"
)

// SlogLogger is a structured HTTP access logger based on slog.
func SlogLogger() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                c.Next()
                dur := time.Since(start)

                status := c.Writer.Status()
                level := slog.LevelInfo
                switch </span>{
                case status &gt;= 500:<span class="cov0" title="0">
                        level = slog.LevelError</span>
                case status &gt;= 400:<span class="cov0" title="0">
                        level = slog.LevelWarn</span>
                }
                <span class="cov0" title="0">attrs := []slog.Attr{
                        slog.Int("status", status),
                        slog.String("method", c.Request.Method),
                        slog.String("path", c.FullPath()),
                        slog.String("ip", c.ClientIP()),
                        slog.String("duration", dur.String()),
                }
                if rid, ok := c.Get("request_id"); ok </span><span class="cov0" title="0">{
                        if s, ok2 := rid.(string); ok2 </span><span class="cov0" title="0">{
                                attrs = append(attrs, slog.String("request_id", s))
                        }</span>
                }
                <span class="cov0" title="0">if uid, ok := c.Get("user_id"); ok </span><span class="cov0" title="0">{
                        attrs = append(attrs, slog.Any("user_id", uid))
                }</span>
                <span class="cov0" title="0">slog.LogAttrs(c.Request.Context(), level, "http_request", attrs...)</span>
        }
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package middleware

import (
        "fmt"
        "net/http"
        "reflect"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
)

// 验证器实例
var validate = validator.New()

// ValidationError 表示验证失败的错误
type ValidationError struct {
        Field   string `json:"field"`
        Tag     string `json:"tag"`
        Message string `json:"message"`
}

// ValidateJSON 验证JSON请求体
//
// 使用方法：
// router.POST("/users", middleware.ValidateJSON(&amp;CreateUserRequest{}), createUserHandler)
//
// 技术原理：
// 1. 将请求体JSON绑定到指定的结构体
// 2. 使用validator库进行字段验证
// 3. 如果验证失败，返回详细的错误信息
// 4. 验证通过，将验证后的结构体存储到gin.Context中
func ValidateJSON(req interface{}) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                // 创建请求结构体的副本
                reqType := reflect.TypeOf(req)
                if reqType.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                        reqType = reqType.Elem()
                }</span>

                <span class="cov8" title="1">reqValue := reflect.New(reqType).Interface()

                // 绑定JSON到结构体
                if err := c.ShouldBindJSON(reqValue); err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "success": false,
                                "code":    http.StatusBadRequest,
                                "message": "无效的JSON格式: " + err.Error(),
                        })
                        c.Abort()
                        return
                }</span>

                // 执行验证
                <span class="cov8" title="1">if err := validate.Struct(reqValue); err != nil </span><span class="cov8" title="1">{
                        var validationErrors []ValidationError

                        // 处理验证错误
                        if validationErrs, ok := err.(validator.ValidationErrors); ok </span><span class="cov8" title="1">{
                                for _, e := range validationErrs </span><span class="cov8" title="1">{
                                        validationErrors = append(validationErrors, ValidationError{
                                                Field:   e.Field(),
                                                Tag:     e.Tag(),
                                                Message: getErrorMessage(e),
                                        })
                                }</span>
                        }

                        <span class="cov8" title="1">c.JSON(http.StatusBadRequest, gin.H{
                                "success": false,
                                "code":    http.StatusBadRequest,
                                "message": "输入验证失败",
                                "errors":  validationErrors,
                        })
                        c.Abort()
                        return</span>
                }

                // 将验证后的数据存储到Context中
                <span class="cov8" title="1">c.Set("validated_request", reqValue)
                c.Next()</span>
        }
}

// GetValidatedRequest 从Context中获取验证后的请求
func GetValidatedRequest(c *gin.Context, target interface{}) bool <span class="cov8" title="1">{
        if req, exists := c.Get("validated_request"); exists </span><span class="cov8" title="1">{
                reflect.ValueOf(target).Elem().Set(reflect.ValueOf(req).Elem())
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// getErrorMessage 将验证标签转换为中文错误消息
func getErrorMessage(fe validator.FieldError) string <span class="cov8" title="1">{
        field := fe.Field()
        tag := fe.Tag()

        switch tag </span>{
        case "required":<span class="cov8" title="1">
                return field + " 是必填字段"</span>
        case "min":<span class="cov8" title="1">
                return field + " 长度不能少于 " + fe.Param() + " 个字符"</span>
        case "max":<span class="cov0" title="0">
                return field + " 长度不能超过 " + fe.Param() + " 个字符"</span>
        case "email":<span class="cov8" title="1">
                return field + " 必须是有效的邮箱地址"</span>
        case "oneof":<span class="cov8" title="1">
                return field + " 必须是以下值之一: " + fe.Param()</span>
        case "numeric":<span class="cov0" title="0">
                return field + " 必须是数字"</span>
        case "alpha":<span class="cov0" title="0">
                return field + " 只能包含字母"</span>
        case "alphanum":<span class="cov0" title="0">
                return field + " 只能包含字母和数字"</span>
        default:<span class="cov8" title="1">
                return field + " 格式不正确"</span>
        }
}

// ValidateQuery 验证查询参数
func ValidateQuery(rules map[string]string) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                var errors []ValidationError

                for field, rule := range rules </span><span class="cov8" title="1">{
                        value := c.Query(field)

                        // 检查必填字段
                        if strings.Contains(rule, "required") &amp;&amp; value == "" </span><span class="cov8" title="1">{
                                errors = append(errors, ValidationError{
                                        Field:   field,
                                        Tag:     "required",
                                        Message: field + " 是必填的查询参数",
                                })
                                continue</span>
                        }

                        // 如果字段为空且不是必填，跳过其他验证
                        <span class="cov8" title="1">if value == "" </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        // 检查长度限制
                        <span class="cov8" title="1">if strings.Contains(rule, "min:") </span><span class="cov8" title="1">{
                                minLen := 0
                                if n, err := fmt.Sscanf(strings.TrimPrefix(rule, "min:"), "%d", &amp;minLen); err == nil &amp;&amp; n == 1 </span><span class="cov8" title="1">{
                                        if len(value) &lt; minLen </span><span class="cov8" title="1">{
                                                errors = append(errors, ValidationError{
                                                        Field:   field,
                                                        Tag:     "min",
                                                        Message: field + " 长度不能少于 " + fmt.Sprintf("%d", minLen) + " 个字符",
                                                })
                                        }</span>
                                }
                        }
                }

                <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov8" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "success": false,
                                "code":    http.StatusBadRequest,
                                "message": "查询参数验证失败",
                                "errors":  errors,
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">c.Next()</span>
        }
}

// 自定义验证函数
func init() <span class="cov8" title="1">{
        // 注册自定义验证规则
        _ = validate.RegisterValidation("phone", validatePhone)
        _ = validate.RegisterValidation("password", validatePassword)
}</span>

// validatePhone 验证手机号格式
func validatePhone(fl validator.FieldLevel) bool <span class="cov8" title="1">{
        phone := fl.Field().String()
        // 简单的中国手机号验证：1开头，第二位3-9，总共11位数字
        if len(phone) != 11 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if phone[0] != '1' </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if phone[1] &lt; '3' || phone[1] &gt; '9' </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for _, c := range phone </span><span class="cov8" title="1">{
                if c &lt; '0' || c &gt; '9' </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// validatePassword 验证密码强度
func validatePassword(fl validator.FieldLevel) bool <span class="cov8" title="1">{
        password := fl.Field().String()
        if len(password) &lt; 8 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">hasNumber := false
        hasLetter := false
        hasSpecial := false
        for _, c := range password </span><span class="cov8" title="1">{
                switch </span>{
                case c &gt;= '0' &amp;&amp; c &lt;= '9':<span class="cov8" title="1">
                        hasNumber = true</span>
                case (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z'):<span class="cov8" title="1">
                        hasLetter = true</span>
                default:<span class="cov8" title="1">
                        hasSpecial = true</span>
                }
        }
        <span class="cov8" title="1">return hasNumber &amp;&amp; hasLetter &amp;&amp; hasSpecial</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package player

import (
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"

        "gamelink/internal/model"
        "gamelink/internal/service/commission"
)

// RegisterCommissionRoutes 注册陪玩师端抽成管理路由
func RegisterCommissionRoutes(router gin.IRouter, svc *commission.CommissionService, authMiddleware gin.HandlerFunc) <span class="cov0" title="0">{
        group := router.Group("/player/commission")
        group.Use(authMiddleware) // 需要认�?
        </span><span class="cov0" title="0">{
                group.GET("/summary", func(c *gin.Context) </span><span class="cov0" title="0">{ getCommissionSummaryHandler(c, svc) }</span>)
                <span class="cov0" title="0">group.GET("/records", func(c *gin.Context) </span><span class="cov0" title="0">{ getCommissionRecordsHandler(c, svc) }</span>)
                <span class="cov0" title="0">group.GET("/settlements", func(c *gin.Context) </span><span class="cov0" title="0">{ getMonthlySettlementsHandler(c, svc) }</span>)
        }
}

// getCommissionSummaryHandler 获取抽成汇�?
// @Summary      获取抽成汇�?
// @Description  获取陪玩师抽成收入汇�?
// @Tags         Player - Commission
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Param        month          query     string  true  "月份 (YYYY-MM)"
// @Success      200            {object}  model.APIResponse[commission.CommissionSummaryResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /player/commission/summary [get]
func getCommissionSummaryHandler(c *gin.Context, svc *commission.CommissionService) <span class="cov0" title="0">{
        userID := getUserIDFromContext(c)

        // 获取月份参数，默认当前月
        month := c.DefaultQuery("month", time.Now().Format("2006-01"))

        // 查找该用户的陪玩师ID
        playerID, err := getPlayerIDByUserID(c, userID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusNotFound, "Player not found")
                return
        }</span>

        <span class="cov0" title="0">resp, err := svc.GetPlayerCommissionSummary(c.Request.Context(), playerID, month)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">respondJSON(c, http.StatusOK, model.APIResponse[commission.CommissionSummaryResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *resp,
        })</span>
}

// getCommissionRecordsHandler 获取抽成记录
// @Summary      获取抽成记录
// @Description  获取陪玩师抽成记录列�?
// @Tags         Player - Commission
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        page           query     int     false  "页码"
// @Param        pageSize       query     int     false  "每页数量"
// @Success      200            {object}  model.APIResponse[commission.CommissionRecordListResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /player/commission/records [get]
func getCommissionRecordsHandler(c *gin.Context, svc *commission.CommissionService) <span class="cov0" title="0">{
        userID := getUserIDFromContext(c)

        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        pageSize, _ := strconv.Atoi(c.DefaultQuery("pageSize", "20"))

        // 查找该用户的陪玩师ID
        playerID, err := getPlayerIDByUserID(c, userID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusNotFound, "Player not found")
                return
        }</span>

        <span class="cov0" title="0">resp, err := svc.GetCommissionRecords(c.Request.Context(), playerID, page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">respondJSON(c, http.StatusOK, model.APIResponse[commission.CommissionRecordListResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *resp,
        })</span>
}

// getMonthlySettlementsHandler 获取月度结算记录
// @Summary      获取月度结算记录
// @Description  获取陪玩师月度结算记�?
// @Tags         Player - Commission
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        page           query     int     false  "页码"
// @Param        pageSize       query     int     false  "每页数量"
// @Success      200            {object}  model.APIResponse[commission.SettlementListResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /player/commission/settlements [get]
func getMonthlySettlementsHandler(c *gin.Context, svc *commission.CommissionService) <span class="cov0" title="0">{
        userID := getUserIDFromContext(c)

        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        pageSize, _ := strconv.Atoi(c.DefaultQuery("pageSize", "20"))

        // 查找该用户的陪玩师ID
        playerID, err := getPlayerIDByUserID(c, userID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusNotFound, "Player not found")
                return
        }</span>

        <span class="cov0" title="0">resp, err := svc.GetMonthlySettlements(c.Request.Context(), playerID, page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">respondJSON(c, http.StatusOK, model.APIResponse[commission.SettlementListResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *resp,
        })</span>
}

// getPlayerIDByUserID 根据用户ID获取陪玩师ID
func getPlayerIDByUserID(c *gin.Context, userID uint64) (uint64, error) <span class="cov0" title="0">{
        // TODO: 优化这个查询，可以在用户上下文中缓存playerID
        // 这里简化处理，实际应该从service层获�?
        // 暂时返回userID作为playerID（需要后续完善）
        return userID, nil
}</span>

</pre>
		
		<pre class="file" id="file48" style="display: none">package player

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"

        "gamelink/internal/apierr"
        "gamelink/internal/model"
        "gamelink/internal/service/earnings"
)

// RegisterEarningsRoutes 注册陪玩师端收益管理路由
func RegisterEarningsRoutes(router gin.IRouter, svc *earnings.EarningsService, authMiddleware gin.HandlerFunc) <span class="cov0" title="0">{
    group := router.Group("/player/earnings")
    group.Use(authMiddleware) // 需要认证
    group.GET("/summary", func(c *gin.Context) </span><span class="cov0" title="0">{ getEarningsSummaryHandler(c, svc) }</span>)
    <span class="cov0" title="0">group.GET("/trend", func(c *gin.Context) </span><span class="cov0" title="0">{ getEarningsTrendHandler(c, svc) }</span>)
    <span class="cov0" title="0">group.POST("/withdraw", func(c *gin.Context) </span><span class="cov0" title="0">{ requestWithdrawHandler(c, svc) }</span>)
    <span class="cov0" title="0">group.GET("/withdraw-history", func(c *gin.Context) </span><span class="cov0" title="0">{ getWithdrawHistoryHandler(c, svc) }</span>)
}

// getEarningsSummaryHandler 获取收益概览
// @Summary      获取收益概览
// @Description  获取陪玩师收益概览
// @Tags         Player - Earnings
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Success      200            {object}  model.APIResponse[earnings.EarningsSummaryResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /player/earnings/summary [get]
func getEarningsSummaryHandler(c *gin.Context, svc *earnings.EarningsService) <span class="cov8" title="1">{
        userID := getUserIDFromContext(c)

        resp, err := svc.GetEarningsSummary(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[earnings.EarningsSummaryResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *resp,
        })</span>
}

// getEarningsTrendHandler 获取收益趋势
// @Summary      获取收益趋势
// @Description  获取陪玩师收益趋�?// @Tags         Player - Earnings
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Param        days           query     int     true  "天数�?/30/90�?
// @Success      200            {object}  model.APIResponse[earnings.EarningsTrendResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /player/earnings/trend [get]
func getEarningsTrendHandler(c *gin.Context, svc *earnings.EarningsService) <span class="cov8" title="1">{
        userID := getUserIDFromContext(c)

        days, err := strconv.Atoi(c.Query("days"))
        if err != nil || days &lt; 7 || days &gt; 90 </span><span class="cov8" title="1">{
                respondError(c, http.StatusBadRequest, apierr.ErrMissingRequiredFields)
                return
        }</span>

        <span class="cov8" title="1">resp, err := svc.GetEarningsTrend(c.Request.Context(), userID, days)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[earnings.EarningsTrendResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *resp,
        })</span>
}

// requestWithdrawHandler 申请提现
// @Summary      申请提现
// @Description  申请提现
// @Tags         Player - Earnings
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string                     true  "Bearer {token}"
// @Param        request        body      earnings.WithdrawRequest   true  "提现信息"
// @Success      200            {object}  model.APIResponse[earnings.WithdrawResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /player/earnings/withdraw [post]
func requestWithdrawHandler(c *gin.Context, svc *earnings.EarningsService) <span class="cov8" title="1">{
        userID := getUserIDFromContext(c)

        var req earnings.WithdrawRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                respondError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov8" title="1">resp, err := svc.RequestWithdraw(c.Request.Context(), userID, req)
        if err != nil </span><span class="cov0" title="0">{
                if err == earnings.ErrInsufficientBalance </span><span class="cov0" title="0">{
                        respondError(c, http.StatusBadRequest, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">respondError(c, http.StatusInternalServerError, err.Error())
                return</span>
        }

        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[earnings.WithdrawResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "提现申请已提交",
                Data:    *resp,
        })</span>
}

// getWithdrawHistoryHandler 获取提现记录
// @Summary      获取提现记录
// @Description  获取提现记录
// @Tags         Player - Earnings
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        page           query     int     false  "页码"
// @Param        pageSize       query     int     false  "每页数量"
// @Success      200            {object}  model.APIResponse[earnings.WithdrawHistoryResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /player/earnings/withdraw-history [get]
func getWithdrawHistoryHandler(c *gin.Context, svc *earnings.EarningsService) <span class="cov8" title="1">{
        userID := getUserIDFromContext(c)

        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        pageSize, _ := strconv.Atoi(c.DefaultQuery("pageSize", "20"))

        resp, err := svc.GetWithdrawHistory(c.Request.Context(), userID, page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[earnings.WithdrawHistoryResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *resp,
        })</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package player

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"

        "gamelink/internal/model"
        "gamelink/internal/service/gift"
)

// RegisterGiftRoutes 注册陪玩师端礼物路由
func RegisterGiftRoutes(router gin.IRouter, svc *gift.GiftService, authMiddleware gin.HandlerFunc) <span class="cov0" title="0">{
        group := router.Group("/player/gifts")
        group.Use(authMiddleware)
        </span><span class="cov0" title="0">{
                group.GET("/received", func(c *gin.Context) </span><span class="cov0" title="0">{ getReceivedGiftsHandler(c, svc) }</span>)
                <span class="cov0" title="0">group.GET("/stats", func(c *gin.Context) </span><span class="cov0" title="0">{ getGiftStatsHandler(c, svc) }</span>)
        }
}

// getReceivedGiftsHandler 获取收到的礼�?
// @Summary      获取收到的礼�?
// @Description  陪玩师查看收到的礼物列表
// @Tags         Player - Gift
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        page           query     int     false  "页码"
// @Param        pageSize       query     int     false  "每页数量"
// @Success      200            {object}  model.APIResponse[gift.ReceivedGiftsResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /player/gifts/received [get]
func getReceivedGiftsHandler(c *gin.Context, svc *gift.GiftService) <span class="cov0" title="0">{
        userID := getUserIDFromContext(c)
        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        pageSize, _ := strconv.Atoi(c.DefaultQuery("pageSize", "20"))

        // TODO: 需要从userID获取playerID
        // 暂时使用userID作为playerID
        playerID := userID

        resp, err := svc.GetPlayerReceivedGifts(c.Request.Context(), playerID, page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">respondJSON(c, http.StatusOK, model.APIResponse[gift.ReceivedGiftsResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *resp,
        })</span>
}

// getGiftStatsHandler 获取礼物统计
// @Summary      获取礼物统计
// @Description  陪玩师查看礼物收入统�?
// @Tags         Player - Gift
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Success      200            {object}  model.APIResponse[gift.GiftStatsResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /player/gifts/stats [get]
func getGiftStatsHandler(c *gin.Context, svc *gift.GiftService) <span class="cov0" title="0">{
        userID := getUserIDFromContext(c)

        // TODO: 需要从userID获取playerID
        playerID := userID

        resp, err := svc.GetGiftStats(c.Request.Context(), playerID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">respondJSON(c, http.StatusOK, model.APIResponse[gift.GiftStatsResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *resp,
        })</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package player

import (
    "github.com/gin-gonic/gin"
    "gamelink/internal/model"
)

// 本包内通用的响应封装
func respondJSON[T any](c *gin.Context, status int, payload model.APIResponse[T]) <span class="cov8" title="1">{
    c.JSON(status, payload)
}</span>

func respondError(c *gin.Context, status int, msg string) <span class="cov8" title="1">{
    respondJSON(c, status, model.APIResponse[any]{
        Success: false,
        Code:    status,
        Message: msg,
    })
}</span>

// 从上下文获取用户ID（由JWT中间件写入）
func getUserIDFromContext(c *gin.Context) uint64 <span class="cov8" title="1">{
    userIDVal, exists := c.Get("user_id")
    if !exists </span><span class="cov0" title="0">{
        return 0
    }</span>
    <span class="cov8" title="1">userID, ok := userIDVal.(uint64)
    if !ok </span><span class="cov0" title="0">{
        return 0
    }</span>
    <span class="cov8" title="1">return userID</span>
}</pre>
		
		<pre class="file" id="file51" style="display: none">package player

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"

        "gamelink/internal/apierr"
        "gamelink/internal/model"
        "gamelink/internal/service/order"
)

// RegisterOrderRoutes 注册陪玩师端订单管理路由
func RegisterOrderRoutes(router gin.IRouter, svc *order.OrderService, authMiddleware gin.HandlerFunc) <span class="cov0" title="0">{
    group := router.Group("/player/orders")
    group.Use(authMiddleware) // 需要认证
    group.GET("/available", func(c *gin.Context) </span><span class="cov0" title="0">{ getAvailableOrdersHandler(c, svc) }</span>)
    <span class="cov0" title="0">group.POST("/:id/accept", func(c *gin.Context) </span><span class="cov0" title="0">{ acceptOrderHandler(c, svc) }</span>)
    <span class="cov0" title="0">group.GET("/my", func(c *gin.Context) </span><span class="cov0" title="0">{ getMyAcceptedOrdersHandler(c, svc) }</span>)
    <span class="cov0" title="0">group.PUT("/:id/complete", func(c *gin.Context) </span><span class="cov0" title="0">{ completeOrderByPlayerHandler(c, svc) }</span>)
}

// getAvailableOrdersHandler 获取可接订单列表
// @Summary      获取可接订单列表
// @Description  获取订单大厅的可接订单列表
// @Tags         Player - Orders
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        gameId         query     int     false  "游戏ID"
// @Param        page           query     int     false  "页码"
// @Param        pageSize       query     int     false  "每页数量"
// @Success      200            {object}  model.APIResponse[map[string]any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /player/orders/available [get]
func getAvailableOrdersHandler(c *gin.Context, svc *order.OrderService) <span class="cov8" title="1">{
        var req order.AvailableOrdersRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov8" title="1">orders, total, err := svc.GetAvailableOrders(c.Request.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[map[string]any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data: map[string]any{
                        "orders": orders,
                        "total":  total,
                },
        })</span>
}

// acceptOrderHandler 接单
// @Summary      接单
// @Description  陪玩师接�?// @Tags         Player - Orders
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Param        id             path      int     true  "订单ID"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /player/orders/{id}/accept [post]
func acceptOrderHandler(c *gin.Context, svc *order.OrderService) <span class="cov8" title="1">{
        userID := getUserIDFromContext(c)

        idStr := c.Param("id")
        orderID, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                respondError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>

        <span class="cov8" title="1">if err := svc.AcceptOrder(c.Request.Context(), userID, orderID); err != nil </span><span class="cov0" title="0">{
                if err == order.ErrInvalidTransition </span><span class="cov0" title="0">{
                        respondError(c, http.StatusBadRequest, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">respondError(c, http.StatusInternalServerError, err.Error())
                return</span>
        }

        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "接单成功",
        })</span>
}

// getMyAcceptedOrdersHandler 获取我接的订�?// @Summary      获取我接的订�?// @Description  获取陪玩师接的订单列�?// @Tags         Player - Orders
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        status         query     string  false  "订单状�?
// @Param        page           query     int     false  "页码"
// @Param        pageSize       query     int     false  "每页数量"
// @Success      200            {object}  model.APIResponse[order.MyOrderListResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /player/orders/my [get]
func getMyAcceptedOrdersHandler(c *gin.Context, svc *order.OrderService) <span class="cov8" title="1">{
        userID := getUserIDFromContext(c)

        var req order.MyOrderListRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov8" title="1">resp, err := svc.GetMyOrders(c.Request.Context(), userID, req)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[order.MyOrderListResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *resp,
        })</span>
}

// completeOrderByPlayerHandler 完成订单（陪玩师端）
// @Summary      完成订单
// @Description  陪玩师完成订�?// @Tags         Player - Orders
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Param        id             path      int     true  "订单ID"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /player/orders/{id}/complete [put]
func completeOrderByPlayerHandler(c *gin.Context, svc *order.OrderService) <span class="cov8" title="1">{
        userID := getUserIDFromContext(c)

        idStr := c.Param("id")
        orderID, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                respondError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>

        <span class="cov8" title="1">if err := svc.CompleteOrderByPlayer(c.Request.Context(), userID, orderID); err != nil </span><span class="cov0" title="0">{
                if err == order.ErrUnauthorized </span><span class="cov0" title="0">{
                        respondError(c, http.StatusForbidden, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">if err == order.ErrInvalidTransition </span><span class="cov0" title="0">{
                        respondError(c, http.StatusBadRequest, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">respondError(c, http.StatusInternalServerError, err.Error())
                return</span>
        }

        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "订单已完成",
        })</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package player

import (
        "net/http"

        "github.com/gin-gonic/gin"

        "gamelink/internal/model"
        "gamelink/internal/service/player"
)

// RegisterProfileRoutes 注册陪玩师端资料管理路由
func RegisterProfileRoutes(router gin.IRouter, svc *player.PlayerService, authMiddleware gin.HandlerFunc) <span class="cov0" title="0">{
    group := router.Group("/player")
    group.Use(authMiddleware) // 需要认证
    group.POST("/apply", func(c *gin.Context) </span><span class="cov0" title="0">{ applyAsPlayerHandler(c, svc) }</span>)
    <span class="cov0" title="0">group.GET("/profile", func(c *gin.Context) </span><span class="cov0" title="0">{ getPlayerProfileHandler(c, svc) }</span>)
    <span class="cov0" title="0">group.PUT("/profile", func(c *gin.Context) </span><span class="cov0" title="0">{ updatePlayerProfileHandler(c, svc) }</span>)
    <span class="cov0" title="0">group.PUT("/status", func(c *gin.Context) </span><span class="cov0" title="0">{ setPlayerStatusHandler(c, svc) }</span>)
}

// applyAsPlayerHandler 申请成为陪玩�?// @Summary      申请成为陪玩�?// @Description  用户申请成为陪玩�?// @Tags         Player - Profile
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string                       true  "Bearer {token}"
// @Param        request        body      player.ApplyPlayerRequest    true  "申请信息"
// @Success      200            {object}  model.APIResponse[player.ApplyPlayerResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /player/apply [post]
func applyAsPlayerHandler(c *gin.Context, svc *player.PlayerService) <span class="cov8" title="1">{
        userID := getUserIDFromContext(c)

        var req player.ApplyPlayerRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                respondError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov8" title="1">resp, err := svc.ApplyAsPlayer(c.Request.Context(), userID, req)
        if err != nil </span><span class="cov8" title="1">{
                if err == player.ErrAlreadyPlayer </span><span class="cov8" title="1">{
                        respondError(c, http.StatusBadRequest, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">respondError(c, http.StatusInternalServerError, err.Error())
                return</span>
        }

        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[player.ApplyPlayerResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "申请提交成功",
                Data:    *resp,
        })</span>
}

// getPlayerProfileHandler 获取陪玩师资�?// @Summary      获取陪玩师资�?// @Description  获取当前用户的陪玩师资料
// @Tags         Player - Profile
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Success      200            {object}  model.APIResponse[player.PlayerDetailResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Failure      404            {object}  model.APIResponse[any]
// @Router       /player/profile [get]
func getPlayerProfileHandler(c *gin.Context, svc *player.PlayerService) <span class="cov8" title="1">{
        userID := getUserIDFromContext(c)

        resp, err := svc.GetPlayerProfile(c.Request.Context(), userID)
        if err != nil </span><span class="cov8" title="1">{
                if err == player.ErrNotFound </span><span class="cov8" title="1">{
                        respondError(c, http.StatusNotFound, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">respondError(c, http.StatusInternalServerError, err.Error())
                return</span>
        }

        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[player.PlayerDetailResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *resp,
        })</span>
}

// updatePlayerProfileHandler 更新陪玩师资�?// @Summary      更新陪玩师资�?// @Description  更新陪玩师资�?// @Tags         Player - Profile
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string                              true  "Bearer {token}"
// @Param        request        body      player.UpdatePlayerProfileRequest   true  "更新信息"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /player/profile [put]
func updatePlayerProfileHandler(c *gin.Context, svc *player.PlayerService) <span class="cov8" title="1">{
        userID := getUserIDFromContext(c)

        var req player.UpdatePlayerProfileRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                respondError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := svc.UpdatePlayerProfile(c.Request.Context(), userID, req); err != nil </span><span class="cov0" title="0">{
                if err == player.ErrNotFound </span><span class="cov0" title="0">{
                        respondError(c, http.StatusNotFound, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">respondError(c, http.StatusInternalServerError, err.Error())
                return</span>
        }

        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "资料更新成功",
        })</span>
}

// setPlayerStatusHandler 设置在线状�?// @Summary      设置在线状�?// @Description  设置陪玩师在�?离线状�?// @Tags         Player - Profile
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string                          true  "Bearer {token}"
// @Param        request        body      player.SetPlayerStatusRequest   true  "在线状�?
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /player/status [put]
func setPlayerStatusHandler(c *gin.Context, svc *player.PlayerService) <span class="cov8" title="1">{
        userID := getUserIDFromContext(c)

        var req player.SetPlayerStatusRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                respondError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := svc.SetPlayerOnlineStatus(c.Request.Context(), userID, req.Online); err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "状态更新成功",
        })</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package handler

import "github.com/gin-gonic/gin"

// RegisterRoot 注册根路径路由。
func RegisterRoot(router gin.IRoutes) <span class="cov0" title="0">{
        router.GET("/", rootIndex)
}</span>

func rootIndex(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(200, gin.H{
                "message": "GameLink API",
                "endpoints": []string{
                        "/swagger",
                        "/swagger.json",
                        "/healthz",
                        "/api/v1/",
                        "/api/v1/healthz",
                        "/api/v1/admin/games",
                        "/api/v1/admin/users",
                        "/api/v1/admin/players",
                        "/api/v1/admin/orders",
                        "/api/v1/admin/payments",
                },
        })
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package handler

import (
        _ "embed"

        "github.com/gin-gonic/gin"
)

//go:embed swagger/index.html
var swaggerHTML []byte

//go:embed swagger/openapi.json
var swaggerJSON []byte

// RegisterSwagger 注册 Swagger UI 与文档路由。
func RegisterSwagger(router gin.IRoutes) <span class="cov0" title="0">{
        router.GET("/swagger", SwaggerUI)
        router.GET("/swagger.json", SwaggerSpec)
}</span>

// SwaggerUI 提供内嵌的 Swagger UI 页面。
func SwaggerUI(c *gin.Context) <span class="cov0" title="0">{
        c.Data(200, "text/html; charset=utf-8", swaggerHTML)
}</span>

// SwaggerSpec 返回当前服务的 OpenAPI 描述。
func SwaggerSpec(c *gin.Context) <span class="cov0" title="0">{
        c.Data(200, "application/json", swaggerJSON)
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package user

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"

    "gamelink/internal/model"
    "gamelink/internal/service/gift"
    "gamelink/internal/service/item"
)

// RegisterGiftRoutes Register user gift routes
func RegisterGiftRoutes(router gin.IRouter, giftSvc *gift.GiftService, itemSvc *item.ServiceItemService, authMiddleware gin.HandlerFunc) <span class="cov0" title="0">{
        group := router.Group("/user/gifts")
        group.Use(authMiddleware)
        </span><span class="cov0" title="0">{
                group.GET("", func(c *gin.Context) </span><span class="cov0" title="0">{ listGiftsHandler(c, itemSvc) }</span>)
                <span class="cov0" title="0">group.POST("/send", func(c *gin.Context) </span><span class="cov0" title="0">{ sendGiftHandler(c, giftSvc) }</span>)
                <span class="cov0" title="0">group.GET("/sent", func(c *gin.Context) </span><span class="cov0" title="0">{ getSentGiftsHandler(c, giftSvc) }</span>)
        }
}

// listGiftsHandler 获取礼物列表
// @Summary      获取礼物列表
// @Description  用户浏览可赠送的礼物
// @Tags         User - Gift
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        page           query     int     false  "页码"
// @Param        pageSize       query     int     false  "每页数量"
// @Success      200            {object}  model.APIResponse[serviceitem.ServiceItemListResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /user/gifts [get]
func listGiftsHandler(c *gin.Context, svc *item.ServiceItemService) <span class="cov0" title="0">{
        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        pageSize, _ := strconv.Atoi(c.DefaultQuery("pageSize", "20"))

        resp, err := svc.GetGiftList(c.Request.Context(), page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

    <span class="cov0" title="0">respondJSON(c, http.StatusOK, model.APIResponse[item.ServiceItemListResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *resp,
        })</span>
}

// sendGiftHandler 赠送礼�?
// @Summary      赠送礼�?
// @Description  用户给陪玩师赠送礼�?
// @Tags         User - Gift
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string                  true  "Bearer {token}"
// @Param        request        body      gift.SendGiftRequest  true  "赠送礼物请�?
// @Success      200            {object}  model.APIResponse[gift.GiftOrderResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /user/gifts/send [post]
func sendGiftHandler(c *gin.Context, svc *gift.GiftService) <span class="cov0" title="0">{
        userID := getUserIDFromContext(c)

        var req gift.SendGiftRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">resp, err := svc.SendGift(c.Request.Context(), userID, req)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">respondJSON(c, http.StatusOK, model.APIResponse[gift.GiftOrderResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "Gift sent successfully",
                Data:    *resp,
        })</span>
}

// getSentGiftsHandler 获取已赠送的礼物记录
// @Summary      获取已赠送的礼物记录
// @Description  用户查看自己赠送的礼物记录
// @Tags         User - Gift
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        page           query     int     false  "页码"
// @Param        pageSize       query     int     false  "每页数量"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /user/gifts/sent [get]
func getSentGiftsHandler(c *gin.Context, svc *gift.GiftService) <span class="cov0" title="0">{
        userID := getUserIDFromContext(c)
        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        pageSize, _ := strconv.Atoi(c.DefaultQuery("pageSize", "20"))

        // TODO: 实现获取用户赠送的礼物记录
        _ = userID
        _ = page
        _ = pageSize

        respondJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    map[string]interface{}{"gifts": []interface{}{}, "total": 0},
        })
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package user

import (
    "github.com/gin-gonic/gin"
    "gamelink/internal/model"
)

// 本包内通用的响应封装
func respondJSON[T any](c *gin.Context, status int, payload model.APIResponse[T]) <span class="cov8" title="1">{
    c.JSON(status, payload)
}</span>

func respondError(c *gin.Context, status int, msg string) <span class="cov8" title="1">{
    respondJSON(c, status, model.APIResponse[any]{
        Success: false,
        Code:    status,
        Message: msg,
    })
}</pre>
		
		<pre class="file" id="file57" style="display: none">package user

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"

        "gamelink/internal/apierr"
        "gamelink/internal/model"
        "gamelink/internal/service/order"
)

// RegisterOrderRoutes 注册用户端订单路由
func RegisterOrderRoutes(router gin.IRouter, svc *order.OrderService, authMiddleware gin.HandlerFunc) <span class="cov8" title="1">{
    group := router.Group("/user/orders")
    group.Use(authMiddleware) // 需要认证
    group.POST("", func(c *gin.Context) </span><span class="cov0" title="0">{ createOrderHandler(c, svc) }</span>)
    <span class="cov8" title="1">group.GET("", func(c *gin.Context) </span><span class="cov0" title="0">{ getMyOrdersHandler(c, svc) }</span>)
    <span class="cov8" title="1">group.GET("/:id", func(c *gin.Context) </span><span class="cov8" title="1">{ getOrderDetailHandler(c, svc) }</span>)
    <span class="cov8" title="1">group.PUT("/:id/cancel", func(c *gin.Context) </span><span class="cov0" title="0">{ cancelOrderHandler(c, svc) }</span>)
    <span class="cov8" title="1">group.PUT("/:id/complete", func(c *gin.Context) </span><span class="cov0" title="0">{ completeOrderHandler(c, svc) }</span>)
}

// createOrderHandler 创建订单
// @Summary      创建订单
// @Description  用户创建陪玩订单
// @Tags         User - Orders
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string                       true  "Bearer {token}"
// @Param        request        body      order.CreateOrderRequest     true  "创建订单请求"
// @Success      200            {object}  model.APIResponse[order.CreateOrderResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /user/orders [post]
func createOrderHandler(c *gin.Context, svc *order.OrderService) <span class="cov0" title="0">{
        userID := getUserIDFromContext(c)

        var req order.CreateOrderRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">resp, err := svc.CreateOrder(c.Request.Context(), userID, req)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">respondJSON(c, http.StatusOK, model.APIResponse[order.CreateOrderResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "订单创建成功",
                Data:    *resp,
        })</span>
}

// getMyOrdersHandler 获取我的订单列表
// @Summary      获取我的订单列表
// @Description  获取当前用户的订单列�?// @Tags         User - Orders
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        status         query     string  false  "订单状�?
// @Param        page           query     int     false  "页码"
// @Param        pageSize       query     int     false  "每页数量"
// @Success      200            {object}  model.APIResponse[order.MyOrderListResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /user/orders [get]
func getMyOrdersHandler(c *gin.Context, svc *order.OrderService) <span class="cov0" title="0">{
        userID := getUserIDFromContext(c)

        var req order.MyOrderListRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">resp, err := svc.GetMyOrders(c.Request.Context(), userID, req)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">respondJSON(c, http.StatusOK, model.APIResponse[order.MyOrderListResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *resp,
        })</span>
}

// getOrderDetailHandler 获取订单详情
// @Summary      获取订单详情
// @Description  获取订单详细信息
// @Tags         User - Orders
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Param        id             path      int     true  "订单ID"
// @Success      200            {object}  model.APIResponse[order.OrderDetailResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Failure      404            {object}  model.APIResponse[any]
// @Router       /user/orders/{id} [get]
func getOrderDetailHandler(c *gin.Context, svc *order.OrderService) <span class="cov8" title="1">{
        userID := getUserIDFromContext(c)

        idStr := c.Param("id")
        orderID, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                respondError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>

        <span class="cov8" title="1">resp, err := svc.GetOrderDetail(c.Request.Context(), userID, orderID)
        if err != nil </span><span class="cov8" title="1">{
                if err == order.ErrNotFound </span><span class="cov8" title="1">{
                        respondError(c, http.StatusNotFound, err.Error())
                        return
                }</span>
                <span class="cov8" title="1">if err == order.ErrUnauthorized </span><span class="cov8" title="1">{
                        respondError(c, http.StatusForbidden, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">respondError(c, http.StatusInternalServerError, err.Error())
                return</span>
        }

        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[order.OrderDetailResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *resp,
        })</span>
}

// cancelOrderHandler 取消订单
// @Summary      取消订单
// @Description  用户取消订单
// @Tags         User - Orders
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string                     true  "Bearer {token}"
// @Param        id             path      int                        true  "订单ID"
// @Param        request        body      order.CancelOrderRequest   true  "取消原因"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /user/orders/{id}/cancel [put]
func cancelOrderHandler(c *gin.Context, svc *order.OrderService) <span class="cov0" title="0">{
        userID := getUserIDFromContext(c)

        idStr := c.Param("id")
        orderID, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>

        <span class="cov0" title="0">var req order.CancelOrderRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">if err := svc.CancelOrder(c.Request.Context(), userID, orderID, req); err != nil </span><span class="cov0" title="0">{
                if err == order.ErrUnauthorized </span><span class="cov0" title="0">{
                        respondError(c, http.StatusForbidden, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">if err == order.ErrInvalidTransition </span><span class="cov0" title="0">{
                        respondError(c, http.StatusBadRequest, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">respondError(c, http.StatusInternalServerError, err.Error())
                return</span>
        }

        <span class="cov0" title="0">respondJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "订单已取消",
        })</span>
}

// completeOrderHandler 完成订单
// @Summary      完成订单
// @Description  用户确认订单完成
// @Tags         User - Orders
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Param        id             path      int     true  "订单ID"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /user/orders/{id}/complete [put]
func completeOrderHandler(c *gin.Context, svc *order.OrderService) <span class="cov0" title="0">{
        userID := getUserIDFromContext(c)

        idStr := c.Param("id")
        orderID, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>

        <span class="cov0" title="0">if err := svc.CompleteOrder(c.Request.Context(), userID, orderID); err != nil </span><span class="cov0" title="0">{
                if err == order.ErrUnauthorized </span><span class="cov0" title="0">{
                        respondError(c, http.StatusForbidden, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">if err == order.ErrInvalidTransition </span><span class="cov0" title="0">{
                        respondError(c, http.StatusBadRequest, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">respondError(c, http.StatusInternalServerError, err.Error())
                return</span>
        }

        <span class="cov0" title="0">respondJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "订单已完成",
        })</span>
}

// getUserIDFromContext 从上下文获取用户ID
func getUserIDFromContext(c *gin.Context) uint64 <span class="cov8" title="1">{
    // 从 JWT 中间件设置的上下文中获取用户ID
        userIDVal, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">userID, ok := userIDVal.(uint64)
        if !ok </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return userID</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package user

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"

        "gamelink/internal/apierr"
        "gamelink/internal/model"
        "gamelink/internal/service/payment"
)

// RegisterPaymentRoutes 注册用户端支付路由
func RegisterPaymentRoutes(router gin.IRouter, svc *payment.PaymentService, authMiddleware gin.HandlerFunc) <span class="cov0" title="0">{
    group := router.Group("/user/payments")
    group.Use(authMiddleware) // 需要认证
    group.POST("", func(c *gin.Context) </span><span class="cov0" title="0">{ createPaymentHandler(c, svc) }</span>)
    <span class="cov0" title="0">group.GET("/:id", func(c *gin.Context) </span><span class="cov0" title="0">{ getPaymentStatusHandler(c, svc) }</span>)
    <span class="cov0" title="0">group.POST("/:id/cancel", func(c *gin.Context) </span><span class="cov0" title="0">{ cancelPaymentHandler(c, svc) }</span>)
}

// createPaymentHandler 创建支付
// @Summary      创建支付
// @Description  为订单创建支付
// @Tags         User - Payments
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string                          true  "Bearer {token}"
// @Param        request        body      payment.CreatePaymentRequest    true  "创建支付请求"
// @Success      200            {object}  model.APIResponse[payment.CreatePaymentResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /user/payments [post]
func createPaymentHandler(c *gin.Context, svc *payment.PaymentService) <span class="cov8" title="1">{
        userID := getUserIDFromContext(c)

        var req payment.CreatePaymentRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                respondError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov8" title="1">resp, err := svc.CreatePayment(c.Request.Context(), userID, req)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[payment.CreatePaymentResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "支付创建成功",
                Data:    *resp,
        })</span>
}

// getPaymentStatusHandler 查询支付状�?// @Summary      查询支付状�?// @Description  查询支付状�?// @Tags         User - Payments
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Param        id             path      int     true  "支付ID"
// @Success      200            {object}  model.APIResponse[payment.PaymentStatusResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Failure      404            {object}  model.APIResponse[any]
// @Router       /user/payments/{id} [get]
func getPaymentStatusHandler(c *gin.Context, svc *payment.PaymentService) <span class="cov8" title="1">{
        idStr := c.Param("id")
        paymentID, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                respondError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>

        <span class="cov8" title="1">resp, err := svc.GetPaymentStatus(c.Request.Context(), paymentID)
        if err != nil </span><span class="cov8" title="1">{
                if err == payment.ErrNotFound </span><span class="cov8" title="1">{
                        respondError(c, http.StatusNotFound, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">respondError(c, http.StatusInternalServerError, err.Error())
                return</span>
        }

        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[payment.PaymentStatusResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *resp,
        })</span>
}

// cancelPaymentHandler 取消支付
// @Summary      取消支付
// @Description  取消支付
// @Tags         User - Payments
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true  "Bearer {token}"
// @Param        id             path      int     true  "支付ID"
// @Success      200            {object}  model.APIResponse[any]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /user/payments/{id}/cancel [post]
func cancelPaymentHandler(c *gin.Context, svc *payment.PaymentService) <span class="cov8" title="1">{
        userID := getUserIDFromContext(c)

        idStr := c.Param("id")
        paymentID, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                respondError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>

        <span class="cov8" title="1">if err := svc.CancelPayment(c.Request.Context(), userID, paymentID); err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[any]{
                Success: true,
                Code:    http.StatusOK,
                Message: "支付已取消",
        })</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package user

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"

        "gamelink/internal/apierr"
        "gamelink/internal/model"
        "gamelink/internal/service/player"
)

// RegisterPlayerRoutes 注册用户端陪玩师路由
func RegisterPlayerRoutes(router gin.IRouter, svc *player.PlayerService, authMiddleware gin.HandlerFunc) <span class="cov0" title="0">{
        group := router.Group("/user/players")
        </span><span class="cov0" title="0">{
                // 公开接口（不需要认证）
                group.GET("", func(c *gin.Context) </span><span class="cov0" title="0">{ listPlayersHandler(c, svc) }</span>)
                <span class="cov0" title="0">group.GET("/:id", func(c *gin.Context) </span><span class="cov0" title="0">{ getPlayerDetailHandler(c, svc) }</span>)
        }
}

// listPlayersHandler 获取陪玩师列�?// @Summary      获取陪玩师列�?// @Description  获取陪玩师列表，支持筛选和排序
// @Tags         User - Players
// @Accept       json
// @Produce      json
// @Param        gameId      query     int     false  "游戏ID"
// @Param        minPrice    query     int     false  "最低价格（分）"
// @Param        maxPrice    query     int     false  "最高价格（分）"
// @Param        minRating   query     number  false  "最低评�?
// @Param        onlineOnly  query     bool    false  "仅在�?
// @Param        sortBy      query     string  false  "排序方式" Enums(price, rating, orders)
// @Param        page        query     int     false  "页码"
// @Param        pageSize    query     int     false  "每页数量"
// @Success      200         {object}  model.APIResponse[player.PlayerListResponse]
// @Failure      400         {object}  model.APIResponse[any]
// @Router       /user/players [get]
func listPlayersHandler(c *gin.Context, svc *player.PlayerService) <span class="cov8" title="1">{
        var req player.PlayerListRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov8" title="1">resp, err := svc.ListPlayers(c.Request.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[player.PlayerListResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *resp,
        })</span>
}

// getPlayerDetailHandler 获取陪玩师详�?// @Summary      获取陪玩师详�?// @Description  获取陪玩师详细信息，包括评价和统�?// @Tags         User - Players
// @Accept       json
// @Produce      json
// @Param        id   path      int  true  "陪玩师ID"
// @Success      200  {object}  model.APIResponse[player.PlayerDetailResponse]
// @Failure      400  {object}  model.APIResponse[any]
// @Failure      404  {object}  model.APIResponse[any]
// @Router       /user/players/{id} [get]
func getPlayerDetailHandler(c *gin.Context, svc *player.PlayerService) <span class="cov8" title="1">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                respondError(c, http.StatusBadRequest, apierr.ErrInvalidID)
                return
        }</span>

        <span class="cov8" title="1">resp, err := svc.GetPlayerDetail(c.Request.Context(), id)
        if err != nil </span><span class="cov8" title="1">{
                if err == player.ErrNotFound </span><span class="cov8" title="1">{
                        respondError(c, http.StatusNotFound, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">respondError(c, http.StatusInternalServerError, err.Error())
                return</span>
        }

        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[player.PlayerDetailResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *resp,
        })</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package user

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"

        "gamelink/internal/model"
        "gamelink/internal/service/review"
)

// RegisterReviewRoutes 注册用户端评价路由
func RegisterReviewRoutes(router gin.IRouter, svc *review.ReviewService, authMiddleware gin.HandlerFunc) <span class="cov0" title="0">{
    group := router.Group("/user/reviews")
    group.Use(authMiddleware) // 需要认证
    group.POST("", func(c *gin.Context) </span><span class="cov0" title="0">{ createReviewHandler(c, svc) }</span>)
    <span class="cov0" title="0">group.GET("/my", func(c *gin.Context) </span><span class="cov0" title="0">{ getMyReviewsHandler(c, svc) }</span>)
}

// createReviewHandler 创建评价
// @Summary      创建评价
// @Description  为已完成订单创建评价
// @Tags         User - Reviews
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string                        true  "Bearer {token}"
// @Param        request        body      review.CreateReviewRequest    true  "创建评价请求"
// @Success      200            {object}  model.APIResponse[review.CreateReviewResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /user/reviews [post]
func createReviewHandler(c *gin.Context, svc *review.ReviewService) <span class="cov8" title="1">{
        userID := getUserIDFromContext(c)

        var req review.CreateReviewRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                respondError(c, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov8" title="1">resp, err := svc.CreateReview(c.Request.Context(), userID, req)
        if err != nil </span><span class="cov8" title="1">{
                if err == review.ErrAlreadyReviewed </span><span class="cov8" title="1">{
                        respondError(c, http.StatusBadRequest, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">if err == review.ErrOrderNotCompleted </span><span class="cov0" title="0">{
                        respondError(c, http.StatusBadRequest, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">if err == review.ErrUnauthorized </span><span class="cov0" title="0">{
                        respondError(c, http.StatusForbidden, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">respondError(c, http.StatusInternalServerError, err.Error())
                return</span>
        }

        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[review.CreateReviewResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "评价创建成功",
                Data:    *resp,
        })</span>
}

// getMyReviewsHandler 获取我的评价列表
// @Summary      获取我的评价列表
// @Description  获取当前用户的评价列�?// @Tags         User - Reviews
// @Accept       json
// @Produce      json
// @Param        Authorization  header    string  true   "Bearer {token}"
// @Param        page           query     int     false  "页码"
// @Param        pageSize       query     int     false  "每页数量"
// @Success      200            {object}  model.APIResponse[review.MyReviewListResponse]
// @Failure      400            {object}  model.APIResponse[any]
// @Failure      401            {object}  model.APIResponse[any]
// @Router       /user/reviews/my [get]
func getMyReviewsHandler(c *gin.Context, svc *review.ReviewService) <span class="cov8" title="1">{
        userID := getUserIDFromContext(c)

        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        pageSize, _ := strconv.Atoi(c.DefaultQuery("pageSize", "20"))

        resp, err := svc.GetMyReviews(c.Request.Context(), userID, page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                respondError(c, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">respondJSON(c, http.StatusOK, model.APIResponse[review.MyReviewListResponse]{
                Success: true,
                Code:    http.StatusOK,
                Message: "OK",
                Data:    *resp,
        })</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package logging

import "context"

type ctxKey string

const (
    keyRequestID ctxKey = "request_id"
    keyActorUserID ctxKey = "actor_user_id"
)

// WithRequestID stores request id into context.
func WithRequestID(ctx context.Context, id string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, keyRequestID, id)
}</span>

// RequestIDFromContext returns the request id if present.
func RequestIDFromContext(ctx context.Context) (string, bool) <span class="cov0" title="0">{
        v := ctx.Value(keyRequestID)
        if v == nil </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov0" title="0">if s, ok := v.(string); ok </span><span class="cov0" title="0">{
                return s, true
        }</span>
        <span class="cov0" title="0">return "", false</span>
}

// WithActorUserID stores current actor (user id) into context.
func WithActorUserID(ctx context.Context, id uint64) context.Context <span class="cov0" title="0">{
    return context.WithValue(ctx, keyActorUserID, id)
}</span>

// ActorUserIDFromContext returns the user id if present.
func ActorUserIDFromContext(ctx context.Context) (uint64, bool) <span class="cov0" title="0">{
    v := ctx.Value(keyActorUserID)
    if v == nil </span><span class="cov0" title="0">{ return 0, false }</span>
    <span class="cov0" title="0">if id, ok := v.(uint64); ok </span><span class="cov0" title="0">{ return id, true }</span>
    <span class="cov0" title="0">return 0, false</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package logging

import (
        "log/slog"
        "os"
        "strings"
)

// Init sets the default slog logger with JSON handler and given level.
func Init(level string) *slog.Logger <span class="cov8" title="1">{
        lvl := parseLevel(level)
        handler := slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{Level: lvl, AddSource: false})
        logger := slog.New(handler)
        slog.SetDefault(logger)
        return logger
}</span>

func parseLevel(v string) slog.Leveler <span class="cov8" title="1">{
        switch strings.ToLower(strings.TrimSpace(v)) </span>{
        case "debug":<span class="cov8" title="1">
                return slog.LevelDebug</span>
        case "warn", "warning":<span class="cov0" title="0">
                return slog.LevelWarn</span>
        case "error":<span class="cov0" title="0">
                return slog.LevelError</span>
        default:<span class="cov0" title="0">
                return slog.LevelInfo</span>
        }
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package metrics

import (
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "gorm.io/gorm"
)

// InstrumentGorm registers callbacks to measure operation durations.
func InstrumentGorm(db *gorm.DB) error <span class="cov0" title="0">{
        // Ensure metrics are initialized; use default registerer
        Init(prometheus.DefaultRegisterer)

        // we store start time in instance settings
        const key = "metrics_start"

        before := func(tx *gorm.DB) </span><span class="cov0" title="0">{
                tx.InstanceSet(key, time.Now())
        }</span>
        <span class="cov0" title="0">after := func(op string) func(tx *gorm.DB) </span><span class="cov0" title="0">{
                return func(tx *gorm.DB) </span><span class="cov0" title="0">{
                        v, ok := tx.InstanceGet(key)
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">start, _ := v.(time.Time)
                        table := tx.Statement.Table
                        DBQueryDuration.WithLabelValues(op, table).Observe(time.Since(start).Seconds())</span>
                }
        }

        <span class="cov0" title="0">_ = db.Callback().Query().Before("gorm:query").Register("metrics:before_query", before)
        _ = db.Callback().Query().After("gorm:after_query").Register("metrics:after_query", after("query"))

        _ = db.Callback().Create().Before("gorm:create").Register("metrics:before_create", before)
        _ = db.Callback().Create().After("gorm:after_create").Register("metrics:after_create", after("create"))

        _ = db.Callback().Update().Before("gorm:update").Register("metrics:before_update", before)
        _ = db.Callback().Update().After("gorm:after_update").Register("metrics:after_update", after("update"))

        _ = db.Callback().Delete().Before("gorm:delete").Register("metrics:before_delete", before)
        _ = db.Callback().Delete().After("gorm:after_delete").Register("metrics:after_delete", after("delete"))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package metrics

import (
        "sync"

        "github.com/prometheus/client_golang/prometheus"
)

var (
        once sync.Once

        // HTTPRequestsTotal counts requests by method, path and status code.
        HTTPRequestsTotal *prometheus.CounterVec

        // HTTPRequestDuration measures request duration seconds by method and path.
        HTTPRequestDuration *prometheus.HistogramVec

        // DBQueryDuration measures gorm operation duration seconds by op (query/create/update/delete) and table.
        DBQueryDuration *prometheus.HistogramVec
)

// Init registers metrics. Safe to call multiple times.
func Init(reg prometheus.Registerer) <span class="cov8" title="1">{
        once.Do(func() </span><span class="cov8" title="1">{
                HTTPRequestsTotal = prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "http_requests_total",
                                Help: "Total number of HTTP requests",
                        },
                        []string{"method", "path", "status"},
                )
                HTTPRequestDuration = prometheus.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "http_request_duration_seconds",
                                Help:    "HTTP request duration in seconds",
                                Buckets: prometheus.DefBuckets,
                        },
                        []string{"method", "path"},
                )
                DBQueryDuration = prometheus.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "db_query_duration_seconds",
                                Help:    "GORM operation duration in seconds",
                                Buckets: prometheus.DefBuckets,
                        },
                        []string{"op", "table"},
                )
                reg.MustRegister(HTTPRequestsTotal, HTTPRequestDuration, DBQueryDuration)
        }</span>)
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package model

import "time"

// CommissionRule 抽成规则
type CommissionRule struct {
        ID               uint64    `gorm:"primaryKey;autoIncrement" json:"id"`
        Name             string    `gorm:"type:varchar(128);not null" json:"name"`
        Description      string    `gorm:"type:text" json:"description"`
        Type             string    `gorm:"type:varchar(32);not null" json:"type"` // default/special/gift
        Rate             int       `gorm:"not null" json:"rate"`                  // 抽成比例（百分比，例如20表示20%）
        IsActive         bool      `gorm:"default:true" json:"isActive"`
        GameID           *uint64   `gorm:"index" json:"gameId"`     // 特定游戏的抽成
        PlayerID         *uint64   `gorm:"index" json:"playerId"`   // 特定陪玩师的抽成
        ServiceType      *string   `gorm:"type:varchar(64)" json:"serviceType"` // 特定服务类型的抽成
        CreatedAt        time.Time `gorm:"autoCreateTime" json:"createdAt"`
        UpdatedAt        time.Time `gorm:"autoUpdateTime" json:"updatedAt"`
}

// TableName 指定表名
func (CommissionRule) TableName() string <span class="cov8" title="1">{
        return "commission_rules"
}</span>

// CommissionRecord 抽成记录
type CommissionRecord struct {
        ID                 uint64    `gorm:"primaryKey;autoIncrement" json:"id"`
        OrderID            uint64    `gorm:"not null;index" json:"orderId"`
        PlayerID           uint64    `gorm:"not null;index" json:"playerId"`
        TotalAmountCents   int64     `gorm:"not null" json:"totalAmountCents"`       // 订单总金额
        CommissionRate     int       `gorm:"not null" json:"commissionRate"`         // 抽成比例
        CommissionCents    int64     `gorm:"not null" json:"commissionCents"`        // 平台抽成金额
        PlayerIncomeCents  int64     `gorm:"not null" json:"playerIncomeCents"`      // 陪玩师收入
        SettlementStatus   string    `gorm:"type:varchar(32);not null;default:'pending'" json:"settlementStatus"` // pending/settled
        SettlementMonth    string    `gorm:"type:varchar(7);index" json:"settlementMonth"` // YYYY-MM
        SettledAt          *time.Time `json:"settledAt"`
        CreatedAt          time.Time `gorm:"autoCreateTime" json:"createdAt"`
        UpdatedAt          time.Time `gorm:"autoUpdateTime" json:"updatedAt"`
}

// TableName 指定表名
func (CommissionRecord) TableName() string <span class="cov8" title="1">{
        return "commission_records"
}</span>

// MonthlySettlement 月度结算
type MonthlySettlement struct {
        ID                    uint64    `gorm:"primaryKey;autoIncrement" json:"id"`
        PlayerID              uint64    `gorm:"not null;index" json:"playerId"`
        SettlementMonth       string    `gorm:"type:varchar(7);not null;index" json:"settlementMonth"` // YYYY-MM
        TotalOrderCount       int64     `gorm:"not null" json:"totalOrderCount"`
        TotalAmountCents      int64     `gorm:"not null" json:"totalAmountCents"`
        TotalCommissionCents  int64     `gorm:"not null" json:"totalCommissionCents"`
        TotalIncomeCents      int64     `gorm:"not null" json:"totalIncomeCents"`
        BonusCents            int64     `gorm:"default:0" json:"bonusCents"`        // 奖金
        FinalIncomeCents      int64     `gorm:"not null" json:"finalIncomeCents"`   // 最终收入
        Status                string    `gorm:"type:varchar(32);not null;default:'pending'" json:"status"` // pending/confirmed/paid
        IncomeRank            *int      `json:"incomeRank"`                         // 收入排名
        OrderRank             *int      `json:"orderRank"`                          // 订单数排名
        QualityRank           *int      `json:"qualityRank"`                        // 质量排名
        CreatedAt             time.Time `gorm:"autoCreateTime" json:"createdAt"`
        UpdatedAt             time.Time `gorm:"autoUpdateTime" json:"updatedAt"`
        SettledAt             *time.Time `json:"settledAt"`
}

// TableName 指定表名
func (MonthlySettlement) TableName() string <span class="cov8" title="1">{
        return "monthly_settlements"
}</span>

</pre>
		
		<pre class="file" id="file66" style="display: none">package model

// Currency 定义系统支持的三字母货币编码。
type Currency string

// Currency values define supported ISO-4217 3-letter codes.
const (
        CurrencyCNY Currency = "CNY"
        CurrencyUSD Currency = "USD"
        CurrencyEUR Currency = "EUR"
)

// SupportedCurrencies 返回受支持的货币列表。
func SupportedCurrencies() []Currency <span class="cov8" title="1">{
        return []Currency{
                CurrencyCNY,
                CurrencyUSD,
                CurrencyEUR,
        }
}</span>

// IsValidCurrency 判断输入货币是否受支持。
func IsValidCurrency(value Currency) bool <span class="cov8" title="1">{
        for _, c := range SupportedCurrencies() </span><span class="cov8" title="1">{
                if c == value </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// GormDataType 指定默认存储类型。
func (Currency) GormDataType() string <span class="cov8" title="1">{
        return "char(3)"
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package model

import (
        "encoding/json"
        "time"
)

// FinancialAccountType 财务科目类型
type FinancialAccountType string

const (
        FinancialAccountTypeAsset     FinancialAccountType = "asset"     // 资产
        FinancialAccountTypeLiability  FinancialAccountType = "liability"  // 负债
        FinancialAccountTypeEquity     FinancialAccountType = "equity"     // 所有者权益
        FinancialAccountTypeRevenue    FinancialAccountType = "revenue"    // 收入
        FinancialAccountTypeExpense    FinancialAccountType = "expense"    // 费用
)

// FinancialAccountLevel 科目级别
type FinancialAccountLevel int

const (
        FinancialAccountLevel1 FinancialAccountLevel = 1 // 一级科目
        FinancialAccountLevel2 FinancialAccountLevel = 2 // 二级科目
        FinancialAccountLevel3 FinancialAccountLevel = 3 // 三级科目
)

// FinancialAccountDirection 余额方向
type FinancialAccountDirection string

const (
        FinancialAccountDirectionDebit  FinancialAccountDirection = "debit"  // 借方
        FinancialAccountDirectionCredit FinancialAccountDirection = "credit" // 贷方
)

// FinancialAccountStatus 科目状态
type FinancialAccountStatus string

const (
        FinancialAccountStatusActive   FinancialAccountStatus = "active"   // 启用
        FinancialAccountStatusInactive FinancialAccountStatus = "inactive" // 停用
)

// FinancialAccount 财务科目
type FinancialAccount struct {
        Base
        Code             string                   `json:"code" gorm:"column:code;size:20;uniqueIndex;not null"`              // 科目编码
        Name             string                   `json:"name" gorm:"column:name;size:100;not null"`                         // 科目名称
        Type             FinancialAccountType     `json:"type" gorm:"column:type;size:20;not null;index"`                      // 科目类型
        Level            FinancialAccountLevel    `json:"level" gorm:"column:level;not null"`                                  // 科目级别
        ParentCode       *string                  `json:"parentCode,omitempty" gorm:"column:parent_code;size:20;index"`          // 父科目编码
        Direction        FinancialAccountDirection `json:"direction" gorm:"column:direction;size:10;not null"`                    // 余额方向
        OpeningBalance   int64                    `json:"openingBalance" gorm:"column:opening_balance;default:0"`               // 期初余额（分）
        CurrentBalance   int64                    `json:"currentBalance" gorm:"column:current_balance;default:0"`               // 当前余额（分）
        Description      string                   `json:"description,omitempty" gorm:"column:description;size:500"`           // 科目描述
        Status           FinancialAccountStatus   `json:"status" gorm:"column:status;size:20;default:'active'"`                // 状态
        IsSystem         bool                     `json:"isSystem" gorm:"column:is_system;default:false"`                      // 是否系统科目

        // 审计字段
        CreatedBy        uint64                   `json:"createdBy" gorm:"column:created_by;not null;index"`                    // 创建人
        UpdatedBy        *uint64                  `json:"updatedBy,omitempty" gorm:"column:updated_by;index"`                   // 更新人

        // 关联关系
        Parent           *FinancialAccount       `json:"parent,omitempty" gorm:"foreignKey:ParentCode;references:Code"`
        Children         []FinancialAccount      `json:"children,omitempty" gorm:"foreignKey:ParentCode;references:Code"`
        Vouchers         []FinancialVoucher      `json:"-" gorm:"foreignKey:AccountCode;references:Code"`
        Transactions     []FinancialTransaction  `json:"-" gorm:"foreignKey:AccountCode;references:Code"`
}

// FinancialVoucherType 凭证类型
type FinancialVoucherType string

const (
        FinancialVoucherTypeManual    FinancialVoucherType = "manual"    // 手工凭证
        FinancialVoucherTypeAuto      FinancialVoucherType = "auto"      // 自动凭证
        FinancialVoucherTypeAdjust    FinancialVoucherType = "adjust"    // 调整凭证
        FinancialVoucherTypeClosing   FinancialVoucherType = "closing"   // 结账凭证
        FinancialVoucherTypeReversal  FinancialVoucherType = "reversal"  // 红字冲销凭证
)

// FinancialVoucherStatus 凭证状态
type FinancialVoucherStatus string

const (
        FinancialVoucherStatusDraft     FinancialVoucherStatus = "draft"     // 草稿
        FinancialVoucherStatusPending   FinancialVoucherStatus = "pending"   // 待审核
        FinancialVoucherStatusApproved  FinancialVoucherStatus = "approved"  // 已审核
        FinancialVoucherStatusRejected  FinancialVoucherStatus = "rejected"  // 已驳回
        FinancialVoucherStatusPosted    FinancialVoucherStatus = "posted"    // 已过账
        FinancialVoucherStatusCancelled FinancialVoucherStatus = "cancelled" // 已取消
)

// FinancialVoucher 财务凭证
type FinancialVoucher struct {
        Base
        VoucherNo        string                  `json:"voucherNo" gorm:"column:voucher_no;size:32;uniqueIndex;not null"` // 凭证号
        VoucherDate      time.Time               `json:"voucherDate" gorm:"column:voucher_date;not null;index"`             // 凭证日期
        Type             FinancialVoucherType    `json:"type" gorm:"column:type;size:20;not null;index"`                    // 凭证类型
        Abstract         string                  `json:"abstract" gorm:"column:abstract;size:200;not null"`                   // 摘要
        AttachmentCount  int                     `json:"attachmentCount" gorm:"column:attachment_count;default:0"`             // 附件数量
        Status           FinancialVoucherStatus  `json:"status" gorm:"column:status;size:20;default:'draft'"`                // 状态
        TotalAmount      int64                   `json:"totalAmount" gorm:"column:total_amount;default:0"`                     // 总金额（分）

        // 业务关联
        BusinessType     string                  `json:"businessType,omitempty" gorm:"column:business_type;size:50"`           // 业务类型
        BusinessNo       string                  `json:"businessNo,omitempty" gorm:"column:business_no;size:64"`               // 业务单号

        // 审计字段
        CreatedBy        uint64                  `json:"createdBy" gorm:"column:created_by;not null;index"`                    // 制单人
        ReviewedBy       *uint64                 `json:"reviewedBy,omitempty" gorm:"column:reviewed_by;index"`                 // 审核人
        PostedBy         *uint64                 `json:"postedBy,omitempty" gorm:"column:posted_by;index"`                    // 过账人
        ReviewedAt       *time.Time              `json:"reviewedAt,omitempty" gorm:"column:reviewed_at"`                        // 审核时间
        PostedAt         *time.Time              `json:"postedAt,omitempty" gorm:"column:posted_at"`                            // 过账时间

        // 关联关系
        Entries          []FinancialVoucherEntry `json:"entries,omitempty" gorm:"foreignKey:VoucherID;references:ID"`
        Creator          User                    `json:"-" gorm:"foreignKey:CreatedBy;references:ID"`
        Reviewer         *User                   `json:"-" gorm:"foreignKey:ReviewedBy;references:ID"`
        Poster           *User                   `json:"-" gorm:"foreignKey:PostedBy;references:ID"`
}

// FinancialVoucherEntry 凭证分录
type FinancialVoucherEntry struct {
        Base
        VoucherID        uint64                   `json:"voucherId" gorm:"column:voucher_id;not null;index"`                       // 凭证ID
        LineNo           int                      `json:"lineNo" gorm:"column:line_no;not null"`                                    // 分录行号
        AccountCode      string                   `json:"accountCode" gorm:"column:account_code;size:20;not null;index"`           // 科目编码
        Abstract         string                   `json:"abstract" gorm:"column:abstract;size:200"`                                  // 摘要
        DebitAmount      int64                    `json:"debitAmount" gorm:"column:debit_amount;default:0"`                          // 借方金额（分）
        CreditAmount     int64                    `json:"creditAmount" gorm:"column:credit_amount;default:0"`                         // 贷方金额（分）
        Currency         Currency                 `json:"currency,omitempty" gorm:"type:char(3);default:'CNY'"`                    // 货币

        // 业务关联
        BusinessType     string                   `json:"businessType,omitempty" gorm:"column:business_type;size:50"`              // 业务类型
        BusinessNo       string                   `json:"businessNo,omitempty" gorm:"column:business_no;size:64"`                // 业务单号
        RelatedEntity    string                   `json:"relatedEntity,omitempty" gorm:"column:related_entity;size:50"`           // 关联实体
        RelatedEntityID  *uint64                  `json:"relatedEntityId,omitempty" gorm:"column:related_entity_id"`              // 关联实体ID

        // 关联关系
        Voucher          FinancialVoucher         `json:"-" gorm:"foreignKey:VoucherID;references:ID"`
        Account          FinancialAccount        `json:"-" gorm:"foreignKey:AccountCode;references:Code"`
}

// FinancialTransactionType 交易类型
type FinancialTransactionType string

const (
        FinancialTransactionTypeRevenue    FinancialTransactionType = "revenue"    // 收入
        FinancialTransactionTypeExpense    FinancialTransactionType = "expense"    // 支出
        FinancialTransactionTypeTransfer   FinancialTransactionType = "transfer"   // 转账
        FinancialTransactionTypeAdjustment FinancialTransactionType = "adjustment" // 调整
        FinancialTransactionTypeOpening    FinancialTransactionType = "opening"    // 开账
        FinancialTransactionTypeClosing    FinancialTransactionType = "closing"    // 结账
)

// FinancialTransaction 财务流水
type FinancialTransaction struct {
        Base
        TransactionNo    string                     `json:"transactionNo" gorm:"column:transaction_no;size:32;uniqueIndex;not null"` // 交易流水号
        TransactionDate  time.Time                  `json:"transactionDate" gorm:"column:transaction_date;not null;index"`             // 交易日期
        AccountCode      string                     `json:"accountCode" gorm:"column:account_code;size:20;not null;index"`           // 科目编码
        Type             FinancialTransactionType   `json:"type" gorm:"column:type;size:20;not null;index"`                        // 交易类型
        Direction        FinancialAccountDirection   `json:"direction" gorm:"column:direction;size:10;not null"`                      // 借贷方向
        Amount           int64                      `json:"amount" gorm:"column:amount;not null"`                                      // 金额（分）
        BalanceBefore    int64                      `json:"balanceBefore" gorm:"column:balance_before;not null"`                       // 交易前余额（分）
        BalanceAfter     int64                      `json:"balanceAfter" gorm:"column:balance_after;not null"`                         // 交易后余额（分）
        Currency         Currency                   `json:"currency,omitempty" gorm:"type:char(3);default:'CNY'"`                    // 货币
        Abstract         string                     `json:"abstract" gorm:"column:abstract;size:200"`                                  // 摘要

        // 业务关联
        BusinessType     string                     `json:"businessType,omitempty" gorm:"column:business_type;size:50"`              // 业务类型
        BusinessNo       string                     `json:"businessNo,omitempty" gorm:"column:business_no;size:64"`                // 业务单号
        VoucherID        *uint64                    `json:"voucherId,omitempty" gorm:"column:voucher_id;index"`                      // 关联凭证ID
        VoucherEntryID   *uint64                    `json:"voucherEntryId,omitempty" gorm:"column:voucher_entry_id"`                 // 关联凭证分录ID

        // 关联关系
        Account          FinancialAccount           `json:"-" gorm:"foreignKey:AccountCode;references:Code"`
        Voucher          *FinancialVoucher         `json:"-" gorm:"foreignKey:VoucherID;references:ID"`
        VoucherEntry     *FinancialVoucherEntry    `json:"-" gorm:"foreignKey:VoucherEntryID;references:ID"`
}

// ReconciliationType 对账类型
type ReconciliationType string

const (
        ReconciliationTypePayment     ReconciliationType = "payment"     // 支付对账
        ReconciliationTypeInternal    ReconciliationType = "internal"    // 内部对账
        ReconciliationTypeBank        ReconciliationType = "bank"        // 银行对账
        ReconciliationTypeManual      ReconciliationType = "manual"      // 手工对账
)

// ReconciliationStatus 对账状态
type ReconciliationStatus string

const (
        ReconciliationStatusPending   ReconciliationStatus = "pending"   // 待对账
        ReconciliationStatusProgress  ReconciliationStatus = "progress"  // 对账中
        ReconciliationStatusSuccess   ReconciliationStatus = "success"   // 对账成功
        ReconciliationStatusFailed    ReconciliationStatus = "failed"    // 对账失败
        ReconciliationStatusException ReconciliationStatus = "exception" // 异常
)

// Reconciliation 对账单
type Reconciliation struct {
        Base
        ReconciliationNo string               `json:"reconciliationNo" gorm:"column:reconciliation_no;size:32;uniqueIndex;not null"` // 对账单号
        ReconciliationDate time.Time           `json:"reconciliationDate" gorm:"column:reconciliation_date;not null;index"`             // 对账日期
        Type             ReconciliationType   `json:"type" gorm:"column:type;size:20;not null;index"`                        // 对账类型
        Status           ReconciliationStatus `json:"status" gorm:"column:status;size:20;default:'pending'"`                      // 对账状态
        PeriodStart      time.Time            `json:"periodStart" gorm:"column:period_start;not null"`                              // 对账期间开始
        PeriodEnd        time.Time            `json:"periodEnd" gorm:"column:period_end;not null"`                                // 对账期间结束
        TotalRecords     int                  `json:"totalRecords" gorm:"column:total_records;default:0"`                         // 总记录数
        MatchedRecords   int                  `json:"matchedRecords" gorm:"column:matched_records;default:0"`                       // 匹配记录数
        DifferenceAmount int64                `json:"differenceAmount" gorm:"column:difference_amount;default:0"`                   // 差异金额（分）
        Abstract         string               `json:"abstract" gorm:"column:abstract;size:500"`                                   // 摘要

        // 处理信息
        ProcessedAt      *time.Time           `json:"processedAt,omitempty" gorm:"column:processed_at"`                           // 处理时间
        ProcessedBy      *uint64              `json:"processedBy,omitempty" gorm:"column:processed_by;index"`                     // 处理人

        // 关联关系
        Details          []ReconciliationDetail `json:"details,omitempty" gorm:"foreignKey:ReconciliationID;references:ID"`
        Processor        *User                  `json:"-" gorm:"foreignKey:ProcessedBy;references:ID"`
}

// ReconciliationDetail 对账明细
type ReconciliationDetail struct {
        Base
        ReconciliationID uint64 `json:"reconciliationId" gorm:"column:reconciliation_id;not null;index"` // 对账单ID
        LineNo           int    `json:"lineNo" gorm:"column:line_no;not null"`                            // 行号

        // 外部数据
        ExternalType     string `json:"externalType" gorm:"column:external_type;size:50"`                 // 外部类型
        ExternalNo       string `json:"externalNo" gorm:"column:external_no;size:64"`                     // 外部单号
        ExternalAmount   int64  `json:"externalAmount" gorm:"column:external_amount;not null"`             // 外部金额（分）
        ExternalDate     time.Time `json:"externalDate" gorm:"column:external_date;not null"`             // 外部日期

        // 内部数据
        InternalType     string `json:"internalType" gorm:"column:internal_type;size:50"`                 // 内部类型
        InternalNo       string `json:"internalNo" gorm:"column:internal_no;size:64"`                     // 内部单号
        InternalAmount   int64  `json:"internalAmount" gorm:"column:internal_amount;not null"`             // 内部金额（分）
        InternalDate     time.Time `json:"internalDate" gorm:"column:internal_date;not null"`             // 内部日期

        // 对账结果
        Status           string `json:"status" gorm:"column:status;size:20;default:'pending'"`           // 对账状态
        DifferenceAmount int64  `json:"differenceAmount" gorm:"column:difference_amount;default:0"`       // 差异金额（分）
        Remark           string `json:"remark,omitempty" gorm:"column:remark;size:500"`                   // 备注

        // 关联关系
        Reconciliation   Reconciliation `json:"-" gorm:"foreignKey:ReconciliationID;references:ID"`
}

// FinancialReportType 财务报表类型
type FinancialReportType string

const (
        FinancialReportTypeBalanceSheet    FinancialReportType = "balance_sheet"    // 资产负债表
        FinancialReportTypeIncomeStatement  FinancialReportType = "income_statement"  // 利润表
        FinancialReportTypeCashFlow        FinancialReportType = "cash_flow"        // 现金流量表
        FinancialReportTypeTrialBalance     FinancialReportType = "trial_balance"     // 试算平衡表
        FinancialReportTypeCustom          FinancialReportType = "custom"           // 自定义报表
)

// FinancialReport 财务报表
type FinancialReport struct {
        Base
        ReportNo         string              `json:"reportNo" gorm:"column:report_no;size:32;uniqueIndex;not null"` // 报表编号
        ReportName       string              `json:"reportName" gorm:"column:report_name;size:100;not null"`         // 报表名称
        Type             FinancialReportType `json:"type" gorm:"column:type;size:50;not null;index"`                // 报表类型
        PeriodStart      time.Time           `json:"periodStart" gorm:"column:period_start;not null"`                // 报告期间开始
        PeriodEnd        time.Time           `json:"periodEnd" gorm:"column:period_end;not null"`                  // 报告期间结束
        Currency         Currency            `json:"currency,omitempty" gorm:"type:char(3);default:'CNY'"`         // 货币单位
        ReportData       json.RawMessage    `json:"reportData" gorm:"column:report_data;type:json"`                 // 报表数据(JSON)
        Status           string              `json:"status" gorm:"column:status;size:20;default:'draft'"`           // 报表状态

        // 生成信息
        GeneratedAt      *time.Time          `json:"generatedAt,omitempty" gorm:"column:generated_at"`               // 生成时间
        GeneratedBy      *uint64             `json:"generatedBy,omitempty" gorm:"column:generated_by;index"`          // 生成人

        // 关联关系
        Generator        *User               `json:"-" gorm:"foreignKey:GeneratedBy;references:ID"`
}

// FinancialAccountSetting 科目设置
type FinancialAccountSetting struct {
        Base
        AccountCode      string    `json:"accountCode" gorm:"column:account_code;size:20;not null;index"` // 科目编码
        AllowManual      bool      `json:"allowManual" gorm:"column:allow_manual;default:true"`            // 允许手工录入
        RequireApproval  bool      `json:"requireApproval" gorm:"column:require_approval;default:false"`      // 需要审批
        MaxAmount        int64     `json:"maxAmount" gorm:"column:max_amount;default:0"`                      // 最大金额（分）
        MinAmount        int64     `json:"minAmount" gorm:"column:min_amount;default:0"`                      // 最小金额（分）
        Description      string    `json:"description,omitempty" gorm:"column:description;size:500"`         // 描述

        // 关联关系
        Account          FinancialAccount `json:"-" gorm:"foreignKey:AccountCode;references:Code"`
}

// TableName 返回表名
func (FinancialAccount) TableName() string <span class="cov8" title="1">{
        return "financial_accounts"
}</span>

func (FinancialVoucher) TableName() string <span class="cov8" title="1">{
        return "financial_vouchers"
}</span>

func (FinancialVoucherEntry) TableName() string <span class="cov8" title="1">{
        return "financial_voucher_entries"
}</span>

func (FinancialTransaction) TableName() string <span class="cov8" title="1">{
        return "financial_transactions"
}</span>

func (Reconciliation) TableName() string <span class="cov8" title="1">{
        return "reconciliations"
}</span>

func (ReconciliationDetail) TableName() string <span class="cov8" title="1">{
        return "reconciliation_details"
}</span>

func (FinancialReport) TableName() string <span class="cov8" title="1">{
        return "financial_reports"
}</span>

func (FinancialAccountSetting) TableName() string <span class="cov8" title="1">{
        return "financial_account_settings"
}</pre>
		
		<pre class="file" id="file68" style="display: none">package model

import "time"

// OrderStatus defines lifecycle states for an order.
type OrderStatus string

// OrderStatus values define the lifecycle of an order.
const (
        OrderStatusPending    OrderStatus = "pending"
        OrderStatusConfirmed  OrderStatus = "confirmed"
        OrderStatusInProgress OrderStatus = "in_progress"
        OrderStatusCompleted  OrderStatus = "completed"
        OrderStatusCanceled   OrderStatus = "canceled"
        OrderStatusRefunded   OrderStatus = "refunded"
)

// Order represents a unified order (护航服务 or 礼物)
type Order struct {
        Base
        OrderNo           string  `json:"orderNo" gorm:"column:order_no;size:64;uniqueIndex:idx_order_no,where:order_no != ''"` // 订单号
        UserID            uint64  `json:"userId" gorm:"column:user_id;not null;index"`                                          // 下单用户
        ItemID            uint64  `json:"itemId" gorm:"column:item_id;not null;index"`                                          // 服务项目ID
        PlayerID          *uint64 `json:"playerId,omitempty" gorm:"column:player_id;index"`                                     // 服务陪玩师（礼物订单也可选）
        RecipientPlayerID *uint64 `json:"recipientPlayerId,omitempty" gorm:"column:recipient_player_id;index"`                  // 接收礼物的陪玩师

        // 价格相关
        Quantity          int      `json:"quantity" gorm:"default:1"`                                     // 数量
        UnitPriceCents    int64    `json:"unitPriceCents" gorm:"column:unit_price_cents;not null"`        // 单价（分）
        TotalPriceCents   int64    `json:"totalPriceCents" gorm:"column:total_price_cents;not null"`      // 总价（分）
        CommissionCents   int64    `json:"commissionCents" gorm:"column:commission_cents;default:0"`      // 平台抽成（分）
        PlayerIncomeCents int64    `json:"playerIncomeCents" gorm:"column:player_income_cents;default:0"` // 陪玩师收入（分）
        Currency          Currency `json:"currency,omitempty" gorm:"type:char(3);default:'CNY'"`          // 货币

        // 订单信息
        Status      OrderStatus `json:"status" gorm:"size:32;index;default:'pending'"` // 订单状态
        Title       string      `json:"title,omitempty" gorm:"size:128"`               // 订单标题
        Description string      `json:"description,omitempty" gorm:"type:text"`        // 订单描述

        // 护航服务字段
        GameID         *uint64    `json:"gameId,omitempty" gorm:"column:game_id;index"`           // 游戏ID
        ScheduledStart *time.Time `json:"scheduledStart,omitempty" gorm:"column:scheduled_start"` // 预约开始时间
        ScheduledEnd   *time.Time `json:"scheduledEnd,omitempty" gorm:"column:scheduled_end"`     // 预约结束时间
        StartedAt      *time.Time `json:"startedAt,omitempty" gorm:"column:started_at"`           // 实际开始时间
        CompletedAt    *time.Time `json:"completedAt,omitempty" gorm:"column:completed_at"`       // 完成时间

        // 礼物订单字段
        GiftMessage string     `json:"giftMessage,omitempty" gorm:"column:gift_message;type:text"` // 礼物留言
        IsAnonymous bool       `json:"isAnonymous" gorm:"column:is_anonymous;default:false"`       // 是否匿名
        DeliveredAt *time.Time `json:"deliveredAt,omitempty" gorm:"column:delivered_at"`           // 礼物送达时间

        // 取消/退款信息
        CancelReason      string     `json:"cancelReason,omitempty" gorm:"column:cancel_reason;type:text"`
        RefundAmountCents int64      `json:"refundAmountCents,omitempty" gorm:"column:refund_amount_cents;default:0"`
        RefundReason      string     `json:"refundReason,omitempty" gorm:"column:refund_reason;type:text"`
        RefundedAt        *time.Time `json:"refundedAt,omitempty" gorm:"column:refunded_at"`

        // 扩展字段
        OrderConfig string `json:"orderConfig,omitempty" gorm:"column:order_config;type:json"` // 订单配置（JSON）
        UserNotes   string `json:"userNotes,omitempty" gorm:"column:user_notes;type:text"`     // 用户备注

        // Relations
        User            User         `json:"-" gorm:"constraint:OnUpdate:CASCADE,OnDelete:RESTRICT;foreignKey:UserID;references:ID"`
        Player          *Player      `json:"-" gorm:"constraint:OnUpdate:CASCADE,OnDelete:SET NULL;foreignKey:PlayerID;references:ID"`
        RecipientPlayer *Player      `json:"-" gorm:"constraint:OnUpdate:CASCADE,OnDelete:SET NULL;foreignKey:RecipientPlayerID;references:ID"`
        Game            *Game        `json:"-" gorm:"constraint:OnUpdate:CASCADE,OnDelete:SET NULL;foreignKey:GameID;references:ID"`
        ServiceItem     *ServiceItem `json:"-" gorm:"constraint:OnUpdate:CASCADE,OnDelete:RESTRICT;foreignKey:ItemID;references:ID"`
}

// IsGiftOrder 判断是否为礼物订单
func (o *Order) IsGiftOrder() bool <span class="cov8" title="1">{
        return o.RecipientPlayerID != nil &amp;&amp; *o.RecipientPlayerID &gt; 0
}</span>

// GetPlayerID 获取陪玩师ID（向后兼容）
func (o *Order) GetPlayerID() uint64 <span class="cov8" title="1">{
        if o.PlayerID != nil </span><span class="cov8" title="1">{
                return *o.PlayerID
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// GetGameID 获取游戏ID（向后兼容）
func (o *Order) GetGameID() uint64 <span class="cov8" title="1">{
        if o.GameID != nil </span><span class="cov8" title="1">{
                return *o.GameID
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// GetPriceCents 获取价格（向后兼容）- 返回总价
func (o *Order) GetPriceCents() int64 <span class="cov8" title="1">{
        return o.TotalPriceCents
}</span>

// SetPlayerID 设置陪玩师ID（向后兼容）
func (o *Order) SetPlayerID(playerID uint64) <span class="cov8" title="1">{
        o.PlayerID = &amp;playerID
}</span>

// SetGameID 设置游戏ID（向后兼容）
func (o *Order) SetGameID(gameID uint64) <span class="cov8" title="1">{
        o.GameID = &amp;gameID
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package model

import (
        "fmt"
        "math/rand"
        "time"
)

// GenerateOrderNo 生成订单号
// 格式: PREFIX + YYYYMMDDHHMMSS + 6位随机数
func GenerateOrderNo(prefix string) string <span class="cov8" title="1">{
        now := time.Now()
        timestamp := now.Format("20060102150405")
        random := rand.Intn(1000000)
        return fmt.Sprintf("%s%s%06d", prefix, timestamp, random)
}</span>

// GenerateEscortOrderNo 生成护航订单号
func GenerateEscortOrderNo() string <span class="cov8" title="1">{
        return GenerateOrderNo("ESC")
}</span>

// GenerateGiftOrderNo 生成礼物订单号
func GenerateGiftOrderNo() string <span class="cov8" title="1">{
        return GenerateOrderNo("GIFT")
}</span>

</pre>
		
		<pre class="file" id="file70" style="display: none">package model

// HTTPMethod defines standard HTTP methods for permission control.
type HTTPMethod string

// HTTPMethod values define standard HTTP methods.
const (
        HTTPMethodGET    HTTPMethod = "GET"
        HTTPMethodPOST   HTTPMethod = "POST"
        HTTPMethodPUT    HTTPMethod = "PUT"
        HTTPMethodPATCH  HTTPMethod = "PATCH"
        HTTPMethodDELETE HTTPMethod = "DELETE"
)

// Permission represents a backend API resource that can be accessed.
// It records method + path as a unique identifier for fine-grained authorization.
type Permission struct {
        Base
        Method      HTTPMethod `json:"method" gorm:"size:16;not null;uniqueIndex:idx_method_path"`
        Path        string     `json:"path" gorm:"size:255;not null;uniqueIndex:idx_method_path"`
        Code        string     `json:"code" gorm:"size:128;uniqueIndex;comment:语义化标识，如 admin.games.read"`
        Group       string     `json:"group" gorm:"size:64;index;comment:API 分组，如 /admin/games"`
        Description string     `json:"description" gorm:"size:255"`
}

// TableName specifies the table name for Permission.
func (Permission) TableName() string <span class="cov0" title="0">{
        return "permissions"
}</span>






</pre>
		
		<pre class="file" id="file71" style="display: none">package model

import "time"

// RankingType 排名类型
type RankingType string

const (
        // RankingTypeIncome 收入排名
        RankingTypeIncome RankingType = "income"
        // RankingTypeOrderCount 订单数量排名
        RankingTypeOrderCount RankingType = "order_count"
        // RankingTypeQuality 服务质量排名
        RankingTypeQuality RankingType = "quality"
        // RankingTypePopularity 人气排名
        RankingTypePopularity RankingType = "popularity"
)

// PlayerRanking 陪玩师排名
type PlayerRanking struct {
        ID           uint64      `gorm:"primaryKey;autoIncrement" json:"id"`
        PlayerID     uint64      `gorm:"not null;index" json:"playerId"`
        RankingType  RankingType `gorm:"type:varchar(32);not null;index" json:"rankingType"`
        Period       string      `gorm:"type:varchar(32);not null;index" json:"period"` // daily/weekly/monthly/yearly
        PeriodValue  string      `gorm:"type:varchar(32);not null;index" json:"periodValue"` // YYYY-MM-DD, YYYY-WW, YYYY-MM
        Rank         int         `gorm:"not null" json:"rank"`
        Score        float64     `gorm:"not null" json:"score"` // 排名分数
        OrderCount   int64       `json:"orderCount"`
        IncomeCents  int64       `json:"incomeCents"`
        AvgRating    float32     `json:"avgRating"`
        BonusCents   int64       `gorm:"default:0" json:"bonusCents"` // 排名奖金
        CreatedAt    time.Time   `gorm:"autoCreateTime" json:"createdAt"`
        UpdatedAt    time.Time   `gorm:"autoUpdateTime" json:"updatedAt"`
}

// TableName 指定表名
func (PlayerRanking) TableName() string <span class="cov0" title="0">{
        return "player_rankings"
}</span>

// RankingCommissionConfig 排名抽成配置（使用JSON序列化存储阶梯规则）
type RankingCommissionConfig struct {
        ID          uint64      `gorm:"primaryKey;autoIncrement" json:"id"`
        Name        string      `gorm:"type:varchar(128);not null" json:"name"`
        RankingType RankingType `gorm:"type:varchar(32);not null;index" json:"rankingType"` // income/order_count
        Period      string      `gorm:"type:varchar(32);not null" json:"period"`            // monthly
        Month       string      `gorm:"type:varchar(7);not null;index" json:"month"`        // YYYY-MM
        RulesJSON   string      `gorm:"type:text;not null" json:"rulesJson"`                // JSON序列化的阶梯规则
        Description string      `gorm:"type:text" json:"description"`
        IsActive    bool        `gorm:"default:true;index" json:"isActive"`
        CreatedAt   time.Time   `gorm:"autoCreateTime" json:"createdAt"`
        UpdatedAt   time.Time   `gorm:"autoUpdateTime" json:"updatedAt"`
}

// TableName 指定表名
func (RankingCommissionConfig) TableName() string <span class="cov0" title="0">{
        return "ranking_commission_configs"
}</span>

// RankingCommissionRule 排名抽成规则（用于JSON序列化）
// 示例：[{"rankStart":1,"rankEnd":3,"commissionRate":10},{"rankStart":4,"rankEnd":8,"commissionRate":12}]
type RankingCommissionRule struct {
        RankStart      int `json:"rankStart"`      // 排名开始
        RankEnd        int `json:"rankEnd"`        // 排名结束  
        CommissionRate int `json:"commissionRate"` // 抽成比例（%）
}

// RankingReward 排名奖励（奖金）
type RankingReward struct {
        ID          uint64      `gorm:"primaryKey;autoIncrement" json:"id"`
        RankingType RankingType `gorm:"type:varchar(32);not null;index" json:"rankingType"`
        Period      string      `gorm:"type:varchar(32);not null" json:"period"`
        RankStart   int         `gorm:"not null" json:"rankStart"` // 排名开始（例如1）
        RankEnd     int         `gorm:"not null" json:"rankEnd"`   // 排名结束（例如10）
        RewardType  string      `gorm:"type:varchar(32);not null" json:"rewardType"` // fixed/percentage
        RewardValue int64       `gorm:"not null" json:"rewardValue"` // 固定金额（分）或百分比
        Description string      `gorm:"type:text" json:"description"`
        IsActive    bool        `gorm:"default:true" json:"isActive"`
        CreatedAt   time.Time   `gorm:"autoCreateTime" json:"createdAt"`
        UpdatedAt   time.Time   `gorm:"autoUpdateTime" json:"updatedAt"`
}

// TableName 指定表名
func (RankingReward) TableName() string <span class="cov0" title="0">{
        return "ranking_rewards"
}</span>

</pre>
		
		<pre class="file" id="file72" style="display: none">package model

import "fmt"

// Rating 表示 1-5 的打分区间。
type Rating uint8

// Rating bounds define the valid inclusive range.
const (
        RatingMin Rating = 1
        RatingMax Rating = 5
)

// Valid 检查评分是否在合法区间内。
func (r Rating) Valid() bool <span class="cov8" title="1">{
        return r &gt;= RatingMin &amp;&amp; r &lt;= RatingMax
}</span>

// MustRating 返回合法评分，越界时 panic，用于初始化常量或测试。
func MustRating(value uint8) Rating <span class="cov8" title="1">{
        r := Rating(value)
        if !r.Valid() </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("invalid rating: %d", value))</span>
        }
        <span class="cov8" title="1">return r</span>
}

// GormDataType 指定评分的默认列类型。
func (Rating) GormDataType() string <span class="cov0" title="0">{
        return "tinyint"
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">package model

// RoleSlug defines system predefined role identifiers.
type RoleSlug string

// RoleSlug values define system predefined roles.
const (
        RoleSlugSuperAdmin RoleSlug = "super_admin"
        RoleSlugAdmin      RoleSlug = "admin"
        RoleSlugPlayer     RoleSlug = "player"
        RoleSlugUser       RoleSlug = "user"
)

// RoleModel represents a platform role with custom permissions.
// Supports both system-predefined roles and user-defined custom roles.
type RoleModel struct {
        Base
        Slug        string `json:"slug" gorm:"size:64;uniqueIndex;not null;comment:角色标识"`
        Name        string `json:"name" gorm:"size:128;not null;comment:角色名称"`
        Description string `json:"description" gorm:"size:255;comment:角色描述"`
        IsSystem    bool   `json:"isSystem" gorm:"column:is_system;default:false;comment:是否系统角色（不可删除）"`

        // 关联关系
        Permissions []Permission `json:"permissions,omitempty" gorm:"many2many:role_permissions;foreignKey:ID;joinForeignKey:RoleID;References:ID;joinReferences:PermissionID"`
        Users       []User       `json:"users,omitempty" gorm:"many2many:user_roles;foreignKey:ID;joinForeignKey:RoleID;References:ID;joinReferences:UserID"`
}

// TableName specifies the table name for RoleModel.
func (RoleModel) TableName() string <span class="cov8" title="1">{
        return "roles"
}</span>

// IsSystemRole checks if this is a system-predefined role.
func (r *RoleModel) IsSystemRole() bool <span class="cov8" title="1">{
        return r.IsSystem
}</span>

// IsSuperAdmin checks if this role is super_admin.
func (r *RoleModel) IsSuperAdmin() bool <span class="cov8" title="1">{
        return r.Slug == string(RoleSlugSuperAdmin)
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">package model

import "time"

// RolePermission represents the many-to-many relationship between roles and permissions.
type RolePermission struct {
        RoleID       uint64    `json:"roleId" gorm:"column:role_id;primaryKey;not null"`
        PermissionID uint64    `json:"permissionId" gorm:"column:permission_id;primaryKey;not null"`
        CreatedAt    time.Time `json:"createdAt" gorm:"column:created_at;autoCreateTime"`

        // 外键关联
        Role       RoleModel  `json:"role,omitempty" gorm:"foreignKey:RoleID;constraint:OnDelete:CASCADE"`
        Permission Permission `json:"permission,omitempty" gorm:"foreignKey:PermissionID;constraint:OnDelete:CASCADE"`
}

// TableName specifies the table name for RolePermission.
func (RolePermission) TableName() string <span class="cov0" title="0">{
        return "role_permissions"
}</span>






</pre>
		
		<pre class="file" id="file75" style="display: none">package model

import "time"

// ServiceItemSubCategory 服务子类别
type ServiceItemSubCategory string

const (
        // SubCategorySolo 单人护航
        SubCategorySolo ServiceItemSubCategory = "solo"
        // SubCategoryTeam 团队护航
        SubCategoryTeam ServiceItemSubCategory = "team"
        // SubCategoryGift 礼物
        SubCategoryGift ServiceItemSubCategory = "gift"
)

// ServiceItem 服务项目表 (统一管理所有服务类型，包括礼物)
type ServiceItem struct {
        ID             uint64                 `gorm:"primaryKey;autoIncrement" json:"id"`
        ItemCode       string                 `gorm:"type:varchar(32);not null;uniqueIndex" json:"itemCode"`
        Name           string                 `gorm:"type:varchar(128);not null" json:"name"`
        Description    string                 `gorm:"type:text" json:"description"`
        Category       string                 `gorm:"type:varchar(32);not null;default:'escort';index" json:"category"` // 统一为 'escort'
        SubCategory    ServiceItemSubCategory `gorm:"type:varchar(32);not null;index" json:"subCategory"`               // solo/team/gift
        GameID         *uint64                `gorm:"index" json:"gameId"`
        PlayerID       *uint64                `gorm:"index" json:"playerId"`
        RankLevel      string                 `gorm:"type:varchar(32)" json:"rankLevel"`
        BasePriceCents int64                  `gorm:"not null;default:0" json:"basePriceCents"`
        ServiceHours   int                    `gorm:"not null;default:0" json:"serviceHours"`               // 服务时长（小时），礼物为0
        CommissionRate float64                `gorm:"type:decimal(5,2);default:0.20" json:"commissionRate"` // 抽成比例
        MinUsers       int                    `gorm:"default:1" json:"minUsers"`
        MaxPlayers     int                    `gorm:"default:1" json:"maxPlayers"`
        Tags           string                 `gorm:"type:json" json:"tags"` // JSON数组
        IconURL        string                 `gorm:"type:varchar(255)" json:"iconUrl"`
        IsActive       bool                   `gorm:"default:true;index" json:"isActive"`
        SortOrder      int                    `gorm:"default:0" json:"sortOrder"`
        CreatedAt      time.Time              `gorm:"autoCreateTime" json:"createdAt"`
        UpdatedAt      time.Time              `gorm:"autoUpdateTime" json:"updatedAt"`
}

// TableName 指定表名
func (ServiceItem) TableName() string <span class="cov8" title="1">{
        return "service_items"
}</span>

// IsGift 判断是否为礼物
func (s *ServiceItem) IsGift() bool <span class="cov8" title="1">{
        return s.SubCategory == SubCategoryGift
}</span>

// CalculateCommission 计算抽成
func (s *ServiceItem) CalculateCommission(quantity int) (platformCommission, playerIncome int64) <span class="cov8" title="1">{
        totalAmount := s.BasePriceCents * int64(quantity)
        platformCommission = int64(float64(totalAmount) * s.CommissionRate)
        playerIncome = totalAmount - platformCommission
        return platformCommission, playerIncome
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">package model

import "time"

// FollowStatus 关注状态
type FollowStatus string

const (
        // FollowStatusActive 关注中
        FollowStatusActive FollowStatus = "active"
        // FollowStatusBlocked 已拉黑
        FollowStatusBlocked FollowStatus = "blocked"
)

// Follow 关注关系
type Follow struct {
        ID         uint64       `gorm:"primaryKey;autoIncrement" json:"id"`
        UserID     uint64       `gorm:"not null;index:idx_user_player" json:"userId"`
        PlayerID   uint64       `gorm:"not null;index:idx_user_player" json:"playerId"`
        Status     FollowStatus `gorm:"type:varchar(32);not null;default:'active'" json:"status"`
        NotifyNewService bool   `gorm:"default:true" json:"notifyNewService"` // 新服务通知
        NotifyOnline     bool   `gorm:"default:true" json:"notifyOnline"`     // 上线通知
        CreatedAt  time.Time    `gorm:"autoCreateTime" json:"createdAt"`
        UpdatedAt  time.Time    `gorm:"autoUpdateTime" json:"updatedAt"`
}

// TableName 指定表名
func (Follow) TableName() string <span class="cov0" title="0">{
        return "follows"
}</span>

// Friendship 好友关系
type Friendship struct {
        ID         uint64    `gorm:"primaryKey;autoIncrement" json:"id"`
        UserID1    uint64    `gorm:"not null;index:idx_users" json:"userId1"` // 较小的用户ID
        UserID2    uint64    `gorm:"not null;index:idx_users" json:"userId2"` // 较大的用户ID
        Status     string    `gorm:"type:varchar(32);not null;default:'pending'" json:"status"` // pending/accepted/rejected
        InitiatorID uint64   `gorm:"not null" json:"initiatorId"` // 发起人ID
        CreatedAt  time.Time `gorm:"autoCreateTime" json:"createdAt"`
        UpdatedAt  time.Time `gorm:"autoUpdateTime" json:"updatedAt"`
        AcceptedAt *time.Time `json:"acceptedAt"`
}

// TableName 指定表名
func (Friendship) TableName() string <span class="cov0" title="0">{
        return "friendships"
}</span>

// Message 私信
type Message struct {
        ID         uint64    `gorm:"primaryKey;autoIncrement" json:"id"`
        SenderID   uint64    `gorm:"not null;index" json:"senderId"`
        ReceiverID uint64    `gorm:"not null;index" json:"receiverId"`
        Content    string    `gorm:"type:text;not null" json:"content"`
        IsRead     bool      `gorm:"default:false" json:"isRead"`
        ReadAt     *time.Time `json:"readAt"`
        CreatedAt  time.Time `gorm:"autoCreateTime;index" json:"createdAt"`
}

// TableName 指定表名
func (Message) TableName() string <span class="cov0" title="0">{
        return "messages"
}</span>

// Notification 通知
type Notification struct {
        ID         uint64    `gorm:"primaryKey;autoIncrement" json:"id"`
        UserID     uint64    `gorm:"not null;index" json:"userId"`
        Type       string    `gorm:"type:varchar(64);not null;index" json:"type"` // order/payment/follow/system
        Title      string    `gorm:"type:varchar(255);not null" json:"title"`
        Content    string    `gorm:"type:text" json:"content"`
        RelatedID  *uint64   `json:"relatedId"` // 关联的实体ID
        IsRead     bool      `gorm:"default:false;index" json:"isRead"`
        ReadAt     *time.Time `json:"readAt"`
        CreatedAt  time.Time `gorm:"autoCreateTime;index" json:"createdAt"`
}

// TableName 指定表名
func (Notification) TableName() string <span class="cov0" title="0">{
        return "notifications"
}</span>

// PlayerMoment 陪玩师动态
type PlayerMoment struct {
        ID        uint64    `gorm:"primaryKey;autoIncrement" json:"id"`
        PlayerID  uint64    `gorm:"not null;index" json:"playerId"`
        Content   string    `gorm:"type:text;not null" json:"content"`
        Images    string    `gorm:"type:text" json:"images"` // JSON数组
        LikeCount int64     `gorm:"default:0" json:"likeCount"`
        ViewCount int64     `gorm:"default:0" json:"viewCount"`
        CreatedAt time.Time `gorm:"autoCreateTime;index" json:"createdAt"`
        UpdatedAt time.Time `gorm:"autoUpdateTime" json:"updatedAt"`
}

// TableName 指定表名
func (PlayerMoment) TableName() string <span class="cov0" title="0">{
        return "player_moments"
}</span>

// MomentLike 动态点赞
type MomentLike struct {
        ID       uint64    `gorm:"primaryKey;autoIncrement" json:"id"`
        MomentID uint64    `gorm:"not null;index:idx_moment_user" json:"momentId"`
        UserID   uint64    `gorm:"not null;index:idx_moment_user" json:"userId"`
        CreatedAt time.Time `gorm:"autoCreateTime" json:"createdAt"`
}

// TableName 指定表名
func (MomentLike) TableName() string <span class="cov0" title="0">{
        return "moment_likes"
}</span>

// MomentComment 动态评论
type MomentComment struct {
        ID        uint64    `gorm:"primaryKey;autoIncrement" json:"id"`
        MomentID  uint64    `gorm:"not null;index" json:"momentId"`
        UserID    uint64    `gorm:"not null;index" json:"userId"`
        Content   string    `gorm:"type:text;not null" json:"content"`
        ParentID  *uint64   `gorm:"index" json:"parentId"` // 父评论ID（用于回复）
        CreatedAt time.Time `gorm:"autoCreateTime;index" json:"createdAt"`
}

// TableName 指定表名
func (MomentComment) TableName() string <span class="cov0" title="0">{
        return "moment_comments"
}</span>

</pre>
		
		<pre class="file" id="file77" style="display: none">package model

import "time"

// UserRole represents the many-to-many relationship between users and roles.
// One user can have multiple roles.
type UserRole struct {
        UserID    uint64    `json:"userId" gorm:"column:user_id;primaryKey;not null"`
        RoleID    uint64    `json:"roleId" gorm:"column:role_id;primaryKey;not null"`
        CreatedAt time.Time `json:"createdAt" gorm:"column:created_at;autoCreateTime"`

        // 外键关联
        User User      `json:"user,omitempty" gorm:"foreignKey:UserID;constraint:OnDelete:CASCADE"`
        Role RoleModel `json:"role,omitempty" gorm:"foreignKey:RoleID;constraint:OnDelete:CASCADE"`
}

// TableName specifies the table name for UserRole.
func (UserRole) TableName() string <span class="cov0" title="0">{
        return "user_roles"
}</span>






</pre>
		
		<pre class="file" id="file78" style="display: none">package model

import (
        "time"
)

// WithdrawStatus 提现状态
type WithdrawStatus string

const (
        // WithdrawStatusPending 待处理
        WithdrawStatusPending WithdrawStatus = "pending"
        // WithdrawStatusApproved 已批准
        WithdrawStatusApproved WithdrawStatus = "approved"
        // WithdrawStatusRejected 已拒绝
        WithdrawStatusRejected WithdrawStatus = "rejected"
        // WithdrawStatusCompleted 已完成
        WithdrawStatusCompleted WithdrawStatus = "completed"
        // WithdrawStatusFailed 失败
        WithdrawStatusFailed WithdrawStatus = "failed"
)

// WithdrawMethod 提现方式
type WithdrawMethod string

const (
        // WithdrawMethodAlipay 支付宝
        WithdrawMethodAlipay WithdrawMethod = "alipay"
        // WithdrawMethodWeChat 微信
        WithdrawMethodWeChat WithdrawMethod = "wechat"
        // WithdrawMethodBank 银行卡
        WithdrawMethodBank WithdrawMethod = "bank"
)

// Withdraw 提现记录
type Withdraw struct {
        ID          uint64         `gorm:"primaryKey;autoIncrement" json:"id"`
        PlayerID    uint64         `gorm:"not null;index" json:"playerId"`
        UserID      uint64         `gorm:"not null;index" json:"userId"` // 冗余字段，方便查询
        AmountCents int64          `gorm:"not null" json:"amountCents"`  // 提现金额（分）
        Method      WithdrawMethod `gorm:"type:varchar(32);not null" json:"method"`
        AccountInfo string         `gorm:"type:varchar(255);not null" json:"accountInfo"` // 账号信息（加密存储）
        Status      WithdrawStatus `gorm:"type:varchar(32);not null;default:'pending'" json:"status"`
        RejectReason string        `gorm:"type:text" json:"rejectReason"`    // 拒绝原因
        AdminRemark  string        `gorm:"type:text" json:"adminRemark"`     // 管理员备注
        ProcessedBy  *uint64       `gorm:"index" json:"processedBy"`         // 处理人ID
        ProcessedAt  *time.Time    `json:"processedAt"`                      // 处理时间
        CompletedAt  *time.Time    `json:"completedAt"`                      // 完成时间
        CreatedAt    time.Time     `gorm:"autoCreateTime" json:"createdAt"`
        UpdatedAt    time.Time     `gorm:"autoUpdateTime" json:"updatedAt"`
}

// TableName 指定表名
func (Withdraw) TableName() string <span class="cov0" title="0">{
        return "withdraws"
}</span>

</pre>
		
		<pre class="file" id="file79" style="display: none">package commission

import (
        "context"
        "time"

        "gamelink/internal/model"
        "gamelink/internal/repository"

        "gorm.io/gorm"
)

// CommissionRepository 抽成记录仓储接口
type CommissionRepository interface {
        // 抽成规则
        CreateRule(ctx context.Context, rule *model.CommissionRule) error
        GetRule(ctx context.Context, id uint64) (*model.CommissionRule, error)
        GetDefaultRule(ctx context.Context) (*model.CommissionRule, error)
        GetRuleForOrder(ctx context.Context, gameID *uint64, playerID *uint64, serviceType *string) (*model.CommissionRule, error)
        ListRules(ctx context.Context, opts CommissionRuleListOptions) ([]model.CommissionRule, int64, error)
        UpdateRule(ctx context.Context, rule *model.CommissionRule) error
        DeleteRule(ctx context.Context, id uint64) error

        // 抽成记录
        CreateRecord(ctx context.Context, record *model.CommissionRecord) error
        GetRecord(ctx context.Context, id uint64) (*model.CommissionRecord, error)
        GetRecordByOrderID(ctx context.Context, orderID uint64) (*model.CommissionRecord, error)
        ListRecords(ctx context.Context, opts CommissionRecordListOptions) ([]model.CommissionRecord, int64, error)
        UpdateRecord(ctx context.Context, record *model.CommissionRecord) error

        // 月度结算
        CreateSettlement(ctx context.Context, settlement *model.MonthlySettlement) error
        GetSettlement(ctx context.Context, id uint64) (*model.MonthlySettlement, error)
        GetSettlementByPlayerMonth(ctx context.Context, playerID uint64, month string) (*model.MonthlySettlement, error)
        ListSettlements(ctx context.Context, opts SettlementListOptions) ([]model.MonthlySettlement, int64, error)
        UpdateSettlement(ctx context.Context, settlement *model.MonthlySettlement) error

        // 统计查询
        GetMonthlyStats(ctx context.Context, month string) (*MonthlyStats, error)
        GetPlayerMonthlyIncome(ctx context.Context, playerID uint64, month string) (int64, error)
}

// CommissionRuleListOptions 抽成规则查询选项
type CommissionRuleListOptions struct {
        Type     *string
        GameID   *uint64
        PlayerID *uint64
        IsActive *bool
        Page     int
        PageSize int
}

// CommissionRecordListOptions 抽成记录查询选项
type CommissionRecordListOptions struct {
        OrderID          *uint64
        PlayerID         *uint64
        SettlementStatus *string
        SettlementMonth  *string
        DateFrom         *time.Time
        DateTo           *time.Time
        Page             int
        PageSize         int
}

// SettlementListOptions 月度结算查询选项
type SettlementListOptions struct {
        PlayerID        *uint64
        SettlementMonth *string
        Status          *string
        Page            int
        PageSize        int
}

// MonthlyStats 月度统计数据
type MonthlyStats struct {
        TotalOrders       int64
        TotalIncome       int64
        TotalCommission   int64
        TotalPlayerIncome int64
}

type commissionRepository struct {
        db *gorm.DB
}

// NewCommissionRepository 创建抽成记录仓储
func NewCommissionRepository(db *gorm.DB) CommissionRepository <span class="cov8" title="1">{
        return &amp;commissionRepository{db: db}
}</span>

// CreateRule 创建抽成规则
func (r *commissionRepository) CreateRule(ctx context.Context, rule *model.CommissionRule) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Create(rule).Error
}</span>

// GetRule 获取抽成规则
func (r *commissionRepository) GetRule(ctx context.Context, id uint64) (*model.CommissionRule, error) <span class="cov8" title="1">{
        var rule model.CommissionRule
        err := r.db.WithContext(ctx).First(&amp;rule, id).Error
        if err != nil </span><span class="cov8" title="1">{
                if err == gorm.ErrRecordNotFound </span><span class="cov8" title="1">{
                        return nil, repository.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;rule, nil</span>
}

// GetDefaultRule 获取默认抽成规则
func (r *commissionRepository) GetDefaultRule(ctx context.Context) (*model.CommissionRule, error) <span class="cov8" title="1">{
        var rule model.CommissionRule
        err := r.db.WithContext(ctx).
                Where("type = ? AND is_active = ?", "default", true).
                Where("game_id IS NULL AND player_id IS NULL AND service_type IS NULL").
                First(&amp;rule).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, repository.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;rule, nil</span>
}

// GetRuleForOrder 获取订单适用的抽成规则（优先级：特定玩家 &gt; 特定游戏 &gt; 特定服务类型 &gt; 默认�?
func (r *commissionRepository) GetRuleForOrder(ctx context.Context, gameID *uint64, playerID *uint64, serviceType *string) (*model.CommissionRule, error) <span class="cov8" title="1">{
        var rule model.CommissionRule

        // 1. 尝试获取玩家专属规则
        if playerID != nil </span><span class="cov8" title="1">{
                err := r.db.WithContext(ctx).
                        Where("player_id = ? AND is_active = ?", *playerID, true).
                        First(&amp;rule).Error
                if err == nil </span><span class="cov8" title="1">{
                        return &amp;rule, nil
                }</span>
        }

        // 2. 尝试获取游戏专属规则
        <span class="cov8" title="1">if gameID != nil </span><span class="cov8" title="1">{
                err := r.db.WithContext(ctx).
                        Where("game_id = ? AND is_active = ?", *gameID, true).
                        Where("player_id IS NULL").
                        First(&amp;rule).Error
                if err == nil </span><span class="cov8" title="1">{
                        return &amp;rule, nil
                }</span>
        }

        // 3. 尝试获取服务类型规则
        <span class="cov8" title="1">if serviceType != nil </span><span class="cov0" title="0">{
                err := r.db.WithContext(ctx).
                        Where("service_type = ? AND is_active = ?", *serviceType, true).
                        Where("player_id IS NULL AND game_id IS NULL").
                        First(&amp;rule).Error
                if err == nil </span><span class="cov0" title="0">{
                        return &amp;rule, nil
                }</span>
        }

        // 4. 返回默认规则
        <span class="cov8" title="1">return r.GetDefaultRule(ctx)</span>
}

// ListRules 查询抽成规则列表
func (r *commissionRepository) ListRules(ctx context.Context, opts CommissionRuleListOptions) ([]model.CommissionRule, int64, error) <span class="cov8" title="1">{
        query := r.db.WithContext(ctx).Model(&amp;model.CommissionRule{})

        // 过滤条件
        if opts.Type != nil </span><span class="cov8" title="1">{
                query = query.Where("type = ?", *opts.Type)
        }</span>
        <span class="cov8" title="1">if opts.GameID != nil </span><span class="cov0" title="0">{
                query = query.Where("game_id = ?", *opts.GameID)
        }</span>
        <span class="cov8" title="1">if opts.PlayerID != nil </span><span class="cov0" title="0">{
                query = query.Where("player_id = ?", *opts.PlayerID)
        }</span>
        <span class="cov8" title="1">if opts.IsActive != nil </span><span class="cov8" title="1">{
                query = query.Where("is_active = ?", *opts.IsActive)
        }</span>

        // 统计总数
        <span class="cov8" title="1">var total int64
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 分页
        <span class="cov8" title="1">if opts.Page &lt; 1 </span><span class="cov0" title="0">{
                opts.Page = 1
        }</span>
        <span class="cov8" title="1">if opts.PageSize &lt; 1 </span><span class="cov0" title="0">{
                opts.PageSize = 20
        }</span>
        <span class="cov8" title="1">offset := (opts.Page - 1) * opts.PageSize

        // 查询数据
        var rules []model.CommissionRule
        err := query.Order("created_at DESC").Offset(offset).Limit(opts.PageSize).Find(&amp;rules).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">return rules, total, nil</span>
}

// UpdateRule 更新抽成规则
func (r *commissionRepository) UpdateRule(ctx context.Context, rule *model.CommissionRule) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Save(rule).Error
}</span>

// DeleteRule 删除抽成规则
func (r *commissionRepository) DeleteRule(ctx context.Context, id uint64) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Delete(&amp;model.CommissionRule{}, id).Error
}</span>

// CreateRecord 创建抽成记录
func (r *commissionRepository) CreateRecord(ctx context.Context, record *model.CommissionRecord) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Create(record).Error
}</span>

// GetRecord 获取抽成记录
func (r *commissionRepository) GetRecord(ctx context.Context, id uint64) (*model.CommissionRecord, error) <span class="cov8" title="1">{
        var record model.CommissionRecord
        err := r.db.WithContext(ctx).First(&amp;record, id).Error
        if err != nil </span><span class="cov8" title="1">{
                if err == gorm.ErrRecordNotFound </span><span class="cov8" title="1">{
                        return nil, repository.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;record, nil</span>
}

// GetRecordByOrderID 根据订单ID获取抽成记录
func (r *commissionRepository) GetRecordByOrderID(ctx context.Context, orderID uint64) (*model.CommissionRecord, error) <span class="cov8" title="1">{
        var record model.CommissionRecord
        err := r.db.WithContext(ctx).Where("order_id = ?", orderID).First(&amp;record).Error
        if err != nil </span><span class="cov8" title="1">{
                if err == gorm.ErrRecordNotFound </span><span class="cov8" title="1">{
                        return nil, repository.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;record, nil</span>
}

// ListRecords 查询抽成记录列表
func (r *commissionRepository) ListRecords(ctx context.Context, opts CommissionRecordListOptions) ([]model.CommissionRecord, int64, error) <span class="cov8" title="1">{
        query := r.db.WithContext(ctx).Model(&amp;model.CommissionRecord{})

        // 过滤条件
        if opts.OrderID != nil </span><span class="cov0" title="0">{
                query = query.Where("order_id = ?", *opts.OrderID)
        }</span>
        <span class="cov8" title="1">if opts.PlayerID != nil </span><span class="cov8" title="1">{
                query = query.Where("player_id = ?", *opts.PlayerID)
        }</span>
        <span class="cov8" title="1">if opts.SettlementStatus != nil </span><span class="cov0" title="0">{
                query = query.Where("settlement_status = ?", *opts.SettlementStatus)
        }</span>
        <span class="cov8" title="1">if opts.SettlementMonth != nil </span><span class="cov8" title="1">{
                query = query.Where("settlement_month = ?", *opts.SettlementMonth)
        }</span>
        <span class="cov8" title="1">if opts.DateFrom != nil </span><span class="cov0" title="0">{
                query = query.Where("created_at &gt;= ?", *opts.DateFrom)
        }</span>
        <span class="cov8" title="1">if opts.DateTo != nil </span><span class="cov0" title="0">{
                query = query.Where("created_at &lt; ?", *opts.DateTo)
        }</span>

        // 统计总数
        <span class="cov8" title="1">var total int64
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 分页
        <span class="cov8" title="1">if opts.Page &lt; 1 </span><span class="cov0" title="0">{
                opts.Page = 1
        }</span>
        <span class="cov8" title="1">if opts.PageSize &lt; 1 </span><span class="cov0" title="0">{
                opts.PageSize = 20
        }</span>
        <span class="cov8" title="1">offset := (opts.Page - 1) * opts.PageSize

        // 查询数据
        var records []model.CommissionRecord
        err := query.Order("created_at DESC").Offset(offset).Limit(opts.PageSize).Find(&amp;records).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">return records, total, nil</span>
}

// UpdateRecord 更新抽成记录
func (r *commissionRepository) UpdateRecord(ctx context.Context, record *model.CommissionRecord) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Save(record).Error
}</span>

// CreateSettlement 创建月度结算
func (r *commissionRepository) CreateSettlement(ctx context.Context, settlement *model.MonthlySettlement) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Create(settlement).Error
}</span>

// GetSettlement 获取月度结算
func (r *commissionRepository) GetSettlement(ctx context.Context, id uint64) (*model.MonthlySettlement, error) <span class="cov8" title="1">{
        var settlement model.MonthlySettlement
        err := r.db.WithContext(ctx).First(&amp;settlement, id).Error
        if err != nil </span><span class="cov8" title="1">{
                if err == gorm.ErrRecordNotFound </span><span class="cov8" title="1">{
                        return nil, repository.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;settlement, nil</span>
}

// GetSettlementByPlayerMonth 根据玩家和月份获取结�?
func (r *commissionRepository) GetSettlementByPlayerMonth(ctx context.Context, playerID uint64, month string) (*model.MonthlySettlement, error) <span class="cov8" title="1">{
        var settlement model.MonthlySettlement
        err := r.db.WithContext(ctx).
                Where("player_id = ? AND settlement_month = ?", playerID, month).
                First(&amp;settlement).Error
        if err != nil </span><span class="cov8" title="1">{
                if err == gorm.ErrRecordNotFound </span><span class="cov8" title="1">{
                        return nil, repository.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;settlement, nil</span>
}

// ListSettlements 查询月度结算列表
func (r *commissionRepository) ListSettlements(ctx context.Context, opts SettlementListOptions) ([]model.MonthlySettlement, int64, error) <span class="cov8" title="1">{
        query := r.db.WithContext(ctx).Model(&amp;model.MonthlySettlement{})

        // 过滤条件
        if opts.PlayerID != nil </span><span class="cov8" title="1">{
                query = query.Where("player_id = ?", *opts.PlayerID)
        }</span>
        <span class="cov8" title="1">if opts.SettlementMonth != nil </span><span class="cov8" title="1">{
                query = query.Where("settlement_month = ?", *opts.SettlementMonth)
        }</span>
        <span class="cov8" title="1">if opts.Status != nil </span><span class="cov0" title="0">{
                query = query.Where("status = ?", *opts.Status)
        }</span>

        // 统计总数
        <span class="cov8" title="1">var total int64
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 分页
        <span class="cov8" title="1">if opts.Page &lt; 1 </span><span class="cov0" title="0">{
                opts.Page = 1
        }</span>
        <span class="cov8" title="1">if opts.PageSize &lt; 1 </span><span class="cov0" title="0">{
                opts.PageSize = 20
        }</span>
        <span class="cov8" title="1">offset := (opts.Page - 1) * opts.PageSize

        // 查询数据
        var settlements []model.MonthlySettlement
        err := query.Order("settlement_month DESC, created_at DESC").
                Offset(offset).Limit(opts.PageSize).Find(&amp;settlements).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">return settlements, total, nil</span>
}

// UpdateSettlement 更新月度结算
func (r *commissionRepository) UpdateSettlement(ctx context.Context, settlement *model.MonthlySettlement) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Save(settlement).Error
}</span>

// GetMonthlyStats 获取月度统计数据
func (r *commissionRepository) GetMonthlyStats(ctx context.Context, month string) (*MonthlyStats, error) <span class="cov8" title="1">{
        stats := &amp;MonthlyStats{}

        // 统计该月所有已结算记录
        var result struct {
                TotalOrders       int64
                TotalIncome       int64
                TotalCommission   int64
                TotalPlayerIncome int64
        }

        err := r.db.WithContext(ctx).
                Model(&amp;model.CommissionRecord{}).
                Where("settlement_month = ? AND settlement_status = ?", month, "settled").
                Select(`
                        COUNT(*) as total_orders,
                        SUM(total_amount_cents) as total_income,
                        SUM(commission_cents) as total_commission,
                        SUM(player_income_cents) as total_player_income
                `).
                Scan(&amp;result).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">stats.TotalOrders = result.TotalOrders
        stats.TotalIncome = result.TotalIncome
        stats.TotalCommission = result.TotalCommission
        stats.TotalPlayerIncome = result.TotalPlayerIncome

        return stats, nil</span>
}

// GetPlayerMonthlyIncome 获取玩家月度收入
func (r *commissionRepository) GetPlayerMonthlyIncome(ctx context.Context, playerID uint64, month string) (int64, error) <span class="cov8" title="1">{
        var income int64
        err := r.db.WithContext(ctx).
                Model(&amp;model.CommissionRecord{}).
                Where("player_id = ? AND settlement_month = ?", playerID, month).
                Select("COALESCE(SUM(player_income_cents), 0)").
                Scan(&amp;income).Error
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return income, nil</span>
}

</pre>
		
		<pre class="file" id="file80" style="display: none">package common

import (
        "context"

        "gorm.io/gorm"

        "gamelink/internal/repository"
        "gamelink/internal/repository/game"
        operationlog "gamelink/internal/repository/operation_log"
        "gamelink/internal/repository/order"
        "gamelink/internal/repository/payment"
        "gamelink/internal/repository/player"
        playertag "gamelink/internal/repository/player_tag"
        "gamelink/internal/repository/review"
        "gamelink/internal/repository/user"
)

// Repos bundles repository interfaces bound to a specific DB (tx) handle.
type Repos struct {
        Games    repository.GameRepository
        Users    repository.UserRepository
        Players  repository.PlayerRepository
        Orders   repository.OrderRepository
        Payments repository.PaymentRepository
        Tags     repository.PlayerTagRepository
        OpLogs   repository.OperationLogRepository
        Reviews  repository.ReviewRepository
}

// UnitOfWork provides a simple transaction wrapper for GORM repositories.
type UnitOfWork struct {
        db *gorm.DB
}

// NewUnitOfWork creates a UnitOfWork from the root *gorm.DB.
func NewUnitOfWork(db *gorm.DB) *UnitOfWork <span class="cov8" title="1">{ return &amp;UnitOfWork{db: db} }</span>

// WithTx runs fn within a database transaction. If fn returns an error the
// transaction is rolled back; otherwise it is committed.
func (u *UnitOfWork) WithTx(ctx context.Context, fn func(r *Repos) error) error <span class="cov8" title="1">{
        return u.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                r := &amp;Repos{
                        Games:    game.NewGameRepository(tx),
                        Users:    user.NewUserRepository(tx),
                        Players:  player.NewPlayerRepository(tx),
                        Orders:   order.NewOrderRepository(tx),
                        Payments: payment.NewPaymentRepository(tx),
                        Tags:     playertag.NewPlayerTagRepository(tx),
                        OpLogs:   operationlog.NewOperationLogRepository(tx),
                        Reviews:  review.NewReviewRepository(tx),
                }
                return fn(r)
        }</span>)
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package game

import (
        "context"

        "gorm.io/gorm"

        "gamelink/internal/model"
        "gamelink/internal/repository"
)

// gormGameRepository 使用 GORM 实现游戏管理。
type gormGameRepository struct {
        db *gorm.DB
}

// NewGameRepository 创建 GORM 仓储实例。
func NewGameRepository(db *gorm.DB) repository.GameRepository <span class="cov8" title="1">{
        return &amp;gormGameRepository{db: db}
}</span>

// List returns all games ordered by creation time.
func (r *gormGameRepository) List(ctx context.Context) ([]model.Game, error) <span class="cov8" title="1">{
        var games []model.Game
        if err := r.db.WithContext(ctx).Order("created_at DESC").Find(&amp;games).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return games, nil</span>
}

// ListPaged returns a page of games and the total count.
func (r *gormGameRepository) ListPaged(ctx context.Context, page, pageSize int) ([]model.Game, int64, error) <span class="cov8" title="1">{
        page = repository.NormalizePage(page)
        pageSize = repository.NormalizePageSize(pageSize)
        offset := (page - 1) * pageSize

        query := r.db.WithContext(ctx).Model(&amp;model.Game{})

        var total int64
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">var games []model.Game
        if err := query.Order("created_at DESC").Offset(offset).Limit(pageSize).Find(&amp;games).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov8" title="1">return games, total, nil</span>
}

// Get returns a game by id.
func (r *gormGameRepository) Get(ctx context.Context, id uint64) (*model.Game, error) <span class="cov8" title="1">{
        var game model.Game
        err := r.db.WithContext(ctx).First(&amp;game, id).Error
        if err != nil </span><span class="cov8" title="1">{
                if err == gorm.ErrRecordNotFound </span><span class="cov8" title="1">{
                        return nil, repository.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;game, nil</span>
}

// Create inserts a new game.
func (r *gormGameRepository) Create(ctx context.Context, game *model.Game) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Create(game).Error
}</span>

// Update updates editable fields of a game.
func (r *gormGameRepository) Update(ctx context.Context, game *model.Game) error <span class="cov8" title="1">{
        tx := r.db.WithContext(ctx).Model(game).Updates(map[string]any{
                "key":         game.Key,
                "name":        game.Name,
                "category":    game.Category,
                "icon_url":    game.IconURL,
                "description": game.Description,
        })
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>
        <span class="cov8" title="1">if tx.RowsAffected == 0 </span><span class="cov8" title="1">{
                return repository.ErrNotFound
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Delete soft-deletes a game by id.
func (r *gormGameRepository) Delete(ctx context.Context, id uint64) error <span class="cov8" title="1">{
        tx := r.db.WithContext(ctx).Delete(&amp;model.Game{}, id)
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>
        <span class="cov8" title="1">if tx.RowsAffected == 0 </span><span class="cov8" title="1">{
                return repository.ErrNotFound
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: C:\Users\a2778\Desktop\code\GameLink\backend\internal\repository\interfaces.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        model "gamelink/internal/model"
        repository "gamelink/internal/repository"
        reflect "reflect"
        time "time"

        gomock "github.com/golang/mock/gomock"
)

// MockGameRepository is a mock of GameRepository interface.
type MockGameRepository struct {
        ctrl     *gomock.Controller
        recorder *MockGameRepositoryMockRecorder
}

// MockGameRepositoryMockRecorder is the mock recorder for MockGameRepository.
type MockGameRepositoryMockRecorder struct {
        mock *MockGameRepository
}

// NewMockGameRepository creates a new mock instance.
func NewMockGameRepository(ctrl *gomock.Controller) *MockGameRepository <span class="cov0" title="0">{
        mock := &amp;MockGameRepository{ctrl: ctrl}
        mock.recorder = &amp;MockGameRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGameRepository) EXPECT() *MockGameRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockGameRepository) Create(ctx context.Context, game *model.Game) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, game)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockGameRepositoryMockRecorder) Create(ctx, game interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockGameRepository)(nil).Create), ctx, game)
}</span>

// Delete mocks base method.
func (m *MockGameRepository) Delete(ctx context.Context, id uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockGameRepositoryMockRecorder) Delete(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockGameRepository)(nil).Delete), ctx, id)
}</span>

// Get mocks base method.
func (m *MockGameRepository) Get(ctx context.Context, id uint64) (*model.Game, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", ctx, id)
        ret0, _ := ret[0].(*model.Game)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockGameRepositoryMockRecorder) Get(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockGameRepository)(nil).Get), ctx, id)
}</span>

// List mocks base method.
func (m *MockGameRepository) List(ctx context.Context) ([]model.Game, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "List", ctx)
        ret0, _ := ret[0].([]model.Game)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// List indicates an expected call of List.
func (mr *MockGameRepositoryMockRecorder) List(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockGameRepository)(nil).List), ctx)
}</span>

// ListPaged mocks base method.
func (m *MockGameRepository) ListPaged(ctx context.Context, page, pageSize int) ([]model.Game, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListPaged", ctx, page, pageSize)
        ret0, _ := ret[0].([]model.Game)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// ListPaged indicates an expected call of ListPaged.
func (mr *MockGameRepositoryMockRecorder) ListPaged(ctx, page, pageSize interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListPaged", reflect.TypeOf((*MockGameRepository)(nil).ListPaged), ctx, page, pageSize)
}</span>

// Update mocks base method.
func (m *MockGameRepository) Update(ctx context.Context, game *model.Game) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, game)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockGameRepositoryMockRecorder) Update(ctx, game interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockGameRepository)(nil).Update), ctx, game)
}</span>

// MockUserRepository is a mock of UserRepository interface.
type MockUserRepository struct {
        ctrl     *gomock.Controller
        recorder *MockUserRepositoryMockRecorder
}

// MockUserRepositoryMockRecorder is the mock recorder for MockUserRepository.
type MockUserRepositoryMockRecorder struct {
        mock *MockUserRepository
}

// NewMockUserRepository creates a new mock instance.
func NewMockUserRepository(ctrl *gomock.Controller) *MockUserRepository <span class="cov0" title="0">{
        mock := &amp;MockUserRepository{ctrl: ctrl}
        mock.recorder = &amp;MockUserRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserRepository) EXPECT() *MockUserRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockUserRepository) Create(ctx context.Context, user *model.User) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockUserRepositoryMockRecorder) Create(ctx, user interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockUserRepository)(nil).Create), ctx, user)
}</span>

// Delete mocks base method.
func (m *MockUserRepository) Delete(ctx context.Context, id uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockUserRepositoryMockRecorder) Delete(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockUserRepository)(nil).Delete), ctx, id)
}</span>

// FindByEmail mocks base method.
func (m *MockUserRepository) FindByEmail(ctx context.Context, email string) (*model.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByEmail", ctx, email)
        ret0, _ := ret[0].(*model.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByEmail indicates an expected call of FindByEmail.
func (mr *MockUserRepositoryMockRecorder) FindByEmail(ctx, email interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByEmail", reflect.TypeOf((*MockUserRepository)(nil).FindByEmail), ctx, email)
}</span>

// FindByPhone mocks base method.
func (m *MockUserRepository) FindByPhone(ctx context.Context, phone string) (*model.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByPhone", ctx, phone)
        ret0, _ := ret[0].(*model.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByPhone indicates an expected call of FindByPhone.
func (mr *MockUserRepositoryMockRecorder) FindByPhone(ctx, phone interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByPhone", reflect.TypeOf((*MockUserRepository)(nil).FindByPhone), ctx, phone)
}</span>

// Get mocks base method.
func (m *MockUserRepository) Get(ctx context.Context, id uint64) (*model.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", ctx, id)
        ret0, _ := ret[0].(*model.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockUserRepositoryMockRecorder) Get(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockUserRepository)(nil).Get), ctx, id)
}</span>

// GetByPhone mocks base method.
func (m *MockUserRepository) GetByPhone(ctx context.Context, phone string) (*model.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByPhone", ctx, phone)
        ret0, _ := ret[0].(*model.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByPhone indicates an expected call of GetByPhone.
func (mr *MockUserRepositoryMockRecorder) GetByPhone(ctx, phone interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByPhone", reflect.TypeOf((*MockUserRepository)(nil).GetByPhone), ctx, phone)
}</span>

// List mocks base method.
func (m *MockUserRepository) List(ctx context.Context) ([]model.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "List", ctx)
        ret0, _ := ret[0].([]model.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// List indicates an expected call of List.
func (mr *MockUserRepositoryMockRecorder) List(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockUserRepository)(nil).List), ctx)
}</span>

// ListPaged mocks base method.
func (m *MockUserRepository) ListPaged(ctx context.Context, page, pageSize int) ([]model.User, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListPaged", ctx, page, pageSize)
        ret0, _ := ret[0].([]model.User)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// ListPaged indicates an expected call of ListPaged.
func (mr *MockUserRepositoryMockRecorder) ListPaged(ctx, page, pageSize interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListPaged", reflect.TypeOf((*MockUserRepository)(nil).ListPaged), ctx, page, pageSize)
}</span>

// ListWithFilters mocks base method.
func (m *MockUserRepository) ListWithFilters(ctx context.Context, opts repository.UserListOptions) ([]model.User, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListWithFilters", ctx, opts)
        ret0, _ := ret[0].([]model.User)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// ListWithFilters indicates an expected call of ListWithFilters.
func (mr *MockUserRepositoryMockRecorder) ListWithFilters(ctx, opts interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListWithFilters", reflect.TypeOf((*MockUserRepository)(nil).ListWithFilters), ctx, opts)
}</span>

// Update mocks base method.
func (m *MockUserRepository) Update(ctx context.Context, user *model.User) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockUserRepositoryMockRecorder) Update(ctx, user interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockUserRepository)(nil).Update), ctx, user)
}</span>

// MockPlayerRepository is a mock of PlayerRepository interface.
type MockPlayerRepository struct {
        ctrl     *gomock.Controller
        recorder *MockPlayerRepositoryMockRecorder
}

// MockPlayerRepositoryMockRecorder is the mock recorder for MockPlayerRepository.
type MockPlayerRepositoryMockRecorder struct {
        mock *MockPlayerRepository
}

// NewMockPlayerRepository creates a new mock instance.
func NewMockPlayerRepository(ctrl *gomock.Controller) *MockPlayerRepository <span class="cov0" title="0">{
        mock := &amp;MockPlayerRepository{ctrl: ctrl}
        mock.recorder = &amp;MockPlayerRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPlayerRepository) EXPECT() *MockPlayerRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockPlayerRepository) Create(ctx context.Context, player *model.Player) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, player)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockPlayerRepositoryMockRecorder) Create(ctx, player interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockPlayerRepository)(nil).Create), ctx, player)
}</span>

// Delete mocks base method.
func (m *MockPlayerRepository) Delete(ctx context.Context, id uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockPlayerRepositoryMockRecorder) Delete(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockPlayerRepository)(nil).Delete), ctx, id)
}</span>

// Get mocks base method.
func (m *MockPlayerRepository) Get(ctx context.Context, id uint64) (*model.Player, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", ctx, id)
        ret0, _ := ret[0].(*model.Player)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockPlayerRepositoryMockRecorder) Get(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockPlayerRepository)(nil).Get), ctx, id)
}</span>

// List mocks base method.
func (m *MockPlayerRepository) List(ctx context.Context) ([]model.Player, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "List", ctx)
        ret0, _ := ret[0].([]model.Player)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// List indicates an expected call of List.
func (mr *MockPlayerRepositoryMockRecorder) List(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockPlayerRepository)(nil).List), ctx)
}</span>

// ListPaged mocks base method.
func (m *MockPlayerRepository) ListPaged(ctx context.Context, page, pageSize int) ([]model.Player, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListPaged", ctx, page, pageSize)
        ret0, _ := ret[0].([]model.Player)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// ListPaged indicates an expected call of ListPaged.
func (mr *MockPlayerRepositoryMockRecorder) ListPaged(ctx, page, pageSize interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListPaged", reflect.TypeOf((*MockPlayerRepository)(nil).ListPaged), ctx, page, pageSize)
}</span>

// Update mocks base method.
func (m *MockPlayerRepository) Update(ctx context.Context, player *model.Player) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, player)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockPlayerRepositoryMockRecorder) Update(ctx, player interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockPlayerRepository)(nil).Update), ctx, player)
}</span>

// MockOrderRepository is a mock of OrderRepository interface.
type MockOrderRepository struct {
        ctrl     *gomock.Controller
        recorder *MockOrderRepositoryMockRecorder
}

// MockOrderRepositoryMockRecorder is the mock recorder for MockOrderRepository.
type MockOrderRepositoryMockRecorder struct {
        mock *MockOrderRepository
}

// NewMockOrderRepository creates a new mock instance.
func NewMockOrderRepository(ctrl *gomock.Controller) *MockOrderRepository <span class="cov0" title="0">{
        mock := &amp;MockOrderRepository{ctrl: ctrl}
        mock.recorder = &amp;MockOrderRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOrderRepository) EXPECT() *MockOrderRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockOrderRepository) Create(ctx context.Context, order *model.Order) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, order)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockOrderRepositoryMockRecorder) Create(ctx, order interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockOrderRepository)(nil).Create), ctx, order)
}</span>

// Delete mocks base method.
func (m *MockOrderRepository) Delete(ctx context.Context, id uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockOrderRepositoryMockRecorder) Delete(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockOrderRepository)(nil).Delete), ctx, id)
}</span>

// Get mocks base method.
func (m *MockOrderRepository) Get(ctx context.Context, id uint64) (*model.Order, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", ctx, id)
        ret0, _ := ret[0].(*model.Order)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockOrderRepositoryMockRecorder) Get(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockOrderRepository)(nil).Get), ctx, id)
}</span>

// List mocks base method.
func (m *MockOrderRepository) List(ctx context.Context, opts repository.OrderListOptions) ([]model.Order, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "List", ctx, opts)
        ret0, _ := ret[0].([]model.Order)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// List indicates an expected call of List.
func (mr *MockOrderRepositoryMockRecorder) List(ctx, opts interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockOrderRepository)(nil).List), ctx, opts)
}</span>

// Update mocks base method.
func (m *MockOrderRepository) Update(ctx context.Context, order *model.Order) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, order)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockOrderRepositoryMockRecorder) Update(ctx, order interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockOrderRepository)(nil).Update), ctx, order)
}</span>

// MockPaymentRepository is a mock of PaymentRepository interface.
type MockPaymentRepository struct {
        ctrl     *gomock.Controller
        recorder *MockPaymentRepositoryMockRecorder
}

// MockPaymentRepositoryMockRecorder is the mock recorder for MockPaymentRepository.
type MockPaymentRepositoryMockRecorder struct {
        mock *MockPaymentRepository
}

// NewMockPaymentRepository creates a new mock instance.
func NewMockPaymentRepository(ctrl *gomock.Controller) *MockPaymentRepository <span class="cov0" title="0">{
        mock := &amp;MockPaymentRepository{ctrl: ctrl}
        mock.recorder = &amp;MockPaymentRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPaymentRepository) EXPECT() *MockPaymentRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockPaymentRepository) Create(ctx context.Context, payment *model.Payment) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, payment)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockPaymentRepositoryMockRecorder) Create(ctx, payment interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockPaymentRepository)(nil).Create), ctx, payment)
}</span>

// Delete mocks base method.
func (m *MockPaymentRepository) Delete(ctx context.Context, id uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockPaymentRepositoryMockRecorder) Delete(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockPaymentRepository)(nil).Delete), ctx, id)
}</span>

// Get mocks base method.
func (m *MockPaymentRepository) Get(ctx context.Context, id uint64) (*model.Payment, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", ctx, id)
        ret0, _ := ret[0].(*model.Payment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockPaymentRepositoryMockRecorder) Get(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockPaymentRepository)(nil).Get), ctx, id)
}</span>

// List mocks base method.
func (m *MockPaymentRepository) List(ctx context.Context, opts repository.PaymentListOptions) ([]model.Payment, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "List", ctx, opts)
        ret0, _ := ret[0].([]model.Payment)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// List indicates an expected call of List.
func (mr *MockPaymentRepositoryMockRecorder) List(ctx, opts interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockPaymentRepository)(nil).List), ctx, opts)
}</span>

// Update mocks base method.
func (m *MockPaymentRepository) Update(ctx context.Context, payment *model.Payment) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, payment)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockPaymentRepositoryMockRecorder) Update(ctx, payment interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockPaymentRepository)(nil).Update), ctx, payment)
}</span>

// MockPermissionRepository is a mock of PermissionRepository interface.
type MockPermissionRepository struct {
        ctrl     *gomock.Controller
        recorder *MockPermissionRepositoryMockRecorder
}

// MockPermissionRepositoryMockRecorder is the mock recorder for MockPermissionRepository.
type MockPermissionRepositoryMockRecorder struct {
        mock *MockPermissionRepository
}

// NewMockPermissionRepository creates a new mock instance.
func NewMockPermissionRepository(ctrl *gomock.Controller) *MockPermissionRepository <span class="cov0" title="0">{
        mock := &amp;MockPermissionRepository{ctrl: ctrl}
        mock.recorder = &amp;MockPermissionRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPermissionRepository) EXPECT() *MockPermissionRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockPermissionRepository) Create(ctx context.Context, perm *model.Permission) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, perm)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockPermissionRepositoryMockRecorder) Create(ctx, perm interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockPermissionRepository)(nil).Create), ctx, perm)
}</span>

// Delete mocks base method.
func (m *MockPermissionRepository) Delete(ctx context.Context, id uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockPermissionRepositoryMockRecorder) Delete(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockPermissionRepository)(nil).Delete), ctx, id)
}</span>

// Get mocks base method.
func (m *MockPermissionRepository) Get(ctx context.Context, id uint64) (*model.Permission, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", ctx, id)
        ret0, _ := ret[0].(*model.Permission)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockPermissionRepositoryMockRecorder) Get(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockPermissionRepository)(nil).Get), ctx, id)
}</span>

// GetByMethodAndPath mocks base method.
func (m *MockPermissionRepository) GetByMethodAndPath(ctx context.Context, method, path string) (*model.Permission, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByMethodAndPath", ctx, method, path)
        ret0, _ := ret[0].(*model.Permission)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByMethodAndPath indicates an expected call of GetByMethodAndPath.
func (mr *MockPermissionRepositoryMockRecorder) GetByMethodAndPath(ctx, method, path interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByMethodAndPath", reflect.TypeOf((*MockPermissionRepository)(nil).GetByMethodAndPath), ctx, method, path)
}</span>

// GetByResource mocks base method.
func (m *MockPermissionRepository) GetByResource(ctx context.Context, resource, action string) (*model.Permission, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByResource", ctx, resource, action)
        ret0, _ := ret[0].(*model.Permission)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByResource indicates an expected call of GetByResource.
func (mr *MockPermissionRepositoryMockRecorder) GetByResource(ctx, resource, action interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByResource", reflect.TypeOf((*MockPermissionRepository)(nil).GetByResource), ctx, resource, action)
}</span>

// List mocks base method.
func (m *MockPermissionRepository) List(ctx context.Context) ([]model.Permission, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "List", ctx)
        ret0, _ := ret[0].([]model.Permission)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// List indicates an expected call of List.
func (mr *MockPermissionRepositoryMockRecorder) List(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockPermissionRepository)(nil).List), ctx)
}</span>

// ListByGroup mocks base method.
func (m *MockPermissionRepository) ListByGroup(ctx context.Context) (map[string][]model.Permission, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListByGroup", ctx)
        ret0, _ := ret[0].(map[string][]model.Permission)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListByGroup indicates an expected call of ListByGroup.
func (mr *MockPermissionRepositoryMockRecorder) ListByGroup(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListByGroup", reflect.TypeOf((*MockPermissionRepository)(nil).ListByGroup), ctx)
}</span>

// ListByRoleID mocks base method.
func (m *MockPermissionRepository) ListByRoleID(ctx context.Context, roleID uint64) ([]model.Permission, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListByRoleID", ctx, roleID)
        ret0, _ := ret[0].([]model.Permission)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListByRoleID indicates an expected call of ListByRoleID.
func (mr *MockPermissionRepositoryMockRecorder) ListByRoleID(ctx, roleID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListByRoleID", reflect.TypeOf((*MockPermissionRepository)(nil).ListByRoleID), ctx, roleID)
}</span>

// ListByUserID mocks base method.
func (m *MockPermissionRepository) ListByUserID(ctx context.Context, userID uint64) ([]model.Permission, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListByUserID", ctx, userID)
        ret0, _ := ret[0].([]model.Permission)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListByUserID indicates an expected call of ListByUserID.
func (mr *MockPermissionRepositoryMockRecorder) ListByUserID(ctx, userID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListByUserID", reflect.TypeOf((*MockPermissionRepository)(nil).ListByUserID), ctx, userID)
}</span>

// ListGroups mocks base method.
func (m *MockPermissionRepository) ListGroups(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListGroups", ctx)
        ret0, _ := ret[0].([]string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListGroups indicates an expected call of ListGroups.
func (mr *MockPermissionRepositoryMockRecorder) ListGroups(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListGroups", reflect.TypeOf((*MockPermissionRepository)(nil).ListGroups), ctx)
}</span>

// ListPaged mocks base method.
func (m *MockPermissionRepository) ListPaged(ctx context.Context, page, pageSize int) ([]model.Permission, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListPaged", ctx, page, pageSize)
        ret0, _ := ret[0].([]model.Permission)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// ListPaged indicates an expected call of ListPaged.
func (mr *MockPermissionRepositoryMockRecorder) ListPaged(ctx, page, pageSize interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListPaged", reflect.TypeOf((*MockPermissionRepository)(nil).ListPaged), ctx, page, pageSize)
}</span>

// Update mocks base method.
func (m *MockPermissionRepository) Update(ctx context.Context, perm *model.Permission) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, perm)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockPermissionRepositoryMockRecorder) Update(ctx, perm interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockPermissionRepository)(nil).Update), ctx, perm)
}</span>

// UpsertByMethodPath mocks base method.
func (m *MockPermissionRepository) UpsertByMethodPath(ctx context.Context, perm *model.Permission) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpsertByMethodPath", ctx, perm)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpsertByMethodPath indicates an expected call of UpsertByMethodPath.
func (mr *MockPermissionRepositoryMockRecorder) UpsertByMethodPath(ctx, perm interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertByMethodPath", reflect.TypeOf((*MockPermissionRepository)(nil).UpsertByMethodPath), ctx, perm)
}</span>

// MockRoleRepository is a mock of RoleRepository interface.
type MockRoleRepository struct {
        ctrl     *gomock.Controller
        recorder *MockRoleRepositoryMockRecorder
}

// MockRoleRepositoryMockRecorder is the mock recorder for MockRoleRepository.
type MockRoleRepositoryMockRecorder struct {
        mock *MockRoleRepository
}

// NewMockRoleRepository creates a new mock instance.
func NewMockRoleRepository(ctrl *gomock.Controller) *MockRoleRepository <span class="cov0" title="0">{
        mock := &amp;MockRoleRepository{ctrl: ctrl}
        mock.recorder = &amp;MockRoleRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRoleRepository) EXPECT() *MockRoleRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AddPermissions mocks base method.
func (m *MockRoleRepository) AddPermissions(ctx context.Context, roleID uint64, permissionIDs []uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddPermissions", ctx, roleID, permissionIDs)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// AddPermissions indicates an expected call of AddPermissions.
func (mr *MockRoleRepositoryMockRecorder) AddPermissions(ctx, roleID, permissionIDs interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPermissions", reflect.TypeOf((*MockRoleRepository)(nil).AddPermissions), ctx, roleID, permissionIDs)
}</span>

// AssignPermissions mocks base method.
func (m *MockRoleRepository) AssignPermissions(ctx context.Context, roleID uint64, permissionIDs []uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AssignPermissions", ctx, roleID, permissionIDs)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// AssignPermissions indicates an expected call of AssignPermissions.
func (mr *MockRoleRepositoryMockRecorder) AssignPermissions(ctx, roleID, permissionIDs interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AssignPermissions", reflect.TypeOf((*MockRoleRepository)(nil).AssignPermissions), ctx, roleID, permissionIDs)
}</span>

// AssignToUser mocks base method.
func (m *MockRoleRepository) AssignToUser(ctx context.Context, userID uint64, roleIDs []uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AssignToUser", ctx, userID, roleIDs)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// AssignToUser indicates an expected call of AssignToUser.
func (mr *MockRoleRepositoryMockRecorder) AssignToUser(ctx, userID, roleIDs interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AssignToUser", reflect.TypeOf((*MockRoleRepository)(nil).AssignToUser), ctx, userID, roleIDs)
}</span>

// CheckUserHasRole mocks base method.
func (m *MockRoleRepository) CheckUserHasRole(ctx context.Context, userID uint64, roleSlug string) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CheckUserHasRole", ctx, userID, roleSlug)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CheckUserHasRole indicates an expected call of CheckUserHasRole.
func (mr *MockRoleRepositoryMockRecorder) CheckUserHasRole(ctx, userID, roleSlug interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckUserHasRole", reflect.TypeOf((*MockRoleRepository)(nil).CheckUserHasRole), ctx, userID, roleSlug)
}</span>

// Create mocks base method.
func (m *MockRoleRepository) Create(ctx context.Context, role *model.RoleModel) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, role)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockRoleRepositoryMockRecorder) Create(ctx, role interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockRoleRepository)(nil).Create), ctx, role)
}</span>

// Delete mocks base method.
func (m *MockRoleRepository) Delete(ctx context.Context, id uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockRoleRepositoryMockRecorder) Delete(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockRoleRepository)(nil).Delete), ctx, id)
}</span>

// Get mocks base method.
func (m *MockRoleRepository) Get(ctx context.Context, id uint64) (*model.RoleModel, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", ctx, id)
        ret0, _ := ret[0].(*model.RoleModel)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockRoleRepositoryMockRecorder) Get(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockRoleRepository)(nil).Get), ctx, id)
}</span>

// GetBySlug mocks base method.
func (m *MockRoleRepository) GetBySlug(ctx context.Context, slug string) (*model.RoleModel, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetBySlug", ctx, slug)
        ret0, _ := ret[0].(*model.RoleModel)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetBySlug indicates an expected call of GetBySlug.
func (mr *MockRoleRepositoryMockRecorder) GetBySlug(ctx, slug interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBySlug", reflect.TypeOf((*MockRoleRepository)(nil).GetBySlug), ctx, slug)
}</span>

// GetWithPermissions mocks base method.
func (m *MockRoleRepository) GetWithPermissions(ctx context.Context, id uint64) (*model.RoleModel, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetWithPermissions", ctx, id)
        ret0, _ := ret[0].(*model.RoleModel)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetWithPermissions indicates an expected call of GetWithPermissions.
func (mr *MockRoleRepositoryMockRecorder) GetWithPermissions(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWithPermissions", reflect.TypeOf((*MockRoleRepository)(nil).GetWithPermissions), ctx, id)
}</span>

// List mocks base method.
func (m *MockRoleRepository) List(ctx context.Context) ([]model.RoleModel, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "List", ctx)
        ret0, _ := ret[0].([]model.RoleModel)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// List indicates an expected call of List.
func (mr *MockRoleRepositoryMockRecorder) List(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockRoleRepository)(nil).List), ctx)
}</span>

// ListByUserID mocks base method.
func (m *MockRoleRepository) ListByUserID(ctx context.Context, userID uint64) ([]model.RoleModel, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListByUserID", ctx, userID)
        ret0, _ := ret[0].([]model.RoleModel)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListByUserID indicates an expected call of ListByUserID.
func (mr *MockRoleRepositoryMockRecorder) ListByUserID(ctx, userID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListByUserID", reflect.TypeOf((*MockRoleRepository)(nil).ListByUserID), ctx, userID)
}</span>

// ListPaged mocks base method.
func (m *MockRoleRepository) ListPaged(ctx context.Context, page, pageSize int) ([]model.RoleModel, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListPaged", ctx, page, pageSize)
        ret0, _ := ret[0].([]model.RoleModel)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// ListPaged indicates an expected call of ListPaged.
func (mr *MockRoleRepositoryMockRecorder) ListPaged(ctx, page, pageSize interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListPaged", reflect.TypeOf((*MockRoleRepository)(nil).ListPaged), ctx, page, pageSize)
}</span>

// ListPagedWithFilter mocks base method.
func (m *MockRoleRepository) ListPagedWithFilter(ctx context.Context, page, pageSize int, keyword string, isSystem *bool) ([]model.RoleModel, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListPagedWithFilter", ctx, page, pageSize, keyword, isSystem)
        ret0, _ := ret[0].([]model.RoleModel)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// ListPagedWithFilter indicates an expected call of ListPagedWithFilter.
func (mr *MockRoleRepositoryMockRecorder) ListPagedWithFilter(ctx, page, pageSize, keyword, isSystem interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListPagedWithFilter", reflect.TypeOf((*MockRoleRepository)(nil).ListPagedWithFilter), ctx, page, pageSize, keyword, isSystem)
}</span>

// ListWithPermissions mocks base method.
func (m *MockRoleRepository) ListWithPermissions(ctx context.Context) ([]model.RoleModel, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListWithPermissions", ctx)
        ret0, _ := ret[0].([]model.RoleModel)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListWithPermissions indicates an expected call of ListWithPermissions.
func (mr *MockRoleRepositoryMockRecorder) ListWithPermissions(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListWithPermissions", reflect.TypeOf((*MockRoleRepository)(nil).ListWithPermissions), ctx)
}</span>

// RemoveFromUser mocks base method.
func (m *MockRoleRepository) RemoveFromUser(ctx context.Context, userID uint64, roleIDs []uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveFromUser", ctx, userID, roleIDs)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveFromUser indicates an expected call of RemoveFromUser.
func (mr *MockRoleRepositoryMockRecorder) RemoveFromUser(ctx, userID, roleIDs interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveFromUser", reflect.TypeOf((*MockRoleRepository)(nil).RemoveFromUser), ctx, userID, roleIDs)
}</span>

// RemovePermissions mocks base method.
func (m *MockRoleRepository) RemovePermissions(ctx context.Context, roleID uint64, permissionIDs []uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemovePermissions", ctx, roleID, permissionIDs)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemovePermissions indicates an expected call of RemovePermissions.
func (mr *MockRoleRepositoryMockRecorder) RemovePermissions(ctx, roleID, permissionIDs interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemovePermissions", reflect.TypeOf((*MockRoleRepository)(nil).RemovePermissions), ctx, roleID, permissionIDs)
}</span>

// Update mocks base method.
func (m *MockRoleRepository) Update(ctx context.Context, role *model.RoleModel) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, role)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockRoleRepositoryMockRecorder) Update(ctx, role interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockRoleRepository)(nil).Update), ctx, role)
}</span>

// MockPlayerTagRepository is a mock of PlayerTagRepository interface.
type MockPlayerTagRepository struct {
        ctrl     *gomock.Controller
        recorder *MockPlayerTagRepositoryMockRecorder
}

// MockPlayerTagRepositoryMockRecorder is the mock recorder for MockPlayerTagRepository.
type MockPlayerTagRepositoryMockRecorder struct {
        mock *MockPlayerTagRepository
}

// NewMockPlayerTagRepository creates a new mock instance.
func NewMockPlayerTagRepository(ctrl *gomock.Controller) *MockPlayerTagRepository <span class="cov0" title="0">{
        mock := &amp;MockPlayerTagRepository{ctrl: ctrl}
        mock.recorder = &amp;MockPlayerTagRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPlayerTagRepository) EXPECT() *MockPlayerTagRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetTags mocks base method.
func (m *MockPlayerTagRepository) GetTags(ctx context.Context, playerID uint64) ([]string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTags", ctx, playerID)
        ret0, _ := ret[0].([]string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetTags indicates an expected call of GetTags.
func (mr *MockPlayerTagRepositoryMockRecorder) GetTags(ctx, playerID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTags", reflect.TypeOf((*MockPlayerTagRepository)(nil).GetTags), ctx, playerID)
}</span>

// ReplaceTags mocks base method.
func (m *MockPlayerTagRepository) ReplaceTags(ctx context.Context, playerID uint64, tags []string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ReplaceTags", ctx, playerID, tags)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// ReplaceTags indicates an expected call of ReplaceTags.
func (mr *MockPlayerTagRepositoryMockRecorder) ReplaceTags(ctx, playerID, tags interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReplaceTags", reflect.TypeOf((*MockPlayerTagRepository)(nil).ReplaceTags), ctx, playerID, tags)
}</span>

// MockReviewRepository is a mock of ReviewRepository interface.
type MockReviewRepository struct {
        ctrl     *gomock.Controller
        recorder *MockReviewRepositoryMockRecorder
}

// MockReviewRepositoryMockRecorder is the mock recorder for MockReviewRepository.
type MockReviewRepositoryMockRecorder struct {
        mock *MockReviewRepository
}

// NewMockReviewRepository creates a new mock instance.
func NewMockReviewRepository(ctrl *gomock.Controller) *MockReviewRepository <span class="cov0" title="0">{
        mock := &amp;MockReviewRepository{ctrl: ctrl}
        mock.recorder = &amp;MockReviewRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockReviewRepository) EXPECT() *MockReviewRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockReviewRepository) Create(ctx context.Context, review *model.Review) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, review)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockReviewRepositoryMockRecorder) Create(ctx, review interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockReviewRepository)(nil).Create), ctx, review)
}</span>

// Delete mocks base method.
func (m *MockReviewRepository) Delete(ctx context.Context, id uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockReviewRepositoryMockRecorder) Delete(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockReviewRepository)(nil).Delete), ctx, id)
}</span>

// Get mocks base method.
func (m *MockReviewRepository) Get(ctx context.Context, id uint64) (*model.Review, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", ctx, id)
        ret0, _ := ret[0].(*model.Review)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockReviewRepositoryMockRecorder) Get(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockReviewRepository)(nil).Get), ctx, id)
}</span>

// List mocks base method.
func (m *MockReviewRepository) List(ctx context.Context, opts repository.ReviewListOptions) ([]model.Review, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "List", ctx, opts)
        ret0, _ := ret[0].([]model.Review)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// List indicates an expected call of List.
func (mr *MockReviewRepositoryMockRecorder) List(ctx, opts interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockReviewRepository)(nil).List), ctx, opts)
}</span>

// Update mocks base method.
func (m *MockReviewRepository) Update(ctx context.Context, review *model.Review) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, review)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockReviewRepositoryMockRecorder) Update(ctx, review interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockReviewRepository)(nil).Update), ctx, review)
}</span>

// MockOperationLogRepository is a mock of OperationLogRepository interface.
type MockOperationLogRepository struct {
        ctrl     *gomock.Controller
        recorder *MockOperationLogRepositoryMockRecorder
}

// MockOperationLogRepositoryMockRecorder is the mock recorder for MockOperationLogRepository.
type MockOperationLogRepositoryMockRecorder struct {
        mock *MockOperationLogRepository
}

// NewMockOperationLogRepository creates a new mock instance.
func NewMockOperationLogRepository(ctrl *gomock.Controller) *MockOperationLogRepository <span class="cov0" title="0">{
        mock := &amp;MockOperationLogRepository{ctrl: ctrl}
        mock.recorder = &amp;MockOperationLogRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOperationLogRepository) EXPECT() *MockOperationLogRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Append mocks base method.
func (m *MockOperationLogRepository) Append(ctx context.Context, log *model.OperationLog) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Append", ctx, log)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Append indicates an expected call of Append.
func (mr *MockOperationLogRepositoryMockRecorder) Append(ctx, log interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Append", reflect.TypeOf((*MockOperationLogRepository)(nil).Append), ctx, log)
}</span>

// ListByEntity mocks base method.
func (m *MockOperationLogRepository) ListByEntity(ctx context.Context, entityType string, entityID uint64, opts repository.OperationLogListOptions) ([]model.OperationLog, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListByEntity", ctx, entityType, entityID, opts)
        ret0, _ := ret[0].([]model.OperationLog)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// ListByEntity indicates an expected call of ListByEntity.
func (mr *MockOperationLogRepositoryMockRecorder) ListByEntity(ctx, entityType, entityID, opts interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListByEntity", reflect.TypeOf((*MockOperationLogRepository)(nil).ListByEntity), ctx, entityType, entityID, opts)
}</span>

// MockStatsRepository is a mock of StatsRepository interface.
type MockStatsRepository struct {
        ctrl     *gomock.Controller
        recorder *MockStatsRepositoryMockRecorder
}

// MockStatsRepositoryMockRecorder is the mock recorder for MockStatsRepository.
type MockStatsRepositoryMockRecorder struct {
        mock *MockStatsRepository
}

// NewMockStatsRepository creates a new mock instance.
func NewMockStatsRepository(ctrl *gomock.Controller) *MockStatsRepository <span class="cov0" title="0">{
        mock := &amp;MockStatsRepository{ctrl: ctrl}
        mock.recorder = &amp;MockStatsRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStatsRepository) EXPECT() *MockStatsRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AuditOverview mocks base method.
func (m *MockStatsRepository) AuditOverview(ctx context.Context, from, to *time.Time) (map[string]int64, map[string]int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AuditOverview", ctx, from, to)
        ret0, _ := ret[0].(map[string]int64)
        ret1, _ := ret[1].(map[string]int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// AuditOverview indicates an expected call of AuditOverview.
func (mr *MockStatsRepositoryMockRecorder) AuditOverview(ctx, from, to interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AuditOverview", reflect.TypeOf((*MockStatsRepository)(nil).AuditOverview), ctx, from, to)
}</span>

// AuditTrend mocks base method.
func (m *MockStatsRepository) AuditTrend(ctx context.Context, from, to *time.Time, entity, action string) ([]repository.DateValue, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AuditTrend", ctx, from, to, entity, action)
        ret0, _ := ret[0].([]repository.DateValue)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AuditTrend indicates an expected call of AuditTrend.
func (mr *MockStatsRepositoryMockRecorder) AuditTrend(ctx, from, to, entity, action interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AuditTrend", reflect.TypeOf((*MockStatsRepository)(nil).AuditTrend), ctx, from, to, entity, action)
}</span>

// Dashboard mocks base method.
func (m *MockStatsRepository) Dashboard(ctx context.Context) (repository.Dashboard, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Dashboard", ctx)
        ret0, _ := ret[0].(repository.Dashboard)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Dashboard indicates an expected call of Dashboard.
func (mr *MockStatsRepositoryMockRecorder) Dashboard(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Dashboard", reflect.TypeOf((*MockStatsRepository)(nil).Dashboard), ctx)
}</span>

// OrdersByStatus mocks base method.
func (m *MockStatsRepository) OrdersByStatus(ctx context.Context) (map[string]int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "OrdersByStatus", ctx)
        ret0, _ := ret[0].(map[string]int64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// OrdersByStatus indicates an expected call of OrdersByStatus.
func (mr *MockStatsRepositoryMockRecorder) OrdersByStatus(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OrdersByStatus", reflect.TypeOf((*MockStatsRepository)(nil).OrdersByStatus), ctx)
}</span>

// RevenueTrend mocks base method.
func (m *MockStatsRepository) RevenueTrend(ctx context.Context, days int) ([]repository.DateValue, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RevenueTrend", ctx, days)
        ret0, _ := ret[0].([]repository.DateValue)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// RevenueTrend indicates an expected call of RevenueTrend.
func (mr *MockStatsRepositoryMockRecorder) RevenueTrend(ctx, days interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RevenueTrend", reflect.TypeOf((*MockStatsRepository)(nil).RevenueTrend), ctx, days)
}</span>

// TopPlayers mocks base method.
func (m *MockStatsRepository) TopPlayers(ctx context.Context, limit int) ([]repository.PlayerTop, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "TopPlayers", ctx, limit)
        ret0, _ := ret[0].([]repository.PlayerTop)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// TopPlayers indicates an expected call of TopPlayers.
func (mr *MockStatsRepositoryMockRecorder) TopPlayers(ctx, limit interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TopPlayers", reflect.TypeOf((*MockStatsRepository)(nil).TopPlayers), ctx, limit)
}</span>

// UserGrowth mocks base method.
func (m *MockStatsRepository) UserGrowth(ctx context.Context, days int) ([]repository.DateValue, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UserGrowth", ctx, days)
        ret0, _ := ret[0].([]repository.DateValue)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UserGrowth indicates an expected call of UserGrowth.
func (mr *MockStatsRepositoryMockRecorder) UserGrowth(ctx, days interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserGrowth", reflect.TypeOf((*MockStatsRepository)(nil).UserGrowth), ctx, days)
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">package operationlog

import (
    "context"

    "gorm.io/gorm"

    "gamelink/internal/model"
        "gamelink/internal/repository"
)

type gormOperationLogRepository struct{ db *gorm.DB }

func NewOperationLogRepository(db *gorm.DB) repository.OperationLogRepository <span class="cov8" title="1">{ return &amp;gormOperationLogRepository{db: db} }</span>

func (r *gormOperationLogRepository) Append(ctx context.Context, log *model.OperationLog) error <span class="cov8" title="1">{
    return r.db.WithContext(ctx).Create(log).Error
}</span>

func (r *gormOperationLogRepository) ListByEntity(ctx context.Context, entityType string, entityID uint64, opts repository.OperationLogListOptions) ([]model.OperationLog, int64, error) <span class="cov8" title="1">{
    page := repository.NormalizePage(opts.Page)
    pageSize := repository.NormalizePageSize(opts.PageSize)
    offset := (page - 1) * pageSize
    q := r.db.WithContext(ctx).Model(&amp;model.OperationLog{}).Where("entity_type = ? AND entity_id = ?", entityType, entityID)
    if opts.Action != "" </span><span class="cov8" title="1">{
        q = q.Where("action = ?", opts.Action)
    }</span>
    <span class="cov8" title="1">if opts.ActorUserID != nil </span><span class="cov8" title="1">{
        q = q.Where("actor_user_id = ?", *opts.ActorUserID)
    }</span>
    <span class="cov8" title="1">if opts.DateFrom != nil </span><span class="cov8" title="1">{
        q = q.Where("created_at &gt;= ?", *opts.DateFrom)
    }</span>
    <span class="cov8" title="1">if opts.DateTo != nil </span><span class="cov8" title="1">{
        q = q.Where("created_at &lt;= ?", *opts.DateTo)
    }</span>
    <span class="cov8" title="1">var total int64
    if err := q.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{ return nil, 0, err }</span>
    <span class="cov8" title="1">var rows []model.OperationLog
    if err := q.Order("created_at DESC").Offset(offset).Limit(pageSize).Find(&amp;rows).Error; err != nil </span><span class="cov0" title="0">{ return nil, 0, err }</span>
    <span class="cov8" title="1">return rows, total, nil</span>
}

</pre>
		
		<pre class="file" id="file84" style="display: none">package order

import (
        "context"
        "strings"

        "gorm.io/gorm"

        "gamelink/internal/model"
        "gamelink/internal/repository"
)

// gormOrderRepository 使用 GORM 管理订单。
type gormOrderRepository struct {
        db *gorm.DB
}

// NewOrderRepository 创建实例。
func NewOrderRepository(db *gorm.DB) repository.OrderRepository <span class="cov8" title="1">{
        return &amp;gormOrderRepository{db: db}
}</span>

// Create inserts a new order.
func (r *gormOrderRepository) Create(ctx context.Context, order *model.Order) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Create(order).Error
}</span>

// List returns a page of orders and the total count with filters applied.
func (r *gormOrderRepository) List(ctx context.Context, opts repository.OrderListOptions) ([]model.Order, int64, error) <span class="cov8" title="1">{
        query := r.db.WithContext(ctx).Model(&amp;model.Order{})

        if len(opts.Statuses) &gt; 0 </span><span class="cov8" title="1">{
                query = query.Where("status IN ?", opts.Statuses)
        }</span>
        <span class="cov8" title="1">if opts.UserID != nil </span><span class="cov8" title="1">{
                query = query.Where("user_id = ?", *opts.UserID)
        }</span>
        <span class="cov8" title="1">if opts.PlayerID != nil </span><span class="cov8" title="1">{
                query = query.Where("player_id = ?", *opts.PlayerID)
        }</span>
        <span class="cov8" title="1">if opts.GameID != nil </span><span class="cov8" title="1">{
                query = query.Where("game_id = ?", *opts.GameID)
        }</span>
        <span class="cov8" title="1">if opts.DateFrom != nil </span><span class="cov8" title="1">{
                query = query.Where("created_at &gt;= ?", *opts.DateFrom)
        }</span>
        <span class="cov8" title="1">if opts.DateTo != nil </span><span class="cov8" title="1">{
                query = query.Where("created_at &lt;= ?", *opts.DateTo)
        }</span>
        <span class="cov8" title="1">if trimmed := strings.TrimSpace(opts.Keyword); trimmed != "" </span><span class="cov8" title="1">{
                like := "%" + trimmed + "%"
                query = query.Where("title LIKE ? OR description LIKE ?", like, like)
        }</span>

        <span class="cov8" title="1">var total int64
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">page := repository.NormalizePage(opts.Page)
        pageSize := repository.NormalizePageSize(opts.PageSize)
        offset := (page - 1) * pageSize

        var orders []model.Order
        if err := query.Order("created_at DESC").Offset(offset).Limit(pageSize).Find(&amp;orders).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">return orders, total, nil</span>
}

// Get returns an order by id.
func (r *gormOrderRepository) Get(ctx context.Context, id uint64) (*model.Order, error) <span class="cov8" title="1">{
        var order model.Order
        if err := r.db.WithContext(ctx).First(&amp;order, id).Error; err != nil </span><span class="cov8" title="1">{
                if err == gorm.ErrRecordNotFound </span><span class="cov8" title="1">{
                        return nil, repository.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;order, nil</span>
}

// Update updates editable fields of an order.
func (r *gormOrderRepository) Update(ctx context.Context, order *model.Order) error <span class="cov8" title="1">{
        tx := r.db.WithContext(ctx).Model(order).Where("id = ?", order.ID).Updates(map[string]any{
                "player_id":            order.PlayerID,
                "recipient_player_id":  order.RecipientPlayerID,
                "game_id":              order.GameID,
                "status":               order.Status,
                "quantity":             order.Quantity,
                "unit_price_cents":     order.UnitPriceCents,
                "total_price_cents":    order.TotalPriceCents,
                "commission_cents":     order.CommissionCents,
                "player_income_cents":  order.PlayerIncomeCents,
                "currency":             order.Currency,
                "title":                order.Title,
                "description":          order.Description,
                "scheduled_start":      order.ScheduledStart,
                "scheduled_end":        order.ScheduledEnd,
                "started_at":           order.StartedAt,
                "completed_at":         order.CompletedAt,
                "cancel_reason":        order.CancelReason,
                "refund_amount_cents":  order.RefundAmountCents,
                "refund_reason":        order.RefundReason,
                "refunded_at":          order.RefundedAt,
                "gift_message":         order.GiftMessage,
                "is_anonymous":         order.IsAnonymous,
                "delivered_at":         order.DeliveredAt,
        })
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>
        <span class="cov8" title="1">if tx.RowsAffected == 0 </span><span class="cov8" title="1">{
                return repository.ErrNotFound
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Delete soft-deletes an order by id.
func (r *gormOrderRepository) Delete(ctx context.Context, id uint64) error <span class="cov8" title="1">{
        tx := r.db.WithContext(ctx).Delete(&amp;model.Order{}, id)
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>
        <span class="cov8" title="1">if tx.RowsAffected == 0 </span><span class="cov8" title="1">{
                return repository.ErrNotFound
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package repository

const (
        defaultPage     = 1
        defaultPageSize = 20
        maxPageSize     = 100
)

// NormalizePage 返回合法的页码。
func NormalizePage(page int) int <span class="cov8" title="1">{
        if page &lt;= 0 </span><span class="cov8" title="1">{
                return defaultPage
        }</span>
        <span class="cov8" title="1">return page</span>
}

// NormalizePageSize 返回合法的分页大小。
func NormalizePageSize(size int) int <span class="cov8" title="1">{
        if size &lt;= 0 </span><span class="cov8" title="1">{
                return defaultPageSize
        }</span>
        <span class="cov8" title="1">if size &gt; maxPageSize </span><span class="cov8" title="1">{
                return maxPageSize
        }</span>
        <span class="cov8" title="1">return size</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package payment

import (
        "context"

        "gorm.io/gorm"

        "gamelink/internal/model"
        "gamelink/internal/repository"
)

// PaymentRepository ä½¿ç¨ GORM ç®¡çæ¯ä»è®°å½ã?
type gormPaymentRepository struct {
    db *gorm.DB
}

// NewPaymentRepository åå»ºå®ä¾ã?
func NewPaymentRepository(db *gorm.DB) repository.PaymentRepository <span class="cov8" title="1">{
    return &amp;gormPaymentRepository{db: db}
}</span>

// Create inserts a new payment row.
func (r *gormPaymentRepository) Create(ctx context.Context, payment *model.Payment) error <span class="cov8" title="1">{
    return r.db.WithContext(ctx).Create(payment).Error
}</span>

// List returns a page of payments and the total count with filters applied.
func (r *gormPaymentRepository) List(ctx context.Context, opts repository.PaymentListOptions) ([]model.Payment, int64, error) <span class="cov8" title="1">{
        query := r.db.WithContext(ctx).Model(&amp;model.Payment{})

        if len(opts.Statuses) &gt; 0 </span><span class="cov8" title="1">{
                query = query.Where("status IN ?", opts.Statuses)
        }</span>
        <span class="cov8" title="1">if len(opts.Methods) &gt; 0 </span><span class="cov8" title="1">{
                query = query.Where("method IN ?", opts.Methods)
        }</span>
        <span class="cov8" title="1">if opts.UserID != nil </span><span class="cov8" title="1">{
                query = query.Where("user_id = ?", *opts.UserID)
        }</span>
        <span class="cov8" title="1">if opts.OrderID != nil </span><span class="cov8" title="1">{
                query = query.Where("order_id = ?", *opts.OrderID)
        }</span>
        <span class="cov8" title="1">if opts.DateFrom != nil </span><span class="cov8" title="1">{
                query = query.Where("created_at &gt;= ?", *opts.DateFrom)
        }</span>
        <span class="cov8" title="1">if opts.DateTo != nil </span><span class="cov8" title="1">{
                query = query.Where("created_at &lt;= ?", *opts.DateTo)
        }</span>

        <span class="cov8" title="1">var total int64
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">page := repository.NormalizePage(opts.Page)
        pageSize := repository.NormalizePageSize(opts.PageSize)
        offset := (page - 1) * pageSize

        var payments []model.Payment
        if err := query.Order("created_at DESC").Offset(offset).Limit(pageSize).Find(&amp;payments).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">return payments, total, nil</span>
}

// Get returns a payment by id.
func (r *gormPaymentRepository) Get(ctx context.Context, id uint64) (*model.Payment, error) <span class="cov8" title="1">{
        var payment model.Payment
        if err := r.db.WithContext(ctx).First(&amp;payment, id).Error; err != nil </span><span class="cov8" title="1">{
                if err == gorm.ErrRecordNotFound </span><span class="cov8" title="1">{
                        return nil, repository.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;payment, nil</span>
}

// Update updates editable fields of a payment.
func (r *gormPaymentRepository) Update(ctx context.Context, payment *model.Payment) error <span class="cov8" title="1">{
        tx := r.db.WithContext(ctx).Model(payment).Where("id = ?", payment.ID).Updates(map[string]any{
                "status":            payment.Status,
                "provider_trade_no": payment.ProviderTradeNo,
                "provider_raw":      payment.ProviderRaw,
                "paid_at":           payment.PaidAt,
                "refunded_at":       payment.RefundedAt,
        })
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>
        <span class="cov8" title="1">if tx.RowsAffected == 0 </span><span class="cov8" title="1">{
                return repository.ErrNotFound
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Delete soft-deletes a payment by id.
func (r *gormPaymentRepository) Delete(ctx context.Context, id uint64) error <span class="cov8" title="1">{
        tx := r.db.WithContext(ctx).Delete(&amp;model.Payment{}, id)
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>
        <span class="cov8" title="1">if tx.RowsAffected == 0 </span><span class="cov8" title="1">{
                return repository.ErrNotFound
        }</span>
        <span class="cov8" title="1">return nil</span>
}

</pre>
		
		<pre class="file" id="file87" style="display: none">package permission

import (
        "context"
        "errors"

        "gorm.io/gorm"

        "gamelink/internal/model"
        "gamelink/internal/repository"
)

type permissionRepository struct {
        db *gorm.DB
}

// NewPermissionRepository åå»ºæéä»å¨å®ä¾ã?
func NewPermissionRepository(db *gorm.DB) repository.PermissionRepository <span class="cov8" title="1">{
        return &amp;permissionRepository{db: db}
}</span>

func (r *permissionRepository) List(ctx context.Context) ([]model.Permission, error) <span class="cov8" title="1">{
        var permissions []model.Permission
        err := r.db.WithContext(ctx).Order("permissions.\"group\", permissions.method, permissions.path").Find(&amp;permissions).Error
        return permissions, err
}</span>

func (r *permissionRepository) ListPaged(ctx context.Context, page, pageSize int) ([]model.Permission, int64, error) <span class="cov8" title="1">{
        var permissions []model.Permission
        var total int64

        query := r.db.WithContext(ctx).Model(&amp;model.Permission{})

        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">offset := (page - 1) * pageSize
        err := query.Order("permissions.\"group\", permissions.method, permissions.path").
                Offset(offset).
                Limit(pageSize).
                Find(&amp;permissions).Error

        return permissions, total, err</span>
}

// ListPagedWithFilter 分页获取权限列表（支持过滤）
func (r *permissionRepository) ListPagedWithFilter(ctx context.Context, page, pageSize int, keyword, method, group string) ([]model.Permission, int64, error) <span class="cov0" title="0">{
        var permissions []model.Permission
        var total int64

        query := r.db.WithContext(ctx).Model(&amp;model.Permission{})

        // 关键词搜索（匹配code, path, description）
        if keyword != "" </span><span class="cov0" title="0">{
                query = query.Where("code LIKE ? OR path LIKE ? OR description LIKE ?", "%"+keyword+"%", "%"+keyword+"%", "%"+keyword+"%")
        }</span>

        // HTTP方法过滤
        <span class="cov0" title="0">if method != "" </span><span class="cov0" title="0">{
                query = query.Where("method = ?", method)
        }</span>

        // 分组过滤
        <span class="cov0" title="0">if group != "" </span><span class="cov0" title="0">{
                query = query.Where("permissions.\"group\" = ?", group)
        }</span>

        // 统计总数
        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 分页查询
        <span class="cov0" title="0">offset := (page - 1) * pageSize
        err := query.Order("permissions.\"group\", permissions.method, permissions.path").
                Offset(offset).
                Limit(pageSize).
                Find(&amp;permissions).Error

        return permissions, total, err</span>
}

func (r *permissionRepository) ListByGroup(ctx context.Context) (map[string][]model.Permission, error) <span class="cov8" title="1">{
        var permissions []model.Permission
        err := r.db.WithContext(ctx).
                Order("permissions.\"group\", permissions.method, permissions.path").
                Find(&amp;permissions).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Group permissions by their group field
        <span class="cov8" title="1">grouped := make(map[string][]model.Permission)
        for _, p := range permissions </span><span class="cov8" title="1">{
                grouped[p.Group] = append(grouped[p.Group], p)
        }</span>
        <span class="cov8" title="1">return grouped, nil</span>
}

func (r *permissionRepository) ListGroups(ctx context.Context) ([]string, error) <span class="cov8" title="1">{
        var groups []string
        err := r.db.WithContext(ctx).
                Model(&amp;model.Permission{}).
                Distinct("permissions.\"group\"").
                Where("permissions.\"group\" != ''").
                Order("permissions.\"group\"").
                Pluck("permissions.\"group\"", &amp;groups).Error
        return groups, err
}</span>

func (r *permissionRepository) Get(ctx context.Context, id uint64) (*model.Permission, error) <span class="cov8" title="1">{
        var permission model.Permission
        err := r.db.WithContext(ctx).First(&amp;permission, id).Error
        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                return nil, repository.ErrNotFound
        }</span>
        <span class="cov8" title="1">return &amp;permission, err</span>
}

func (r *permissionRepository) GetByResource(ctx context.Context, resource, action string) (*model.Permission, error) <span class="cov0" title="0">{
        var permission model.Permission
        err := r.db.WithContext(ctx).
                Where("resource = ? AND action = ?", resource, action).
                First(&amp;permission).Error
        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return nil, repository.ErrNotFound
        }</span>
        <span class="cov0" title="0">return &amp;permission, err</span>
}

func (r *permissionRepository) GetByMethodAndPath(ctx context.Context, method, path string) (*model.Permission, error) <span class="cov8" title="1">{
        var permission model.Permission
        err := r.db.WithContext(ctx).
                Where("method = ? AND path = ?", method, path).
                First(&amp;permission).Error
        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                return nil, repository.ErrNotFound
        }</span>
        <span class="cov8" title="1">return &amp;permission, err</span>
}

func (r *permissionRepository) GetByCode(ctx context.Context, code string) (*model.Permission, error) <span class="cov8" title="1">{
        var permission model.Permission
        err := r.db.WithContext(ctx).Where("code = ?", code).First(&amp;permission).Error
        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                return nil, repository.ErrNotFound
        }</span>
        <span class="cov8" title="1">return &amp;permission, err</span>
}

func (r *permissionRepository) Create(ctx context.Context, permission *model.Permission) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Create(permission).Error
}</span>

func (r *permissionRepository) CreateBatch(ctx context.Context, permissions []model.Permission) error <span class="cov0" title="0">{
        if len(permissions) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return r.db.WithContext(ctx).Create(&amp;permissions).Error</span>
}

func (r *permissionRepository) Update(ctx context.Context, permission *model.Permission) error <span class="cov8" title="1">{
        result := r.db.WithContext(ctx).Model(permission).Updates(permission)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov8" title="1">if result.RowsAffected == 0 </span><span class="cov8" title="1">{
                return repository.ErrNotFound
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *permissionRepository) Delete(ctx context.Context, id uint64) error <span class="cov8" title="1">{
        result := r.db.WithContext(ctx).Delete(&amp;model.Permission{}, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov8" title="1">if result.RowsAffected == 0 </span><span class="cov8" title="1">{
                return repository.ErrNotFound
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *permissionRepository) UpsertByMethodPath(ctx context.Context, permission *model.Permission) error <span class="cov8" title="1">{
        // å°è¯æ¥æ¾ç°æè®°å½
        var existing model.Permission
        err := r.db.WithContext(ctx).
                Where("method = ? AND path = ?", permission.Method, permission.Path).
                First(&amp;existing).Error

        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                // ä¸å­å¨ï¼åå»ºæ°è®°å½?
                return r.db.WithContext(ctx).Create(permission).Error
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // å­å¨ï¼æ´æ°è®°å½ï¼ä¿ç IDï¼?
        <span class="cov8" title="1">permission.ID = existing.ID
        return r.db.WithContext(ctx).Model(&amp;existing).Updates(permission).Error</span>
}

func (r *permissionRepository) ListByRoleID(ctx context.Context, roleID uint64) ([]model.Permission, error) <span class="cov8" title="1">{
        var permissions []model.Permission
        err := r.db.WithContext(ctx).
                Joins("JOIN role_permissions ON role_permissions.permission_id = permissions.id").
                Where("role_permissions.role_id = ?", roleID).
                Order("permissions.\"group\", permissions.method, permissions.path").
                Find(&amp;permissions).Error
        return permissions, err
}</span>

func (r *permissionRepository) ListByUserID(ctx context.Context, userID uint64) ([]model.Permission, error) <span class="cov8" title="1">{
        var permissions []model.Permission
        err := r.db.WithContext(ctx).
                Distinct("permissions.*").
                Joins("JOIN role_permissions ON role_permissions.permission_id = permissions.id").
                Joins("JOIN user_roles ON user_roles.role_id = role_permissions.role_id").
                Where("user_roles.user_id = ?", userID).
                Order("permissions.\"group\", permissions.method, permissions.path").
                Find(&amp;permissions).Error
        return permissions, err
}</span>
</pre>
		
		<pre class="file" id="file88" style="display: none">package player

import (
        "context"

        "gorm.io/gorm"

        "gamelink/internal/model"
        "gamelink/internal/repository"
)

// PlayerRepository å®ç°éªç©èµæä»å¨ã?
type gormPlayerRepository struct {
        db *gorm.DB
}

// NewPlayerRepository åå»ºéªç©ä»å¨ã?
func NewPlayerRepository(db *gorm.DB) repository.PlayerRepository <span class="cov8" title="1">{
        return &amp;gormPlayerRepository{db: db}
}</span>

// List returns all players ordered by creation time.
func (r *gormPlayerRepository) List(ctx context.Context) ([]model.Player, error) <span class="cov8" title="1">{
        var players []model.Player
        if err := r.db.WithContext(ctx).Order("created_at DESC").Find(&amp;players).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return players, nil</span>
}

// ListPaged returns a page of players and the total count.
func (r *gormPlayerRepository) ListPaged(ctx context.Context, page, pageSize int) ([]model.Player, int64, error) <span class="cov8" title="1">{
        page = repository.NormalizePage(page)
        pageSize = repository.NormalizePageSize(pageSize)
        offset := (page - 1) * pageSize

        query := r.db.WithContext(ctx).Model(&amp;model.Player{})

        var total int64
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">var players []model.Player
        if err := query.Order("created_at DESC").Offset(offset).Limit(pageSize).Find(&amp;players).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov8" title="1">return players, total, nil</span>
}

// Get returns a player by id.
func (r *gormPlayerRepository) Get(ctx context.Context, id uint64) (*model.Player, error) <span class="cov8" title="1">{
        var player model.Player
        if err := r.db.WithContext(ctx).First(&amp;player, id).Error; err != nil </span><span class="cov8" title="1">{
                if err == gorm.ErrRecordNotFound </span><span class="cov8" title="1">{
                        return nil, repository.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;player, nil</span>
}

// Create inserts a new player.
func (r *gormPlayerRepository) Create(ctx context.Context, player *model.Player) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Create(player).Error
}</span>

// Update updates editable fields of a player.
func (r *gormPlayerRepository) Update(ctx context.Context, player *model.Player) error <span class="cov8" title="1">{
        tx := r.db.WithContext(ctx).Model(player).Updates(map[string]any{
                "nickname":            player.Nickname,
                "bio":                 player.Bio,
                "rating_average":      player.RatingAverage,
                "rating_count":        player.RatingCount,
                "hourly_rate_cents":   player.HourlyRateCents,
                "main_game_id":        player.MainGameID,
                "verification_status": player.VerificationStatus,
        })
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>
        <span class="cov8" title="1">if tx.RowsAffected == 0 </span><span class="cov8" title="1">{
                return repository.ErrNotFound
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Delete soft-deletes a player by id.
func (r *gormPlayerRepository) Delete(ctx context.Context, id uint64) error <span class="cov8" title="1">{
        tx := r.db.WithContext(ctx).Delete(&amp;model.Player{}, id)
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>
        <span class="cov8" title="1">if tx.RowsAffected == 0 </span><span class="cov8" title="1">{
                return repository.ErrNotFound
        }</span>
        <span class="cov8" title="1">return nil</span>
}

</pre>
		
		<pre class="file" id="file89" style="display: none">package playertag

import (
        "context"
        "strings"

        "gorm.io/gorm"

        "gamelink/internal/model"
        "gamelink/internal/repository"
)

type gormPlayerTagRepository struct{ db *gorm.DB }

func NewPlayerTagRepository(db *gorm.DB) repository.PlayerTagRepository <span class="cov8" title="1">{
        return &amp;gormPlayerTagRepository{db: db}
}</span>

func (r *gormPlayerTagRepository) GetTags(ctx context.Context, playerID uint64) ([]string, error) <span class="cov8" title="1">{
        items, err := r.List(ctx, playerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">tags := make([]string, len(items))
        for i, item := range items </span><span class="cov8" title="1">{
                tags[i] = item.Tag
        }</span>
        <span class="cov8" title="1">return tags, nil</span>
}

func (r *gormPlayerTagRepository) List(ctx context.Context, playerID uint64) ([]model.PlayerSkillTag, error) <span class="cov8" title="1">{
        var items []model.PlayerSkillTag
        if err := r.db.WithContext(ctx).Where("player_id = ?", playerID).Order("tag ASC").Find(&amp;items).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

func (r *gormPlayerTagRepository) ReplaceTags(ctx context.Context, playerID uint64, tags []string) error <span class="cov8" title="1">{
        // normalize + de-dup
        m := make(map[string]struct{}, len(tags))
        norm := make([]string, 0, len(tags))
        for _, t := range tags </span><span class="cov8" title="1">{
                v := strings.TrimSpace(strings.ToLower(t))
                if v == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, ok := m[v]; ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">m[v] = struct{}{}
                norm = append(norm, v)</span>
        }
        <span class="cov8" title="1">return r.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                // delete existing
                if err := tx.Where("player_id = ?", playerID).Delete(&amp;model.PlayerSkillTag{}).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // insert new
                <span class="cov8" title="1">if len(norm) == 0 </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">rows := make([]model.PlayerSkillTag, 0, len(norm))
                for _, v := range norm </span><span class="cov8" title="1">{
                        rows = append(rows, model.PlayerSkillTag{PlayerID: playerID, Tag: v})
                }</span>
                <span class="cov8" title="1">return tx.Create(&amp;rows).Error</span>
        })
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package ranking

import (
        "context"
        "errors"

        "gamelink/internal/model"

        "gorm.io/gorm"
)

var (
        // ErrNotFound 资源不存在错误
        ErrNotFound = errors.New("resource not found")
)

// RankingCommissionRepository 排名抽成配置仓储
type RankingCommissionRepository interface {
        // 配置管理
        CreateConfig(ctx context.Context, config *model.RankingCommissionConfig) error
        GetConfig(ctx context.Context, id uint64) (*model.RankingCommissionConfig, error)
        GetActiveConfigForMonth(ctx context.Context, rankingType model.RankingType, month string) (*model.RankingCommissionConfig, error)
        ListConfigs(ctx context.Context, opts RankingCommissionConfigListOptions) ([]model.RankingCommissionConfig, int64, error)
        UpdateConfig(ctx context.Context, config *model.RankingCommissionConfig) error
        DeleteConfig(ctx context.Context, id uint64) error
}

// RankingCommissionConfigListOptions 查询选项
type RankingCommissionConfigListOptions struct {
        RankingType *model.RankingType
        Month       *string
        IsActive    *bool
        Page        int
        PageSize    int
}

type rankingCommissionRepository struct {
        db *gorm.DB
}

// NewRankingCommissionRepository 创建排名抽成配置仓储
func NewRankingCommissionRepository(db *gorm.DB) RankingCommissionRepository <span class="cov0" title="0">{
        return &amp;rankingCommissionRepository{db: db}
}</span>

// CreateConfig 创建配置
func (r *rankingCommissionRepository) CreateConfig(ctx context.Context, config *model.RankingCommissionConfig) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(config).Error
}</span>

// GetConfig 获取配置
func (r *rankingCommissionRepository) GetConfig(ctx context.Context, id uint64) (*model.RankingCommissionConfig, error) <span class="cov0" title="0">{
        var config model.RankingCommissionConfig
        err := r.db.WithContext(ctx).First(&amp;config, id).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;config, nil</span>
}

// GetActiveConfigForMonth 获取指定月份的激活配置
func (r *rankingCommissionRepository) GetActiveConfigForMonth(ctx context.Context, rankingType model.RankingType, month string) (*model.RankingCommissionConfig, error) <span class="cov0" title="0">{
        var config model.RankingCommissionConfig
        err := r.db.WithContext(ctx).
                Where("ranking_type = ? AND month = ? AND is_active = ?", rankingType, month, true).
                First(&amp;config).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;config, nil</span>
}

// ListConfigs 查询配置列表
func (r *rankingCommissionRepository) ListConfigs(ctx context.Context, opts RankingCommissionConfigListOptions) ([]model.RankingCommissionConfig, int64, error) <span class="cov0" title="0">{
        query := r.db.WithContext(ctx).Model(&amp;model.RankingCommissionConfig{})

        if opts.RankingType != nil </span><span class="cov0" title="0">{
                query = query.Where("ranking_type = ?", *opts.RankingType)
        }</span>
        <span class="cov0" title="0">if opts.Month != nil </span><span class="cov0" title="0">{
                query = query.Where("month = ?", *opts.Month)
        }</span>
        <span class="cov0" title="0">if opts.IsActive != nil </span><span class="cov0" title="0">{
                query = query.Where("is_active = ?", *opts.IsActive)
        }</span>

        <span class="cov0" title="0">var total int64
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if opts.Page &lt; 1 </span><span class="cov0" title="0">{
                opts.Page = 1
        }</span>
        <span class="cov0" title="0">if opts.PageSize &lt; 1 </span><span class="cov0" title="0">{
                opts.PageSize = 20
        }</span>
        <span class="cov0" title="0">offset := (opts.Page - 1) * opts.PageSize

        var configs []model.RankingCommissionConfig
        err := query.Order("month DESC, created_at DESC").
                Offset(offset).Limit(opts.PageSize).Find(&amp;configs).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return configs, total, nil</span>
}

// UpdateConfig 更新配置
func (r *rankingCommissionRepository) UpdateConfig(ctx context.Context, config *model.RankingCommissionConfig) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(config).Error
}</span>

// DeleteConfig 删除配置
func (r *rankingCommissionRepository) DeleteConfig(ctx context.Context, id uint64) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Delete(&amp;model.RankingCommissionConfig{}, id).Error
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">package ranking

import (
        "context"

        "gamelink/internal/model"

        "gorm.io/gorm"
)

// RankingRepository 排名仓储接口
type RankingRepository interface {
        // 排名管理
        CreateRanking(ctx context.Context, ranking *model.PlayerRanking) error
        GetPlayerRanking(ctx context.Context, playerID uint64, rankingType model.RankingType, period, periodValue string) (*model.PlayerRanking, error)
        ListRankings(ctx context.Context, opts RankingListOptions) ([]model.PlayerRanking, int64, error)
        UpdateRanking(ctx context.Context, ranking *model.PlayerRanking) error

        // 排名奖励规则
        CreateReward(ctx context.Context, reward *model.RankingReward) error
        GetReward(ctx context.Context, id uint64) (*model.RankingReward, error)
        ListRewards(ctx context.Context, opts RewardListOptions) ([]model.RankingReward, int64, error)
        UpdateReward(ctx context.Context, reward *model.RankingReward) error
        DeleteReward(ctx context.Context, id uint64) error

        // 查询排名奖励
        GetRewardForRank(ctx context.Context, rankingType model.RankingType, period string, rank int) (*model.RankingReward, error)
}

// RankingListOptions 排名查询选项
type RankingListOptions struct {
        PlayerID    *uint64
        RankingType *model.RankingType
        Period      *string
        PeriodValue *string
        Page        int
        PageSize    int
}

// RewardListOptions 奖励规则查询选项
type RewardListOptions struct {
        RankingType *model.RankingType
        Period      *string
        IsActive    *bool
        Page        int
        PageSize    int
}

type rankingRepository struct {
        db *gorm.DB
}

// NewRankingRepository 创建排名仓储
func NewRankingRepository(db *gorm.DB) RankingRepository <span class="cov0" title="0">{
        return &amp;rankingRepository{db: db}
}</span>

// CreateRanking 创建排名记录
func (r *rankingRepository) CreateRanking(ctx context.Context, ranking *model.PlayerRanking) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(ranking).Error
}</span>

// GetPlayerRanking 获取陪玩师排�?
func (r *rankingRepository) GetPlayerRanking(ctx context.Context, playerID uint64, rankingType model.RankingType, period, periodValue string) (*model.PlayerRanking, error) <span class="cov0" title="0">{
        var ranking model.PlayerRanking
        err := r.db.WithContext(ctx).
                Where("player_id = ? AND ranking_type = ? AND period = ? AND period_value = ?",
                        playerID, rankingType, period, periodValue).
                First(&amp;ranking).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;ranking, nil</span>
}

// ListRankings 查询排名列表
func (r *rankingRepository) ListRankings(ctx context.Context, opts RankingListOptions) ([]model.PlayerRanking, int64, error) <span class="cov0" title="0">{
        query := r.db.WithContext(ctx).Model(&amp;model.PlayerRanking{})

        if opts.PlayerID != nil </span><span class="cov0" title="0">{
                query = query.Where("player_id = ?", *opts.PlayerID)
        }</span>
        <span class="cov0" title="0">if opts.RankingType != nil </span><span class="cov0" title="0">{
                query = query.Where("ranking_type = ?", *opts.RankingType)
        }</span>
        <span class="cov0" title="0">if opts.Period != nil </span><span class="cov0" title="0">{
                query = query.Where("period = ?", *opts.Period)
        }</span>
        <span class="cov0" title="0">if opts.PeriodValue != nil </span><span class="cov0" title="0">{
                query = query.Where("period_value = ?", *opts.PeriodValue)
        }</span>

        <span class="cov0" title="0">var total int64
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if opts.Page &lt; 1 </span><span class="cov0" title="0">{
                opts.Page = 1
        }</span>
        <span class="cov0" title="0">if opts.PageSize &lt; 1 </span><span class="cov0" title="0">{
                opts.PageSize = 20
        }</span>
        <span class="cov0" title="0">offset := (opts.Page - 1) * opts.PageSize

        var rankings []model.PlayerRanking
        err := query.Order("rank ASC").Offset(offset).Limit(opts.PageSize).Find(&amp;rankings).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return rankings, total, nil</span>
}

// UpdateRanking 更新排名
func (r *rankingRepository) UpdateRanking(ctx context.Context, ranking *model.PlayerRanking) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(ranking).Error
}</span>

// CreateReward 创建奖励规则
func (r *rankingRepository) CreateReward(ctx context.Context, reward *model.RankingReward) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(reward).Error
}</span>

// GetReward 获取奖励规则
func (r *rankingRepository) GetReward(ctx context.Context, id uint64) (*model.RankingReward, error) <span class="cov0" title="0">{
        var reward model.RankingReward
        err := r.db.WithContext(ctx).First(&amp;reward, id).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;reward, nil</span>
}

// ListRewards 查询奖励规则列表
func (r *rankingRepository) ListRewards(ctx context.Context, opts RewardListOptions) ([]model.RankingReward, int64, error) <span class="cov0" title="0">{
        query := r.db.WithContext(ctx).Model(&amp;model.RankingReward{})

        if opts.RankingType != nil </span><span class="cov0" title="0">{
                query = query.Where("ranking_type = ?", *opts.RankingType)
        }</span>
        <span class="cov0" title="0">if opts.Period != nil </span><span class="cov0" title="0">{
                query = query.Where("period = ?", *opts.Period)
        }</span>
        <span class="cov0" title="0">if opts.IsActive != nil </span><span class="cov0" title="0">{
                query = query.Where("is_active = ?", *opts.IsActive)
        }</span>

        <span class="cov0" title="0">var total int64
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if opts.Page &lt; 1 </span><span class="cov0" title="0">{
                opts.Page = 1
        }</span>
        <span class="cov0" title="0">if opts.PageSize &lt; 1 </span><span class="cov0" title="0">{
                opts.PageSize = 20
        }</span>
        <span class="cov0" title="0">offset := (opts.Page - 1) * opts.PageSize

        var rewards []model.RankingReward
        err := query.Order("rank_start ASC").Offset(offset).Limit(opts.PageSize).Find(&amp;rewards).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return rewards, total, nil</span>
}

// UpdateReward 更新奖励规则
func (r *rankingRepository) UpdateReward(ctx context.Context, reward *model.RankingReward) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(reward).Error
}</span>

// DeleteReward 删除奖励规则
func (r *rankingRepository) DeleteReward(ctx context.Context, id uint64) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Delete(&amp;model.RankingReward{}, id).Error
}</span>

// GetRewardForRank 获取指定排名对应的奖�?
func (r *rankingRepository) GetRewardForRank(ctx context.Context, rankingType model.RankingType, period string, rank int) (*model.RankingReward, error) <span class="cov0" title="0">{
        var reward model.RankingReward
        err := r.db.WithContext(ctx).
                Where("ranking_type = ? AND period = ? AND is_active = ?", rankingType, period, true).
                Where("rank_start &lt;= ? AND rank_end &gt;= ?", rank, rank).
                First(&amp;reward).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;reward, nil</span>
}

</pre>
		
		<pre class="file" id="file92" style="display: none">package review

import (
    "context"

    "gorm.io/gorm"

    "gamelink/internal/model"
        "gamelink/internal/repository"
)

type gormReviewRepository struct{ db *gorm.DB }

func NewReviewRepository(db *gorm.DB) repository.ReviewRepository <span class="cov8" title="1">{ return &amp;gormReviewRepository{db: db} }</span>

func (r *gormReviewRepository) List(ctx context.Context, opts repository.ReviewListOptions) ([]model.Review, int64, error) <span class="cov8" title="1">{
    page := repository.NormalizePage(opts.Page)
    size := repository.NormalizePageSize(opts.PageSize)
    offset := (page - 1) * size
    q := r.db.WithContext(ctx).Model(&amp;model.Review{})
    if opts.OrderID != nil </span><span class="cov8" title="1">{ q = q.Where("order_id = ?", *opts.OrderID) }</span>
    <span class="cov8" title="1">if opts.UserID != nil </span><span class="cov8" title="1">{ q = q.Where("user_id = ?", *opts.UserID) }</span>
    <span class="cov8" title="1">if opts.PlayerID != nil </span><span class="cov8" title="1">{ q = q.Where("player_id = ?", *opts.PlayerID) }</span>
    <span class="cov8" title="1">if opts.DateFrom != nil </span><span class="cov8" title="1">{ q = q.Where("created_at &gt;= ?", *opts.DateFrom) }</span>
    <span class="cov8" title="1">if opts.DateTo != nil </span><span class="cov8" title="1">{ q = q.Where("created_at &lt;= ?", *opts.DateTo) }</span>
    <span class="cov8" title="1">var total int64
    if err := q.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{ return nil, 0, err }</span>
    <span class="cov8" title="1">var items []model.Review
    if err := q.Order("created_at DESC").Offset(offset).Limit(size).Find(&amp;items).Error; err != nil </span><span class="cov0" title="0">{ return nil, 0, err }</span>
    <span class="cov8" title="1">return items, total, nil</span>
}

func (r *gormReviewRepository) Get(ctx context.Context, id uint64) (*model.Review, error) <span class="cov8" title="1">{
    var obj model.Review
    if err := r.db.WithContext(ctx).First(&amp;obj, id).Error; err != nil </span><span class="cov8" title="1">{
        if err == gorm.ErrRecordNotFound </span><span class="cov8" title="1">{ return nil, repository.ErrNotFound }</span>
        <span class="cov0" title="0">return nil, err</span>
    }
    <span class="cov8" title="1">return &amp;obj, nil</span>
}

func (r *gormReviewRepository) Create(ctx context.Context, obj *model.Review) error <span class="cov8" title="1">{
    return r.db.WithContext(ctx).Create(obj).Error
}</span>

func (r *gormReviewRepository) Update(ctx context.Context, obj *model.Review) error <span class="cov8" title="1">{
    tx := r.db.WithContext(ctx).Model(obj).Where("id = ?", obj.ID).Updates(map[string]any{
        "score":   obj.Score,
        "content": obj.Content,
    })
    if tx.Error != nil </span><span class="cov0" title="0">{ return tx.Error }</span>
    <span class="cov8" title="1">if tx.RowsAffected == 0 </span><span class="cov8" title="1">{ return repository.ErrNotFound }</span>
    <span class="cov8" title="1">return nil</span>
}

func (r *gormReviewRepository) Delete(ctx context.Context, id uint64) error <span class="cov8" title="1">{
    tx := r.db.WithContext(ctx).Delete(&amp;model.Review{}, id)
    if tx.Error != nil </span><span class="cov0" title="0">{ return tx.Error }</span>
    <span class="cov8" title="1">if tx.RowsAffected == 0 </span><span class="cov8" title="1">{ return repository.ErrNotFound }</span>
    <span class="cov8" title="1">return nil</span>
}


</pre>
		
		<pre class="file" id="file93" style="display: none">package role

import (
        "context"
        "errors"

        "gorm.io/gorm"

        "gamelink/internal/model"
        "gamelink/internal/repository"
)

type roleRepository struct {
        db *gorm.DB
}

// NewRoleRepository åå»ºè§è²ä»å¨å®ä¾ã?
func NewRoleRepository(db *gorm.DB) repository.RoleRepository <span class="cov8" title="1">{
        return &amp;roleRepository{db: db}
}</span>

func (r *roleRepository) List(ctx context.Context) ([]model.RoleModel, error) <span class="cov8" title="1">{
        var roles []model.RoleModel
        err := r.db.WithContext(ctx).Order("is_system DESC, slug").Find(&amp;roles).Error
        return roles, err
}</span>

func (r *roleRepository) ListPaged(ctx context.Context, page, pageSize int) ([]model.RoleModel, int64, error) <span class="cov8" title="1">{
        var roles []model.RoleModel
        var total int64

        query := r.db.WithContext(ctx).Model(&amp;model.RoleModel{})

        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">offset := (page - 1) * pageSize
        err := query.Order("is_system DESC, slug").
                Offset(offset).
                Limit(pageSize).
                Find(&amp;roles).Error

        return roles, total, err</span>
}

// ListPagedWithFilter 分页获取角色列表（支持过滤）
func (r *roleRepository) ListPagedWithFilter(ctx context.Context, page, pageSize int, keyword string, isSystem *bool) ([]model.RoleModel, int64, error) <span class="cov0" title="0">{
        var roles []model.RoleModel
        var total int64

        query := r.db.WithContext(ctx).Model(&amp;model.RoleModel{})

        // 关键词搜索（匹配name或slug）
        if keyword != "" </span><span class="cov0" title="0">{
                query = query.Where("name LIKE ? OR slug LIKE ?", "%"+keyword+"%", "%"+keyword+"%")
        }</span>

        // 系统角色过滤
        <span class="cov0" title="0">if isSystem != nil </span><span class="cov0" title="0">{
                query = query.Where("is_system = ?", *isSystem)
        }</span>

        // 统计总数
        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 分页查询
        <span class="cov0" title="0">offset := (page - 1) * pageSize
        err := query.Order("is_system DESC, slug").
                Offset(offset).
                Limit(pageSize).
                Find(&amp;roles).Error

        return roles, total, err</span>
}

func (r *roleRepository) ListWithPermissions(ctx context.Context) ([]model.RoleModel, error) <span class="cov8" title="1">{
        var roles []model.RoleModel
        err := r.db.WithContext(ctx).
                Preload("Permissions").
                Order("is_system DESC, slug").
                Find(&amp;roles).Error
        return roles, err
}</span>

func (r *roleRepository) Get(ctx context.Context, id uint64) (*model.RoleModel, error) <span class="cov8" title="1">{
        var role model.RoleModel
        err := r.db.WithContext(ctx).First(&amp;role, id).Error
        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                return nil, repository.ErrNotFound
        }</span>
        <span class="cov8" title="1">return &amp;role, err</span>
}

func (r *roleRepository) GetWithPermissions(ctx context.Context, id uint64) (*model.RoleModel, error) <span class="cov8" title="1">{
        var role model.RoleModel
        err := r.db.WithContext(ctx).
                Preload("Permissions").
                First(&amp;role, id).Error
        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return nil, repository.ErrNotFound
        }</span>
        <span class="cov8" title="1">return &amp;role, err</span>
}

func (r *roleRepository) GetBySlug(ctx context.Context, slug string) (*model.RoleModel, error) <span class="cov8" title="1">{
        var role model.RoleModel
        err := r.db.WithContext(ctx).Where("slug = ?", slug).First(&amp;role).Error
        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                return nil, repository.ErrNotFound
        }</span>
        <span class="cov8" title="1">return &amp;role, err</span>
}

func (r *roleRepository) Create(ctx context.Context, role *model.RoleModel) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Create(role).Error
}</span>

func (r *roleRepository) Update(ctx context.Context, role *model.RoleModel) error <span class="cov8" title="1">{
        result := r.db.WithContext(ctx).Model(role).Updates(role)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov8" title="1">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return repository.ErrNotFound
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *roleRepository) Delete(ctx context.Context, id uint64) error <span class="cov8" title="1">{
        // æ£æ¥æ¯å¦ä¸ºç³»ç»è§è²
        var role model.RoleModel
        if err := r.db.WithContext(ctx).First(&amp;role, id).Error; err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return repository.ErrNotFound
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">if role.IsSystem </span><span class="cov8" title="1">{
                return errors.New("cannot delete system role")
        }</span>

        <span class="cov8" title="1">result := r.db.WithContext(ctx).Delete(&amp;model.RoleModel{}, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov8" title="1">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return repository.ErrNotFound
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *roleRepository) AssignPermissions(ctx context.Context, roleID uint64, permissionIDs []uint64) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                // å é¤ç°ææéå³è
                if err := tx.Where("role_id = ?", roleID).Delete(&amp;model.RolePermission{}).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // æ·»å æ°çæéå³è
                <span class="cov8" title="1">if len(permissionIDs) &gt; 0 </span><span class="cov8" title="1">{
                        rolePermissions := make([]model.RolePermission, len(permissionIDs))
                        for i, permID := range permissionIDs </span><span class="cov8" title="1">{
                                rolePermissions[i] = model.RolePermission{
                                        RoleID:       roleID,
                                        PermissionID: permID,
                                }
                        }</span>
                        <span class="cov8" title="1">if err := tx.Create(&amp;rolePermissions).Error; err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        })
}

func (r *roleRepository) AddPermissions(ctx context.Context, roleID uint64, permissionIDs []uint64) error <span class="cov8" title="1">{
        if len(permissionIDs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">rolePermissions := make([]model.RolePermission, len(permissionIDs))
        for i, permID := range permissionIDs </span><span class="cov8" title="1">{
                rolePermissions[i] = model.RolePermission{
                        RoleID:       roleID,
                        PermissionID: permID,
                }
        }</span>

        // ä½¿ç¨äºå¡æ¹éæå¥ï¼å¿½ç¥å·²å­å¨çè®°å½?
        <span class="cov8" title="1">return r.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                for _, rp := range rolePermissions </span><span class="cov8" title="1">{
                        // æ£æ¥æ¯å¦å·²å­å¨
                        var existing model.RolePermission
                        err := tx.Where("role_id = ? AND permission_id = ?", rp.RoleID, rp.PermissionID).
                                First(&amp;existing).Error
                        if err == nil </span><span class="cov8" title="1">{
                                // å·²å­å¨ï¼è·³è¿
                                continue</span>
                        }
                        <span class="cov8" title="1">if !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // ä¸å­å¨ï¼åå»º
                        <span class="cov8" title="1">if err := tx.Create(&amp;rp).Error; err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        })
}

func (r *roleRepository) RemovePermissions(ctx context.Context, roleID uint64, permissionIDs []uint64) error <span class="cov8" title="1">{
        if len(permissionIDs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return r.db.WithContext(ctx).
                Where("role_id = ? AND permission_id IN ?", roleID, permissionIDs).
                Delete(&amp;model.RolePermission{}).Error</span>
}

func (r *roleRepository) ListByUserID(ctx context.Context, userID uint64) ([]model.RoleModel, error) <span class="cov8" title="1">{
        var roles []model.RoleModel
        err := r.db.WithContext(ctx).
                Joins("JOIN user_roles ON user_roles.role_id = roles.id").
                Where("user_roles.user_id = ?", userID).
                Order("roles.is_system DESC, roles.slug").
                Find(&amp;roles).Error
        return roles, err
}</span>

func (r *roleRepository) AssignToUser(ctx context.Context, userID uint64, roleIDs []uint64) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                // å é¤ç°æè§è²å³è
                if err := tx.Where("user_id = ?", userID).Delete(&amp;model.UserRole{}).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // æ·»å æ°çè§è²å³è
                <span class="cov8" title="1">if len(roleIDs) &gt; 0 </span><span class="cov8" title="1">{
                        userRoles := make([]model.UserRole, len(roleIDs))
                        for i, roleID := range roleIDs </span><span class="cov8" title="1">{
                                userRoles[i] = model.UserRole{
                                        UserID: userID,
                                        RoleID: roleID,
                                }
                        }</span>
                        <span class="cov8" title="1">if err := tx.Create(&amp;userRoles).Error; err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        })
}

func (r *roleRepository) RemoveFromUser(ctx context.Context, userID uint64, roleIDs []uint64) error <span class="cov8" title="1">{
        if len(roleIDs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return r.db.WithContext(ctx).
                Where("user_id = ? AND role_id IN ?", userID, roleIDs).
                Delete(&amp;model.UserRole{}).Error</span>
}

func (r *roleRepository) CheckUserHasRole(ctx context.Context, userID uint64, roleSlug string) (bool, error) <span class="cov8" title="1">{
        var count int64
        err := r.db.WithContext(ctx).
                Model(&amp;model.UserRole{}).
                Joins("JOIN roles ON roles.id = user_roles.role_id").
                Where("user_roles.user_id = ? AND roles.slug = ?", userID, roleSlug).
                Count(&amp;count).Error
        return count &gt; 0, err
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">package serviceitem

import (
        "context"

        "gamelink/internal/model"
        "gamelink/internal/repository"

        "gorm.io/gorm"
)

// ServiceItemRepository 服务项目仓储接口（统一管理所有服务类型，包括礼物�?
type ServiceItemRepository interface {
        // 基础CRUD
        Create(ctx context.Context, item *model.ServiceItem) error
        Get(ctx context.Context, id uint64) (*model.ServiceItem, error)
        GetByCode(ctx context.Context, itemCode string) (*model.ServiceItem, error)
        List(ctx context.Context, opts ServiceItemListOptions) ([]model.ServiceItem, int64, error)
        Update(ctx context.Context, item *model.ServiceItem) error
        Delete(ctx context.Context, id uint64) error

        // 批量操作
        BatchUpdateStatus(ctx context.Context, ids []uint64, isActive bool) error
        BatchUpdatePrice(ctx context.Context, ids []uint64, basePriceCents int64) error

        // 特殊查询
        GetGifts(ctx context.Context, page, pageSize int) ([]model.ServiceItem, int64, error)
        GetGameServices(ctx context.Context, gameID uint64, subCategory *model.ServiceItemSubCategory) ([]model.ServiceItem, error)
}

// ServiceItemListOptions 服务项目查询选项
type ServiceItemListOptions struct {
        Category    *string
        SubCategory *model.ServiceItemSubCategory
        GameID      *uint64
        PlayerID    *uint64
        IsActive    *bool
        Page        int
        PageSize    int
}

type serviceItemRepository struct {
        db *gorm.DB
}

// NewServiceItemRepository 创建服务项目仓储
func NewServiceItemRepository(db *gorm.DB) ServiceItemRepository <span class="cov8" title="1">{
        return &amp;serviceItemRepository{db: db}
}</span>

// Create 创建服务项目
func (r *serviceItemRepository) Create(ctx context.Context, item *model.ServiceItem) error <span class="cov8" title="1">{
        desiredActive := item.IsActive
        if err := r.db.WithContext(ctx).Create(item).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !desiredActive </span><span class="cov8" title="1">{
                if err := r.db.WithContext(ctx).
                        Model(item).
                        Update("is_active", false).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">item.IsActive = false</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Get 获取服务项目
func (r *serviceItemRepository) Get(ctx context.Context, id uint64) (*model.ServiceItem, error) <span class="cov8" title="1">{
        var item model.ServiceItem
        err := r.db.WithContext(ctx).First(&amp;item, id).Error
        if err != nil </span><span class="cov8" title="1">{
                if err == gorm.ErrRecordNotFound </span><span class="cov8" title="1">{
                        return nil, repository.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;item, nil</span>
}

// GetByCode 根据编码获取服务项目
func (r *serviceItemRepository) GetByCode(ctx context.Context, itemCode string) (*model.ServiceItem, error) <span class="cov8" title="1">{
        var item model.ServiceItem
        err := r.db.WithContext(ctx).Where("item_code = ?", itemCode).First(&amp;item).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, repository.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;item, nil</span>
}

// List 查询服务项目列表
func (r *serviceItemRepository) List(ctx context.Context, opts ServiceItemListOptions) ([]model.ServiceItem, int64, error) <span class="cov8" title="1">{
        query := r.db.WithContext(ctx).Model(&amp;model.ServiceItem{})

        // 过滤条件
        if opts.Category != nil </span><span class="cov0" title="0">{
                query = query.Where("category = ?", *opts.Category)
        }</span>
        <span class="cov8" title="1">if opts.SubCategory != nil </span><span class="cov8" title="1">{
                query = query.Where("sub_category = ?", *opts.SubCategory)
        }</span>
        <span class="cov8" title="1">if opts.GameID != nil </span><span class="cov8" title="1">{
                query = query.Where("game_id = ?", *opts.GameID)
        }</span>
        <span class="cov8" title="1">if opts.PlayerID != nil </span><span class="cov0" title="0">{
                query = query.Where("player_id = ?", *opts.PlayerID)
        }</span>
        <span class="cov8" title="1">if opts.IsActive != nil </span><span class="cov8" title="1">{
                query = query.Where("is_active = ?", *opts.IsActive)
        }</span>

        // 统计总数
        <span class="cov8" title="1">var total int64
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 分页
        <span class="cov8" title="1">if opts.Page &lt; 1 </span><span class="cov0" title="0">{
                opts.Page = 1
        }</span>
        <span class="cov8" title="1">if opts.PageSize &lt; 1 </span><span class="cov0" title="0">{
                opts.PageSize = 20
        }</span>
        <span class="cov8" title="1">offset := (opts.Page - 1) * opts.PageSize

        // 查询数据
        var items []model.ServiceItem
        err := query.Order("sort_order ASC, created_at DESC").
                Offset(offset).Limit(opts.PageSize).Find(&amp;items).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">return items, total, nil</span>
}

// Update 更新服务项目
func (r *serviceItemRepository) Update(ctx context.Context, item *model.ServiceItem) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Save(item).Error
}</span>

// Delete 删除服务项目
func (r *serviceItemRepository) Delete(ctx context.Context, id uint64) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Delete(&amp;model.ServiceItem{}, id).Error
}</span>

// BatchUpdateStatus 批量更新状�?
func (r *serviceItemRepository) BatchUpdateStatus(ctx context.Context, ids []uint64, isActive bool) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).
                Model(&amp;model.ServiceItem{}).
                Where("id IN ?", ids).
                Update("is_active", isActive).Error
}</span>

// BatchUpdatePrice 批量更新价格
func (r *serviceItemRepository) BatchUpdatePrice(ctx context.Context, ids []uint64, basePriceCents int64) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).
                Model(&amp;model.ServiceItem{}).
                Where("id IN ?", ids).
                Update("base_price_cents", basePriceCents).Error
}</span>

// GetGifts 获取礼物列表
func (r *serviceItemRepository) GetGifts(ctx context.Context, page, pageSize int) ([]model.ServiceItem, int64, error) <span class="cov8" title="1">{
        subCat := model.SubCategoryGift
        return r.List(ctx, ServiceItemListOptions{
                SubCategory: &amp;subCat,
                IsActive:    boolPtr(true),
                Page:        page,
                PageSize:    pageSize,
        })
}</span>

// GetGameServices 获取指定游戏的服�?
func (r *serviceItemRepository) GetGameServices(ctx context.Context, gameID uint64, subCategory *model.ServiceItemSubCategory) ([]model.ServiceItem, error) <span class="cov8" title="1">{
        query := r.db.WithContext(ctx).
                Where("game_id = ? AND is_active = ?", gameID, true)

        if subCategory != nil </span><span class="cov8" title="1">{
                query = query.Where("sub_category = ?", *subCategory)
        }</span>

        <span class="cov8" title="1">var items []model.ServiceItem
        err := query.Order("sort_order ASC").Find(&amp;items).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return items, nil</span>
}

func boolPtr(b bool) *bool <span class="cov8" title="1">{
        return &amp;b
}</span>

</pre>
		
		<pre class="file" id="file95" style="display: none">package stats

import (
        "context"
        "time"

        "gorm.io/gorm"

        "gamelink/internal/repository"
)

type gormStatsRepository struct{ db *gorm.DB }

func NewStatsRepository(db *gorm.DB) repository.StatsRepository <span class="cov8" title="1">{ return &amp;gormStatsRepository{db: db} }</span>

func (r *gormStatsRepository) Dashboard(ctx context.Context) (repository.Dashboard, error) <span class="cov8" title="1">{
        var d repository.Dashboard
        // counts
        if err := r.db.WithContext(ctx).Table("users").Count(&amp;d.TotalUsers).Error; err != nil </span><span class="cov0" title="0">{
                return d, err
        }</span>
        <span class="cov8" title="1">if err := r.db.WithContext(ctx).Table("players").Count(&amp;d.TotalPlayers).Error; err != nil </span><span class="cov0" title="0">{
                return d, err
        }</span>
        <span class="cov8" title="1">if err := r.db.WithContext(ctx).Table("games").Count(&amp;d.TotalGames).Error; err != nil </span><span class="cov0" title="0">{
                return d, err
        }</span>
        <span class="cov8" title="1">if err := r.db.WithContext(ctx).Table("orders").Count(&amp;d.TotalOrders).Error; err != nil </span><span class="cov0" title="0">{
                return d, err
        }</span>

        // orders by status
        <span class="cov8" title="1">d.OrdersByStatus = map[string]int64{}
        type pair struct {
                K string
                V int64
        }
        var rows []pair
        if err := r.db.WithContext(ctx).Table("orders").Select("status as k, COUNT(1) as v").Group("status").Scan(&amp;rows).Error; err != nil </span><span class="cov0" title="0">{
                return d, err
        }</span>
        <span class="cov8" title="1">for _, r2 := range rows </span><span class="cov8" title="1">{
                d.OrdersByStatus[r2.K] = r2.V
        }</span>

        // payments by status + total paid amount
        <span class="cov8" title="1">d.PaymentsByStatus = map[string]int64{}
        rows = nil
        if err := r.db.WithContext(ctx).Table("payments").Select("status as k, COUNT(1) as v").Group("status").Scan(&amp;rows).Error; err != nil </span><span class="cov0" title="0">{
                return d, err
        }</span>
        <span class="cov8" title="1">for _, r2 := range rows </span><span class="cov8" title="1">{
                d.PaymentsByStatus[r2.K] = r2.V
        }</span>
        <span class="cov8" title="1">if err := r.db.WithContext(ctx).Table("payments").Where("status = ?", "paid").Select("COALESCE(SUM(amount_cents),0)").Scan(&amp;d.TotalPaidAmountCents).Error; err != nil </span><span class="cov0" title="0">{
                return d, err
        }</span>
        <span class="cov8" title="1">return d, nil</span>
}

func (r *gormStatsRepository) RevenueTrend(ctx context.Context, days int) ([]repository.DateValue, error) <span class="cov8" title="1">{
        if days &lt;= 0 </span><span class="cov0" title="0">{
                days = 7
        }</span>
        <span class="cov8" title="1">since := time.Now().AddDate(0, 0, -days+1)
        var rows []repository.DateValue
        // GROUP BY date(paid_at)
        q := r.db.WithContext(ctx).Table("payments").Select("DATE(paid_at) as date, COALESCE(SUM(amount_cents),0) as value").
                Where("status = ? AND paid_at IS NOT NULL AND paid_at &gt;= ?", "paid", since).
                Group("DATE(paid_at)").Order("DATE(paid_at)")
        if err := q.Scan(&amp;rows).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return rows, nil</span>
}

func (r *gormStatsRepository) UserGrowth(ctx context.Context, days int) ([]repository.DateValue, error) <span class="cov8" title="1">{
        if days &lt;= 0 </span><span class="cov0" title="0">{
                days = 7
        }</span>
        <span class="cov8" title="1">since := time.Now().AddDate(0, 0, -days+1)
        var rows []repository.DateValue
        q := r.db.WithContext(ctx).Table("users").Select("DATE(created_at) as date, COUNT(1) as value").
                Where("created_at &gt;= ?", since).Group("DATE(created_at)").Order("DATE(created_at)")
        if err := q.Scan(&amp;rows).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return rows, nil</span>
}

func (r *gormStatsRepository) OrdersByStatus(ctx context.Context) (map[string]int64, error) <span class="cov8" title="1">{
        type pair struct {
                K string
                V int64
        }
        var rows []pair
        if err := r.db.WithContext(ctx).Table("orders").Select("status as k, COUNT(1) as v").Group("status").Scan(&amp;rows).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">m := map[string]int64{}
        for _, p := range rows </span><span class="cov8" title="1">{
                m[p.K] = p.V
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

func (r *gormStatsRepository) TopPlayers(ctx context.Context, limit int) ([]repository.PlayerTop, error) <span class="cov8" title="1">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span>
        <span class="cov8" title="1">var rows []repository.PlayerTop
        // ç®åï¼æ?rating_count æåº
        if err := r.db.WithContext(ctx).Table("players").Select("id as player_id, nickname, rating_average, rating_count").
                Order("rating_count DESC, rating_average DESC").Limit(limit).Scan(&amp;rows).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return rows, nil</span>
}

// AuditOverview returns counts grouped by entity_type and action.
func (r *gormStatsRepository) AuditOverview(ctx context.Context, from, to *time.Time) (map[string]int64, map[string]int64, error) <span class="cov8" title="1">{
        byEntity := map[string]int64{}
        byAction := map[string]int64{}
        q := r.db.WithContext(ctx).Table("operation_logs")
        if from != nil </span><span class="cov0" title="0">{
                q = q.Where("created_at &gt;= ?", *from)
        }</span>
        <span class="cov8" title="1">if to != nil </span><span class="cov0" title="0">{
                q = q.Where("created_at &lt;= ?", *to)
        }</span>
        <span class="cov8" title="1">type pair struct {
                K string
                V int64
        }
        var rows []pair
        if err := q.Select("entity_type as k, COUNT(1) as v").Group("entity_type").Scan(&amp;rows).Error; err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">for _, p := range rows </span><span class="cov8" title="1">{
                byEntity[p.K] = p.V
        }</span>
        <span class="cov8" title="1">rows = nil
        if err := q.Select("action as k, COUNT(1) as v").Group("action").Scan(&amp;rows).Error; err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">for _, p := range rows </span><span class="cov8" title="1">{
                byAction[p.K] = p.V
        }</span>
        <span class="cov8" title="1">return byEntity, byAction, nil</span>
}

// AuditTrend returns per-day counts within range, with optional entity/action filters.
func (r *gormStatsRepository) AuditTrend(ctx context.Context, from, to *time.Time, entity, action string) ([]repository.DateValue, error) <span class="cov8" title="1">{
        q := r.db.WithContext(ctx).Table("operation_logs")
        if from != nil </span><span class="cov0" title="0">{
                q = q.Where("created_at &gt;= ?", *from)
        }</span>
        <span class="cov8" title="1">if to != nil </span><span class="cov0" title="0">{
                q = q.Where("created_at &lt;= ?", *to)
        }</span>
        <span class="cov8" title="1">if entity != "" </span><span class="cov8" title="1">{
                q = q.Where("entity_type = ?", entity)
        }</span>
        <span class="cov8" title="1">if action != "" </span><span class="cov8" title="1">{
                q = q.Where("action = ?", action)
        }</span>
        <span class="cov8" title="1">var rows []repository.DateValue
        if err := q.Select("DATE(created_at) as date, COUNT(1) as value").Group("DATE(created_at)").Order("DATE(created_at)").Scan(&amp;rows).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return rows, nil</span>
}

// compile-time assertion
</pre>
		
		<pre class="file" id="file96" style="display: none">package user

import (
        "context"
        "strings"

        "gorm.io/gorm"

        "gamelink/internal/model"
        "gamelink/internal/repository"
)

// UserRepository å®ç°ç¨æ·ç®¡çä»å¨ã?
type gormUserRepository struct {
        db *gorm.DB
}

// NewUserRepository åå»ºç¨æ·ä»å¨ã?
func NewUserRepository(db *gorm.DB) repository.UserRepository <span class="cov8" title="1">{
        return &amp;gormUserRepository{db: db}
}</span>

// List returns all users ordered by creation time.
func (r *gormUserRepository) List(ctx context.Context) ([]model.User, error) <span class="cov8" title="1">{
        var users []model.User
        if err := r.db.WithContext(ctx).Order("created_at DESC").Find(&amp;users).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return users, nil</span>
}

// ListPaged è¿ååé¡µç¨æ·åè¡¨ä¸æ»æ°ã?
// ListPaged returns a page of users and the total count.
func (r *gormUserRepository) ListPaged(ctx context.Context, page, pageSize int) ([]model.User, int64, error) <span class="cov8" title="1">{
        page = repository.NormalizePage(page)
        pageSize = repository.NormalizePageSize(pageSize)
        offset := (page - 1) * pageSize

        query := r.db.WithContext(ctx).Model(&amp;model.User{})

        var total int64
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">var users []model.User
        if err := query.Order("created_at DESC").Offset(offset).Limit(pageSize).Find(&amp;users).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov8" title="1">return users, total, nil</span>
}

// ListWithFilters returns a page of users with filters and the total count.
func (r *gormUserRepository) ListWithFilters(ctx context.Context, opts repository.UserListOptions) ([]model.User, int64, error) <span class="cov8" title="1">{
        page := repository.NormalizePage(opts.Page)
        pageSize := repository.NormalizePageSize(opts.PageSize)
        offset := (page - 1) * pageSize

        q := r.db.WithContext(ctx).Model(&amp;model.User{})
        if len(opts.Roles) &gt; 0 </span><span class="cov8" title="1">{
                q = q.Where("role IN ?", opts.Roles)
        }</span>
        <span class="cov8" title="1">if len(opts.Statuses) &gt; 0 </span><span class="cov8" title="1">{
                q = q.Where("status IN ?", opts.Statuses)
        }</span>
        <span class="cov8" title="1">if opts.DateFrom != nil </span><span class="cov8" title="1">{
                q = q.Where("created_at &gt;= ?", *opts.DateFrom)
        }</span>
        <span class="cov8" title="1">if opts.DateTo != nil </span><span class="cov8" title="1">{
                q = q.Where("created_at &lt;= ?", *opts.DateTo)
        }</span>
        <span class="cov8" title="1">if kw := strings.TrimSpace(opts.Keyword); kw != "" </span><span class="cov8" title="1">{
                like := "%" + kw + "%"
                q = q.Where("name LIKE ? OR email LIKE ? OR phone LIKE ?", like, like, like)
        }</span>

        <span class="cov8" title="1">var total int64
        if err := q.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov8" title="1">var users []model.User
        if err := q.Order("created_at DESC").Offset(offset).Limit(pageSize).Find(&amp;users).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov8" title="1">return users, total, nil</span>
}

// Get returns a user by id.
func (r *gormUserRepository) Get(ctx context.Context, id uint64) (*model.User, error) <span class="cov8" title="1">{
        var user model.User
        if err := r.db.WithContext(ctx).First(&amp;user, id).Error; err != nil </span><span class="cov8" title="1">{
                if err == gorm.ErrRecordNotFound </span><span class="cov8" title="1">{
                        return nil, repository.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;user, nil</span>
}

// FindByEmail returns a user by unique email.
func (r *gormUserRepository) FindByEmail(ctx context.Context, email string) (*model.User, error) <span class="cov8" title="1">{
        var user model.User
        if err := r.db.WithContext(ctx).Where("email = ?", email).First(&amp;user).Error; err != nil </span><span class="cov8" title="1">{
                if err == gorm.ErrRecordNotFound </span><span class="cov8" title="1">{
                        return nil, repository.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;user, nil</span>
}

// GetByPhone returns a user by unique phone.
func (r *gormUserRepository) GetByPhone(ctx context.Context, phone string) (*model.User, error) <span class="cov8" title="1">{
        var user model.User
        if err := r.db.WithContext(ctx).Where("phone = ?", phone).First(&amp;user).Error; err != nil </span><span class="cov8" title="1">{
                if err == gorm.ErrRecordNotFound </span><span class="cov8" title="1">{
                        return nil, repository.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;user, nil</span>
}

// FindByPhone returns a user by unique phone.
func (r *gormUserRepository) FindByPhone(ctx context.Context, phone string) (*model.User, error) <span class="cov8" title="1">{
        return r.GetByPhone(ctx, phone)
}</span>

// Create inserts a new user.
func (r *gormUserRepository) Create(ctx context.Context, user *model.User) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Create(user).Error
}</span>

// Update updates editable fields of a user.
func (r *gormUserRepository) Update(ctx context.Context, user *model.User) error <span class="cov8" title="1">{
        tx := r.db.WithContext(ctx).Model(user).Updates(map[string]any{
                "phone":         user.Phone,
                "email":         user.Email,
                "name":          user.Name,
                "avatar_url":    user.AvatarURL,
                "role":          user.Role,
                "status":        user.Status,
                "password_hash": user.PasswordHash,
                "last_login_at": user.LastLoginAt,
        })
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>
        <span class="cov8" title="1">if tx.RowsAffected == 0 </span><span class="cov8" title="1">{
                return repository.ErrNotFound
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Delete soft-deletes a user by id.
func (r *gormUserRepository) Delete(ctx context.Context, id uint64) error <span class="cov8" title="1">{
        tx := r.db.WithContext(ctx).Delete(&amp;model.User{}, id)
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>
        <span class="cov8" title="1">if tx.RowsAffected == 0 </span><span class="cov8" title="1">{
                return repository.ErrNotFound
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package withdraw

import (
        "context"
        "time"

        "gamelink/internal/model"
        "gamelink/internal/repository"

        "gorm.io/gorm"
)

// WithdrawRepository 提现记录仓储接口
type WithdrawRepository interface {
        // Create 创建提现记录
        Create(ctx context.Context, withdraw *model.Withdraw) error
        // Get 获取提现记录
        Get(ctx context.Context, id uint64) (*model.Withdraw, error)
        // Update 更新提现记录
        Update(ctx context.Context, withdraw *model.Withdraw) error
        // List 查询提现记录列表
        List(ctx context.Context, opts WithdrawListOptions) ([]model.Withdraw, int64, error)
        // GetPlayerBalance 获取陪玩师余额信�?
        GetPlayerBalance(ctx context.Context, playerID uint64) (*PlayerBalance, error)
}

// WithdrawListOptions 提现记录查询选项
type WithdrawListOptions struct {
        PlayerID *uint64
        UserID   *uint64
        Status   *model.WithdrawStatus
        DateFrom *time.Time
        DateTo   *time.Time
        Page     int
        PageSize int
}

// PlayerBalance 陪玩师余额信�?
type PlayerBalance struct {
        TotalEarnings    int64 // 累计收益
        WithdrawTotal    int64 // 累计提现
        PendingWithdraw  int64 // 待处理提�?
        AvailableBalance int64 // 可提现余�?
        PendingBalance   int64 // 待结算余�?
}

type withdrawRepository struct {
        db *gorm.DB
}

// NewWithdrawRepository 创建提现记录仓储
func NewWithdrawRepository(db *gorm.DB) WithdrawRepository <span class="cov8" title="1">{
        return &amp;withdrawRepository{db: db}
}</span>

// Create 创建提现记录
func (r *withdrawRepository) Create(ctx context.Context, withdraw *model.Withdraw) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Create(withdraw).Error
}</span>

// Get 获取提现记录
func (r *withdrawRepository) Get(ctx context.Context, id uint64) (*model.Withdraw, error) <span class="cov8" title="1">{
        var withdraw model.Withdraw
        err := r.db.WithContext(ctx).First(&amp;withdraw, id).Error
        if err != nil </span><span class="cov8" title="1">{
                if err == gorm.ErrRecordNotFound </span><span class="cov8" title="1">{
                        return nil, repository.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;withdraw, nil</span>
}

// Update 更新提现记录
func (r *withdrawRepository) Update(ctx context.Context, withdraw *model.Withdraw) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Save(withdraw).Error
}</span>

// List 查询提现记录列表
func (r *withdrawRepository) List(ctx context.Context, opts WithdrawListOptions) ([]model.Withdraw, int64, error) <span class="cov8" title="1">{
        query := r.db.WithContext(ctx).Model(&amp;model.Withdraw{})

        // 过滤条件
        if opts.PlayerID != nil </span><span class="cov8" title="1">{
                query = query.Where("player_id = ?", *opts.PlayerID)
        }</span>
        <span class="cov8" title="1">if opts.UserID != nil </span><span class="cov0" title="0">{
                query = query.Where("user_id = ?", *opts.UserID)
        }</span>
        <span class="cov8" title="1">if opts.Status != nil </span><span class="cov8" title="1">{
                query = query.Where("status = ?", *opts.Status)
        }</span>
        <span class="cov8" title="1">if opts.DateFrom != nil </span><span class="cov0" title="0">{
                query = query.Where("created_at &gt;= ?", *opts.DateFrom)
        }</span>
        <span class="cov8" title="1">if opts.DateTo != nil </span><span class="cov0" title="0">{
                query = query.Where("created_at &lt; ?", *opts.DateTo)
        }</span>

        // 统计总数
        <span class="cov8" title="1">var total int64
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 分页
        <span class="cov8" title="1">if opts.Page &lt; 1 </span><span class="cov0" title="0">{
                opts.Page = 1
        }</span>
        <span class="cov8" title="1">if opts.PageSize &lt; 1 </span><span class="cov0" title="0">{
                opts.PageSize = 20
        }</span>
        <span class="cov8" title="1">offset := (opts.Page - 1) * opts.PageSize

        // 查询数据
        var withdraws []model.Withdraw
        err := query.Order("created_at DESC").Offset(offset).Limit(opts.PageSize).Find(&amp;withdraws).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">return withdraws, total, nil</span>
}

// GetPlayerBalance 获取陪玩师余额信�?
func (r *withdrawRepository) GetPlayerBalance(ctx context.Context, playerID uint64) (*PlayerBalance, error) <span class="cov8" title="1">{
        balance := &amp;PlayerBalance{}

        // 计算累计收益（从已完成订单）
        var totalEarnings int64
        err := r.db.WithContext(ctx).
                Model(&amp;model.Order{}).
                Where("player_id = ? AND status = ?", playerID, model.OrderStatusCompleted).
                Select("COALESCE(SUM(total_price_cents), 0)").
                Scan(&amp;totalEarnings).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">balance.TotalEarnings = totalEarnings

        // 计算累计提现（已完成的提现）
        var withdrawTotal int64
        err = r.db.WithContext(ctx).
                Model(&amp;model.Withdraw{}).
                Where("player_id = ? AND status = ?", playerID, model.WithdrawStatusCompleted).
                Select("COALESCE(SUM(amount_cents), 0)").
                Scan(&amp;withdrawTotal).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">balance.WithdrawTotal = withdrawTotal

        // 计算待处理提现（pending �?approved 状态）
        var pendingWithdraw int64
        err = r.db.WithContext(ctx).
                Model(&amp;model.Withdraw{}).
                Where("player_id = ? AND status IN ?", playerID, []model.WithdrawStatus{
                        model.WithdrawStatusPending,
                        model.WithdrawStatusApproved,
                }).
                Select("COALESCE(SUM(amount_cents), 0)").
                Scan(&amp;pendingWithdraw).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">balance.PendingWithdraw = pendingWithdraw

        // 计算待结算余额（进行中的订单�?
        var pendingBalance int64
        err = r.db.WithContext(ctx).
                Model(&amp;model.Order{}).
                Where("player_id = ? AND status = ?", playerID, model.OrderStatusInProgress).
                Select("COALESCE(SUM(total_price_cents), 0)").
                Scan(&amp;pendingBalance).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">balance.PendingBalance = pendingBalance

        // 计算可提现余�?= 累计收益 - 累计提现 - 待处理提�?- 待结算余�?
        balance.AvailableBalance = totalEarnings - withdrawTotal - pendingWithdraw - pendingBalance
        if balance.AvailableBalance &lt; 0 </span><span class="cov0" title="0">{
                balance.AvailableBalance = 0
        }</span>

        <span class="cov8" title="1">return balance, nil</span>
}

</pre>
		
		<pre class="file" id="file98" style="display: none">package scheduler

import (
        "context"
        "log"
        "time"

        "gamelink/internal/service/commission"

        "github.com/robfig/cron/v3"
)

// SettlementScheduler 结算调度器
type SettlementScheduler struct {
        commissionSvc *commission.CommissionService
        cron          *cron.Cron
}

// NewSettlementScheduler 创建结算调度器
func NewSettlementScheduler(commissionSvc *commission.CommissionService) *SettlementScheduler <span class="cov0" title="0">{
        return &amp;SettlementScheduler{
                commissionSvc: commissionSvc,
                cron:          cron.New(),
        }
}</span>

// Start 启动调度器
func (s *SettlementScheduler) Start() <span class="cov0" title="0">{
        // 每月1号凌晨2点执行月度结算
        _, err := s.cron.AddFunc("0 2 1 * *", s.monthlySettlement)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to add monthly settlement job: %v", err)
                return
        }</span>

        <span class="cov0" title="0">s.cron.Start()
        log.Println("Settlement scheduler started - will run on 1st of each month at 02:00")</span>
}

// Stop 停止调度器
func (s *SettlementScheduler) Stop() <span class="cov0" title="0">{
        s.cron.Stop()
        log.Println("Settlement scheduler stopped")
}</span>

// monthlySettlement 月度结算任务
func (s *SettlementScheduler) monthlySettlement() <span class="cov0" title="0">{
        ctx := context.Background()

        // 结算上个月
        now := time.Now()
        lastMonth := now.AddDate(0, -1, 0)
        month := lastMonth.Format("2006-01")

        log.Printf("[Settlement] Starting monthly settlement for %s", month)

        err := s.commissionSvc.SettleMonth(ctx, month)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[Settlement] ERROR: Monthly settlement failed for %s: %v", month, err)
                // TODO: 发送告警通知
                return
        }</span>

        <span class="cov0" title="0">log.Printf("[Settlement] SUCCESS: Monthly settlement completed for %s", month)</span>
        // TODO: 发送成功通知
}

// TriggerSettlement 手动触发结算（用于测试和补偿）
func (s *SettlementScheduler) TriggerSettlement(month string) error <span class="cov0" title="0">{
        ctx := context.Background()
        log.Printf("[Settlement] Manual trigger for month: %s", month)

        err := s.commissionSvc.SettleMonth(ctx, month)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[Settlement] Manual settlement failed: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("[Settlement] Manual settlement completed successfully")
        return nil</span>
}

// GetNextRunTime 获取下次运行时间
func (s *SettlementScheduler) GetNextRunTime() time.Time <span class="cov0" title="0">{
        entries := s.cron.Entries()
        if len(entries) &gt; 0 </span><span class="cov0" title="0">{
                return entries[0].Next
        }</span>
        <span class="cov0" title="0">return time.Time{}</span>
}

</pre>
		
		<pre class="file" id="file99" style="display: none">package admin

import (
        "context"
        "encoding/json"
        "errors"
        "os"
        "sort"
        "strings"
        "time"

        "log/slog"

        "golang.org/x/crypto/bcrypt"

        "gamelink/internal/cache"
        "gamelink/internal/logging"
        "gamelink/internal/model"
        "gamelink/internal/repository"
        "gamelink/internal/repository/common"
)

var (
        // ErrValidation 表示输入校验失败。
        ErrValidation = errors.New("validation failed")
        // ErrUserNotFound 用于统一标识用户不存在的场景。
        ErrUserNotFound = errors.New("user not found")
        // ErrOrderInvalidTransition 代表订单状态流转不合法。
        ErrOrderInvalidTransition = errors.New("invalid order status transition")

        // ErrNotFound 暴露仓储的未找到错误，便于 handler 判定。
        ErrNotFound = repository.ErrNotFound
)

// AdminService 聚合后台管理所需的业务逻辑。
type AdminService struct {
        games    repository.GameRepository
        users    repository.UserRepository
        players  repository.PlayerRepository
        orders   repository.OrderRepository
        payments repository.PaymentRepository
        roles    repository.RoleRepository
        cache    cache.Cache
        tx       TxManager
}

const (
        cacheKeyGames    = "admin:games"
        cacheKeyUsers    = "admin:users"
        cacheKeyPlayers  = "admin:players"
        cacheKeyOrders   = "admin:orders"
        cacheKeyPayments = "admin:payments"
)

var listCacheTTL = readListCacheTTL()

func readListCacheTTL() time.Duration <span class="cov8" title="1">{
        if v := strings.TrimSpace(os.Getenv("ADMIN_LIST_TTL")); v != "" </span><span class="cov0" title="0">{
                if d, err := time.ParseDuration(v); err == nil </span><span class="cov0" title="0">{
                        return d
                }</span>
        }
        <span class="cov8" title="1">return 30 * time.Second</span>
}

// NewAdminService 创建服务实例。
func NewAdminService(
        games repository.GameRepository,
        users repository.UserRepository,
        players repository.PlayerRepository,
        orders repository.OrderRepository,
        payments repository.PaymentRepository,
        roles repository.RoleRepository,
        cache cache.Cache,
) *AdminService <span class="cov8" title="1">{
        return &amp;AdminService{
                games:    games,
                users:    users,
                players:  players,
                orders:   orders,
                payments: payments,
                roles:    roles,
                cache:    cache,
        }
}</span>

// TxManager abstracts UnitOfWork for transactional operations.
type TxManager interface {
        WithTx(ctx context.Context, fn func(r *common.Repos) error) error
}

// SetTxManager injects a transaction manager.
func (s *AdminService) SetTxManager(tx TxManager) <span class="cov8" title="1">{ s.tx = tx }</span>

// UpdatePlayerSkillTags 替换玩家技能标签集合（需要 TxManager）。
func (s *AdminService) UpdatePlayerSkillTags(ctx context.Context, playerID uint64, tags []string) error <span class="cov0" title="0">{
        if s.tx == nil </span><span class="cov0" title="0">{
                return errors.New("transaction manager not configured")
        }</span>
        <span class="cov0" title="0">err := s.tx.WithTx(ctx, func(r *common.Repos) error </span><span class="cov0" title="0">{
                // ensure player exists
                if _, err := r.Players.Get(ctx, playerID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return r.Tags.ReplaceTags(ctx, playerID, tags)</span>
        })
        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                s.appendLogAsync(ctx, string(model.OpEntityPlayer), playerID, string(model.OpActionUpdate), map[string]any{"tags_count": len(tags)})
        }</span>
        <span class="cov0" title="0">return err</span>
}

// RegisterUserAndPlayer creates a user and a player profile in a single transaction.
func (s *AdminService) RegisterUserAndPlayer(ctx context.Context, u CreateUserInput, p CreatePlayerInput) (*model.User, *model.Player, error) <span class="cov0" title="0">{
        if s.tx == nil </span><span class="cov0" title="0">{
                return nil, nil, errors.New("transaction manager not configured")
        }</span>
        // basic validations reuse existing ones
        <span class="cov0" title="0">if err := validateUserInput(u.Name, u.Role, u.Status, u.Password); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        // For registration flow, user will be created first; only verify player fields except UserID.
        <span class="cov0" title="0">if p.VerificationStatus == "" </span><span class="cov0" title="0">{
                return nil, nil, ErrValidation
        }</span>

        <span class="cov0" title="0">var createdUser *model.User
        var createdPlayer *model.Player

        err := s.tx.WithTx(ctx, func(r *common.Repos) error </span><span class="cov0" title="0">{
                // hash password
                hashed, err := hashPassword(u.Password)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">user := &amp;model.User{
                        Phone:        strings.TrimSpace(u.Phone),
                        Email:        strings.TrimSpace(u.Email),
                        PasswordHash: hashed,
                        Name:         strings.TrimSpace(u.Name),
                        AvatarURL:    strings.TrimSpace(u.AvatarURL),
                        Role:         u.Role,
                        Status:       u.Status,
                }
                if err := r.Users.Create(ctx, user); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">createdUser = user

                player := &amp;model.Player{
                        UserID:             user.ID,
                        Nickname:           strings.TrimSpace(p.Nickname),
                        Bio:                strings.TrimSpace(p.Bio),
                        HourlyRateCents:    p.HourlyRateCents,
                        MainGameID:         p.MainGameID,
                        VerificationStatus: p.VerificationStatus,
                }
                if err := r.Players.Create(ctx, player); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">createdPlayer = player
                return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        // invalidate relevant caches
        <span class="cov0" title="0">s.invalidateCache(ctx, cacheKeyUsers, cacheKeyPlayers)
        return createdUser, createdPlayer, nil</span>
}

// --- Game management ---

// CreateGameInput 创建游戏时使用的参数。
type CreateGameInput struct {
        Key         string
        Name        string
        Category    string
        IconURL     string
        Description string
}

// UpdateGameInput 修改游戏资料。
type UpdateGameInput struct {
        Key         string
        Name        string
        Category    string
        IconURL     string
        Description string
}

// ListGames 返回全部游戏。
func (s *AdminService) ListGames(ctx context.Context) ([]model.Game, error) <span class="cov8" title="1">{
        return getCachedList(ctx, s.cache, cacheKeyGames, listCacheTTL, func() ([]model.Game, error) </span><span class="cov8" title="1">{
                return s.games.List(ctx)
        }</span>)
}

// ListGamesPaged 返回分页游戏列表。
func (s *AdminService) ListGamesPaged(ctx context.Context, page, pageSize int) ([]model.Game, *model.Pagination, error) <span class="cov8" title="1">{
        page = repository.NormalizePage(page)
        pageSize = repository.NormalizePageSize(pageSize)
        items, total, err := s.games.ListPaged(ctx, page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">p := buildPagination(page, pageSize, total)
        return items, &amp;p, nil</span>
}

// GetGame 获取单个游戏详情。
func (s *AdminService) GetGame(ctx context.Context, id uint64) (*model.Game, error) <span class="cov8" title="1">{
        return s.games.Get(ctx, id)
}</span>

// CreateGame 创建游戏。
func (s *AdminService) CreateGame(ctx context.Context, input CreateGameInput) (*model.Game, error) <span class="cov8" title="1">{
        if err := validateGameInput(input.Key, input.Name); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">game := &amp;model.Game{
                Key:         strings.TrimSpace(input.Key),
                Name:        strings.TrimSpace(input.Name),
                Category:    strings.TrimSpace(input.Category),
                IconURL:     strings.TrimSpace(input.IconURL),
                Description: strings.TrimSpace(input.Description),
        }

        if err := s.games.Create(ctx, game); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">s.invalidateCache(ctx, cacheKeyGames)
        // audit
        s.appendLogAsync(ctx, string(model.OpEntityGame), game.ID, string(model.OpActionCreate), map[string]any{"key": game.Key})

        return game, nil</span>
}

// UpdateGame 更新游戏。
func (s *AdminService) UpdateGame(ctx context.Context, id uint64, input UpdateGameInput) (*model.Game, error) <span class="cov8" title="1">{
        if err := validateGameInput(input.Key, input.Name); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">game, err := s.games.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">game.Key = strings.TrimSpace(input.Key)
        game.Name = strings.TrimSpace(input.Name)
        game.Category = strings.TrimSpace(input.Category)
        game.IconURL = strings.TrimSpace(input.IconURL)
        game.Description = strings.TrimSpace(input.Description)

        if err := s.games.Update(ctx, game); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">s.invalidateCache(ctx, cacheKeyGames)
        // audit
        s.appendLogAsync(ctx, string(model.OpEntityGame), game.ID, string(model.OpActionUpdate), map[string]any{"key": game.Key})

        return game, nil</span>
}

// DeleteGame 删除游戏。
func (s *AdminService) DeleteGame(ctx context.Context, id uint64) error <span class="cov8" title="1">{
        if err := s.games.Delete(ctx, id); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">s.invalidateCache(ctx, cacheKeyGames)
        // audit
        s.appendLogAsync(ctx, string(model.OpEntityGame), id, string(model.OpActionDelete), nil)
        return nil</span>
}

func validateGameInput(key, name string) error <span class="cov8" title="1">{
        if strings.TrimSpace(key) == "" || strings.TrimSpace(name) == "" </span><span class="cov8" title="1">{
                return ErrValidation
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// --- User management ---

// CreateUserInput 定义创建用户的请求。
type CreateUserInput struct {
        Phone     string
        Email     string
        Password  string
        Name      string
        AvatarURL string
        Role      model.Role
        Status    model.UserStatus
}

// UpdateUserInput 定义更新用户资料的请求。
type UpdateUserInput struct {
        Phone     string
        Email     string
        Name      string
        AvatarURL string
        Role      model.Role
        Status    model.UserStatus
        Password  *string
}

// ListUsers 返回全部用户。
func (s *AdminService) ListUsers(ctx context.Context) ([]model.User, error) <span class="cov8" title="1">{
        return getCachedList(ctx, s.cache, cacheKeyUsers, listCacheTTL, func() ([]model.User, error) </span><span class="cov8" title="1">{
                return s.users.List(ctx)
        }</span>)
}

// ListUsersPaged 返回分页用户列表。
func (s *AdminService) ListUsersPaged(ctx context.Context, page, pageSize int) ([]model.User, *model.Pagination, error) <span class="cov8" title="1">{
        page = repository.NormalizePage(page)
        pageSize = repository.NormalizePageSize(pageSize)
        items, total, err := s.users.ListPaged(ctx, page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">p := buildPagination(page, pageSize, total)
        return items, &amp;p, nil</span>
}

// ListUsersWithOptions 返回带筛选的分页用户列表。
func (s *AdminService) ListUsersWithOptions(ctx context.Context, opts repository.UserListOptions) ([]model.User, *model.Pagination, error) <span class="cov8" title="1">{
        normalized := opts
        normalized.Page = repository.NormalizePage(opts.Page)
        normalized.PageSize = repository.NormalizePageSize(opts.PageSize)
        items, total, err := s.users.ListWithFilters(ctx, normalized)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">p := buildPagination(normalized.Page, normalized.PageSize, total)
        return items, &amp;p, nil</span>
}

// GetUser 返回指定用户。
func (s *AdminService) GetUser(ctx context.Context, id uint64) (*model.User, error) <span class="cov8" title="1">{
        user, err := s.users.Get(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, mapUserError(err)
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}

// CreateUser 新建用户并对密码加密。
func (s *AdminService) CreateUser(ctx context.Context, input CreateUserInput) (*model.User, error) <span class="cov8" title="1">{
        if err := validateUserInput(input.Name, input.Role, input.Status, input.Password); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">hashed, err := hashPassword(input.Password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">user := &amp;model.User{
                Phone:        strings.TrimSpace(input.Phone),
                Email:        strings.TrimSpace(input.Email),
                PasswordHash: hashed,
                Name:         strings.TrimSpace(input.Name),
                AvatarURL:    strings.TrimSpace(input.AvatarURL),
                Role:         input.Role,
                Status:       input.Status,
        }

        if err := s.users.Create(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 同步 user.Role 到 user_roles 表
        <span class="cov8" title="1">if err := s.syncUserRoleToTable(ctx, user.ID, user.Role); err != nil </span><span class="cov0" title="0">{
                slog.Warn("failed to sync user_role to table", slog.Uint64("user_id", user.ID), slog.String("error", err.Error()))
                // 不中断流程，继续执行
        }</span>

        <span class="cov8" title="1">s.invalidateCache(ctx, cacheKeyUsers)
        // audit
        s.appendLogAsync(ctx, string(model.OpEntityUser), user.ID, string(model.OpActionCreate), map[string]any{"role": user.Role, "status": user.Status})
        if rid, ok := logging.RequestIDFromContext(ctx); ok </span><span class="cov0" title="0">{
                slog.Info("user_created", slog.Uint64("user_id", user.ID), slog.String("role", string(user.Role)), slog.String("status", string(user.Status)), slog.String("request_id", rid))
        }</span> else<span class="cov8" title="1"> {
                slog.Info("user_created", slog.Uint64("user_id", user.ID), slog.String("role", string(user.Role)), slog.String("status", string(user.Status)))
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}

// UpdateUser 更新用户基础信息。
func (s *AdminService) UpdateUser(ctx context.Context, id uint64, input UpdateUserInput) (*model.User, error) <span class="cov8" title="1">{
        user, err := s.users.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, mapUserError(err)
        }</span>

        <span class="cov8" title="1">if err := validateUserInput(input.Name, input.Role, input.Status, optionalPassword(input.Password)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 避免将唯一字段更新为空字符串导致唯一索引冲突；空值保持原值
        <span class="cov8" title="1">if v := strings.TrimSpace(input.Phone); v != "" </span><span class="cov0" title="0">{
                user.Phone = v
        }</span>
        <span class="cov8" title="1">if v := strings.TrimSpace(input.Email); v != "" </span><span class="cov0" title="0">{
                user.Email = v
        }</span>
        <span class="cov8" title="1">user.Name = strings.TrimSpace(input.Name)
        user.AvatarURL = strings.TrimSpace(input.AvatarURL)
        user.Role = input.Role
        user.Status = input.Status

        if input.Password != nil &amp;&amp; strings.TrimSpace(*input.Password) != "" </span><span class="cov0" title="0">{
                hash, err := hashPassword(*input.Password)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">user.PasswordHash = hash</span>
        }

        <span class="cov8" title="1">if err := s.users.Update(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 同步 user.Role 到 user_roles 表
        <span class="cov8" title="1">if err := s.syncUserRoleToTable(ctx, user.ID, user.Role); err != nil </span><span class="cov0" title="0">{
                slog.Warn("failed to sync user_role to table", slog.Uint64("user_id", user.ID), slog.String("error", err.Error()))
                // 不中断流程，继续执行
        }</span>

        <span class="cov8" title="1">s.invalidateCache(ctx, cacheKeyUsers)
        // audit
        s.appendLogAsync(ctx, string(model.OpEntityUser), user.ID, string(model.OpActionUpdate), map[string]any{"role": user.Role, "status": user.Status})
        if rid, ok := logging.RequestIDFromContext(ctx); ok </span><span class="cov0" title="0">{
                slog.Info("user_updated", slog.Uint64("user_id", user.ID), slog.String("request_id", rid))
        }</span> else<span class="cov8" title="1"> {
                slog.Info("user_updated", slog.Uint64("user_id", user.ID))
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}

// DeleteUser 删除用户。
func (s *AdminService) DeleteUser(ctx context.Context, id uint64) error <span class="cov8" title="1">{
        if err := s.users.Delete(ctx, id); err != nil </span><span class="cov0" title="0">{
                return mapUserError(err)
        }</span>
        <span class="cov8" title="1">s.invalidateCache(ctx, cacheKeyUsers)
        // audit
        s.appendLogAsync(ctx, string(model.OpEntityUser), id, string(model.OpActionDelete), nil)
        if rid, ok := logging.RequestIDFromContext(ctx); ok </span><span class="cov0" title="0">{
                slog.Info("user_deleted", slog.Uint64("user_id", id), slog.String("request_id", rid))
        }</span> else<span class="cov8" title="1"> {
                slog.Info("user_deleted", slog.Uint64("user_id", id))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// UpdateUserStatus 单独更新用户状态并记录审计。
func (s *AdminService) UpdateUserStatus(ctx context.Context, id uint64, status model.UserStatus) (*model.User, error) <span class="cov8" title="1">{
        user, err := s.users.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, mapUserError(err)
        }</span>
        <span class="cov8" title="1">if err := validateUserInput(user.Name, user.Role, status, ""); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">user.Status = status
        if err := s.users.Update(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">s.invalidateCache(ctx, cacheKeyUsers)
        s.appendLogAsync(ctx, string(model.OpEntityUser), user.ID, string(model.OpActionUpdateStatus), map[string]any{"status": user.Status})
        return user, nil</span>
}

// UpdateUserRole 单独更新用户角色并记录审计。
func (s *AdminService) UpdateUserRole(ctx context.Context, id uint64, role model.Role) (*model.User, error) <span class="cov8" title="1">{
        user, err := s.users.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, mapUserError(err)
        }</span>
        <span class="cov8" title="1">if err := validateUserInput(user.Name, role, user.Status, ""); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">user.Role = role
        if err := s.users.Update(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 同步 user.Role 到 user_roles 表
        <span class="cov8" title="1">if err := s.syncUserRoleToTable(ctx, user.ID, user.Role); err != nil </span><span class="cov0" title="0">{
                slog.Warn("failed to sync user_role to table", slog.Uint64("user_id", user.ID), slog.String("error", err.Error()))
                // 不中断流程，继续执行
        }</span>

        <span class="cov8" title="1">s.invalidateCache(ctx, cacheKeyUsers)
        s.appendLogAsync(ctx, string(model.OpEntityUser), user.ID, string(model.OpActionUpdateRole), map[string]any{"role": user.Role})
        return user, nil</span>
}

func validateUserInput(name string, role model.Role, status model.UserStatus, password string) error <span class="cov8" title="1">{
        if strings.TrimSpace(name) == "" </span><span class="cov0" title="0">{
                return ErrValidation
        }</span>
        <span class="cov8" title="1">if role == "" || status == "" </span><span class="cov0" title="0">{
                return ErrValidation
        }</span>
        <span class="cov8" title="1">if password != "" &amp;&amp; !validPassword(password) </span><span class="cov8" title="1">{
                return ErrValidation
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// syncUserRoleToTable 同步 user.Role 到 user_roles 多对多表。
// 根据 user.Role 字段的值，在 user_roles 表中创建对应的关联记录。
func (s *AdminService) syncUserRoleToTable(ctx context.Context, userID uint64, role model.Role) error <span class="cov8" title="1">{
        // 根据 role 字段查找对应的 RoleModel
        var roleSlug string
        switch role </span>{
        case model.RoleAdmin:<span class="cov0" title="0">
                roleSlug = string(model.RoleSlugAdmin)</span>
        case model.RolePlayer:<span class="cov8" title="1">
                roleSlug = string(model.RoleSlugPlayer)</span>
        case model.RoleUser:<span class="cov8" title="1">
                roleSlug = string(model.RoleSlugUser)</span>
        default:<span class="cov0" title="0">
                // 未知角色，记录日志但不报错
                slog.Warn("unknown user role, skipping user_roles sync", slog.String("role", string(role)), slog.Uint64("user_id", userID))
                return nil</span>
        }

        <span class="cov8" title="1">roleModel, err := s.roles.GetBySlug(ctx, roleSlug)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, repository.ErrNotFound) </span><span class="cov8" title="1">{
                        slog.Warn("role not found in database, skipping user_roles sync", slog.String("slug", roleSlug), slog.Uint64("user_id", userID))
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // 为用户分配该角色（替换现有所有角色，保持与 user.Role 字段一致）
        <span class="cov0" title="0">if err := s.roles.AssignToUser(ctx, userID, []uint64{roleModel.ID}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">slog.Info("user_role_synced_to_table", slog.Uint64("user_id", userID), slog.String("role", string(role)), slog.Uint64("role_id", roleModel.ID))
        return nil</span>
}

func validPassword(pw string) bool <span class="cov8" title="1">{
        if len(pw) &lt; 6 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">hasLetter := false
        hasDigit := false
        for _, r := range pw </span><span class="cov8" title="1">{
                if (r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= 'A' &amp;&amp; r &lt;= 'Z') </span><span class="cov8" title="1">{
                        hasLetter = true
                }</span>
                <span class="cov8" title="1">if r &gt;= '0' &amp;&amp; r &lt;= '9' </span><span class="cov8" title="1">{
                        hasDigit = true
                }</span>
                <span class="cov8" title="1">if hasLetter &amp;&amp; hasDigit </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func optionalPassword(ptr *string) string <span class="cov8" title="1">{
        if ptr == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return *ptr</span>
}

func hashPassword(raw string) (string, error) <span class="cov8" title="1">{
        if strings.TrimSpace(raw) == "" </span><span class="cov0" title="0">{
                return "", ErrValidation
        }</span>
        <span class="cov8" title="1">bytes, err := bcrypt.GenerateFromPassword([]byte(raw), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(bytes), nil</span>
}

// --- Player management ---

// CreatePlayerInput 创建陪玩资料。
type CreatePlayerInput struct {
        UserID             uint64
        Nickname           string
        Bio                string
        Rank               string
        HourlyRateCents    int64
        MainGameID         uint64
        VerificationStatus model.VerificationStatus
}

// UpdatePlayerInput 更新陪玩资料。
type UpdatePlayerInput struct {
        Nickname           string
        Bio                string
        Rank               string
        HourlyRateCents    int64
        MainGameID         uint64
        VerificationStatus model.VerificationStatus
}

// ListPlayers 返回陪玩列表。
func (s *AdminService) ListPlayers(ctx context.Context) ([]model.Player, error) <span class="cov8" title="1">{
        return getCachedList(ctx, s.cache, cacheKeyPlayers, listCacheTTL, func() ([]model.Player, error) </span><span class="cov8" title="1">{
                return s.players.List(ctx)
        }</span>)
}

// ListPlayersPaged 返回分页陪玩列表。
func (s *AdminService) ListPlayersPaged(ctx context.Context, page, pageSize int) ([]model.Player, *model.Pagination, error) <span class="cov8" title="1">{
        page = repository.NormalizePage(page)
        pageSize = repository.NormalizePageSize(pageSize)
        items, total, err := s.players.ListPaged(ctx, page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">p := buildPagination(page, pageSize, total)
        return items, &amp;p, nil</span>
}

// GetPlayer 返回陪玩详情。
func (s *AdminService) GetPlayer(ctx context.Context, id uint64) (*model.Player, error) <span class="cov8" title="1">{
        return s.players.Get(ctx, id)
}</span>

// CreatePlayer 新建陪玩档案。
func (s *AdminService) CreatePlayer(ctx context.Context, input CreatePlayerInput) (*model.Player, error) <span class="cov8" title="1">{
        if err := validatePlayerInput(input.UserID, input.VerificationStatus); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">player := &amp;model.Player{
                UserID:             input.UserID,
                Nickname:           strings.TrimSpace(input.Nickname),
                Bio:                strings.TrimSpace(input.Bio),
                HourlyRateCents:    input.HourlyRateCents,
                MainGameID:         input.MainGameID,
                VerificationStatus: input.VerificationStatus,
        }

        if err := s.players.Create(ctx, player); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">s.invalidateCache(ctx, cacheKeyPlayers)
        // audit
        s.appendLogAsync(ctx, string(model.OpEntityPlayer), player.ID, string(model.OpActionCreate), map[string]any{"user_id": player.UserID})
        return player, nil</span>
}

// UpdatePlayer 调整陪玩信息。
func (s *AdminService) UpdatePlayer(ctx context.Context, id uint64, input UpdatePlayerInput) (*model.Player, error) <span class="cov0" title="0">{
        player, err := s.players.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := validatePlayerInput(player.UserID, input.VerificationStatus); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">player.Nickname = strings.TrimSpace(input.Nickname)
        player.Bio = strings.TrimSpace(input.Bio)
        player.HourlyRateCents = input.HourlyRateCents
        player.MainGameID = input.MainGameID
        player.VerificationStatus = input.VerificationStatus

        if err := s.players.Update(ctx, player); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">s.invalidateCache(ctx, cacheKeyPlayers)
        // audit
        s.appendLogAsync(ctx, string(model.OpEntityPlayer), player.ID, string(model.OpActionUpdate), map[string]any{"main_game_id": player.MainGameID})
        return player, nil</span>
}

// DeletePlayer 删除陪玩档案。
func (s *AdminService) DeletePlayer(ctx context.Context, id uint64) error <span class="cov8" title="1">{
        if err := s.players.Delete(ctx, id); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">s.invalidateCache(ctx, cacheKeyPlayers)
        // audit
        s.appendLogAsync(ctx, string(model.OpEntityPlayer), id, string(model.OpActionDelete), nil)
        return nil</span>
}

func validatePlayerInput(userID uint64, verification model.VerificationStatus) error <span class="cov8" title="1">{
        if userID == 0 </span><span class="cov0" title="0">{
                return ErrValidation
        }</span>
        <span class="cov8" title="1">if verification == "" </span><span class="cov0" title="0">{
                return ErrValidation
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// --- Order management ---

// CreateOrderInput 创建订单请求。
type CreateOrderInput struct {
        UserID          uint64
        PlayerID        *uint64
        GameID          uint64
        Title           string
        Description     string
        TotalPriceCents int64
        Currency        model.Currency
        ScheduledStart  *time.Time
        ScheduledEnd    *time.Time
}

// CreateOrder 新建订单，默认状态为 pending。
func (s *AdminService) CreateOrder(ctx context.Context, in CreateOrderInput) (*model.Order, error) <span class="cov8" title="1">{
        if in.UserID == 0 || in.GameID == 0 || in.TotalPriceCents &lt; 0 || !model.IsValidCurrency(in.Currency) </span><span class="cov0" title="0">{
                return nil, ErrValidation
        }</span>
        <span class="cov8" title="1">if in.ScheduledStart != nil &amp;&amp; in.ScheduledEnd != nil &amp;&amp; in.ScheduledEnd.Before(*in.ScheduledStart) </span><span class="cov0" title="0">{
                return nil, ErrValidation
        }</span>
        <span class="cov8" title="1">if in.PlayerID != nil &amp;&amp; *in.PlayerID != 0 </span><span class="cov0" title="0">{
                if _, err := s.players.Get(ctx, *in.PlayerID); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">gameID := in.GameID
        order := &amp;model.Order{
                OrderNo:         model.GenerateEscortOrderNo(),
                UserID:          in.UserID,
                ItemID:          1, // TODO: 需要从service_items选择
                GameID:          &amp;gameID,
                Quantity:        1,
                UnitPriceCents:  in.TotalPriceCents,
                TotalPriceCents: in.TotalPriceCents,
                Currency:        in.Currency,
                Status:          model.OrderStatusPending,
                Title:           strings.TrimSpace(in.Title),
                Description:     strings.TrimSpace(in.Description),
                ScheduledStart:  in.ScheduledStart,
                ScheduledEnd:    in.ScheduledEnd,
        }
        if in.PlayerID != nil </span><span class="cov0" title="0">{
                order.PlayerID = in.PlayerID
        }</span>
        <span class="cov8" title="1">if err := s.orders.Create(ctx, order); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">s.invalidateCache(ctx, cacheKeyOrders)
        s.appendLogAsync(ctx, string(model.OpEntityOrder), order.ID, string(model.OpActionCreate), map[string]any{"status": order.Status})
        return order, nil</span>
}

// AssignOrder 指派陪玩师。
func (s *AdminService) AssignOrder(ctx context.Context, id uint64, playerID uint64) (*model.Order, error) <span class="cov0" title="0">{
        if playerID == 0 </span><span class="cov0" title="0">{
                return nil, ErrValidation
        }</span>
        <span class="cov0" title="0">if _, err := s.players.Get(ctx, playerID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">order, err := s.orders.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // 不允许在完成/取消/退款后指派
        <span class="cov0" title="0">switch order.Status </span>{
        case model.OrderStatusCompleted, model.OrderStatusCanceled, model.OrderStatusRefunded:<span class="cov0" title="0">
                return nil, ErrValidation</span>
        }
        <span class="cov0" title="0">order.SetPlayerID(playerID)
        if err := s.orders.Update(ctx, order); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">s.invalidateCache(ctx, cacheKeyOrders)
        s.appendLogAsync(ctx, string(model.OpEntityOrder), order.ID, string(model.OpActionAssignPlayer), map[string]any{"player_id": playerID})
        return order, nil</span>
}

// UpdateOrderInput 用于更新订单状态。
type UpdateOrderInput struct {
        Status            model.OrderStatus
        TotalPriceCents   int64
        Currency          model.Currency
        ScheduledStart    *time.Time
        ScheduledEnd      *time.Time
        CancelReason      string
        StartedAt         *time.Time
        CompletedAt       *time.Time
        RefundAmountCents *int64
        RefundReason      string
        RefundedAt        *time.Time
        Note              string
}

// RefundOrderInput 描述退款请求。
type RefundOrderInput struct {
        Reason      string
        AmountCents *int64
        Note        string
}

// OrderTimelineItem 组合订单历史时间线。
type OrderTimelineItem struct {
        ID           uint64         `json:"id"`
        OrderID      uint64         `json:"order_id"`
        PaymentID    *uint64        `json:"payment_id,omitempty"`
        EventType    string         `json:"event_type"`
        Title        string         `json:"title"`
        Description  string         `json:"description,omitempty"`
        Operator     string         `json:"operator,omitempty"`
        OperatorRole string         `json:"operator_role,omitempty"`
        OperatorID   *uint64        `json:"operator_id,omitempty"`
        StatusBefore string         `json:"status_before,omitempty"`
        StatusAfter  string         `json:"status_after,omitempty"`
        Metadata     map[string]any `json:"metadata,omitempty"`
        CreatedAt    time.Time      `json:"created_at"`
}

// OrderRefundItem 描述订单退款记录。
type OrderRefundItem struct {
        ID          uint64     `json:"id"`
        OrderID     uint64     `json:"order_id"`
        PaymentID   uint64     `json:"payment_id"`
        AmountCents int64      `json:"amount_cents"`
        Reason      string     `json:"reason,omitempty"`
        Status      string     `json:"status"`
        Method      string     `json:"refund_method"`
        Note        string     `json:"note,omitempty"`
        RefundedAt  *time.Time `json:"refunded_at,omitempty"`
        CreatedAt   time.Time  `json:"created_at"`
}

// ListOrders 列出订单。
func (s *AdminService) ListOrders(ctx context.Context, opts repository.OrderListOptions) ([]model.Order, *model.Pagination, error) <span class="cov8" title="1">{
        normalized := opts
        normalized.Page = repository.NormalizePage(opts.Page)
        normalized.PageSize = repository.NormalizePageSize(opts.PageSize)

        orders, total, err := s.orders.List(ctx, normalized)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">pagination := buildPagination(normalized.Page, normalized.PageSize, total)
        return orders, &amp;pagination, nil</span>
}

// GetOrder 获取订单详情。
func (s *AdminService) GetOrder(ctx context.Context, id uint64) (*model.Order, error) <span class="cov8" title="1">{
        return s.orders.Get(ctx, id)
}</span>

// UpdateOrder 更新订单信息。
func (s *AdminService) UpdateOrder(ctx context.Context, id uint64, input UpdateOrderInput) (*model.Order, error) <span class="cov8" title="1">{
        order, err := s.orders.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !isValidOrderStatus(input.Status) </span><span class="cov8" title="1">{
                return nil, ErrValidation
        }</span>
        <span class="cov8" title="1">if !model.IsValidCurrency(input.Currency) </span><span class="cov8" title="1">{
                return nil, ErrValidation
        }</span>
        <span class="cov8" title="1">if input.TotalPriceCents &lt; 0 </span><span class="cov8" title="1">{
                return nil, ErrValidation
        }</span>
        <span class="cov8" title="1">if input.ScheduledStart != nil &amp;&amp; input.ScheduledEnd != nil &amp;&amp; input.ScheduledEnd.Before(*input.ScheduledStart) </span><span class="cov8" title="1">{
                return nil, ErrValidation
        }</span>

        // state machine guard
        <span class="cov8" title="1">if !isAllowedOrderTransition(order.Status, input.Status) </span><span class="cov8" title="1">{
                return nil, ErrOrderInvalidTransition
        }</span>

        <span class="cov8" title="1">prevStatus := order.Status

        order.Status = input.Status
        order.TotalPriceCents = input.TotalPriceCents
        order.Currency = input.Currency
        order.ScheduledStart = input.ScheduledStart
        order.ScheduledEnd = input.ScheduledEnd
        order.CancelReason = strings.TrimSpace(input.CancelReason)
        if input.StartedAt != nil </span><span class="cov0" title="0">{
                order.StartedAt = input.StartedAt
        }</span>
        <span class="cov8" title="1">if input.CompletedAt != nil </span><span class="cov0" title="0">{
                order.CompletedAt = input.CompletedAt
        }</span>
        <span class="cov8" title="1">if input.RefundAmountCents != nil </span><span class="cov8" title="1">{
                order.RefundAmountCents = *input.RefundAmountCents
        }</span>
        <span class="cov8" title="1">if input.RefundReason != "" || input.RefundAmountCents != nil </span><span class="cov8" title="1">{
                order.RefundReason = strings.TrimSpace(input.RefundReason)
        }</span>
        <span class="cov8" title="1">if input.RefundedAt != nil </span><span class="cov8" title="1">{
                order.RefundedAt = input.RefundedAt
        }</span>

        <span class="cov8" title="1">if err := s.orders.Update(ctx, order); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">s.invalidateCache(ctx, cacheKeyOrders)
        action := model.OpActionUpdateStatus
        switch order.Status </span>{
        case model.OrderStatusCanceled:<span class="cov8" title="1">
                action = model.OpActionCancel</span>
        case model.OrderStatusRefunded:<span class="cov8" title="1">
                action = model.OpActionRefund</span>
        default:<span class="cov8" title="1">
                switch </span>{
                case prevStatus == model.OrderStatusPending &amp;&amp; order.Status == model.OrderStatusConfirmed:<span class="cov8" title="1">
                        action = model.OpActionConfirm</span>
                case prevStatus == model.OrderStatusConfirmed &amp;&amp; order.Status == model.OrderStatusInProgress:<span class="cov0" title="0">
                        action = model.OpActionStart</span>
                case prevStatus == model.OrderStatusInProgress &amp;&amp; order.Status == model.OrderStatusCompleted:<span class="cov0" title="0">
                        action = model.OpActionComplete</span>
                }
        }
        <span class="cov8" title="1">meta := map[string]any{
                "status":      order.Status,
                "from_status": prevStatus,
        }
        if order.CancelReason != "" </span><span class="cov0" title="0">{
                meta["reason"] = order.CancelReason
        }</span>
        <span class="cov8" title="1">if input.Note != "" </span><span class="cov0" title="0">{
                meta["note"] = strings.TrimSpace(input.Note)
        }</span>
        <span class="cov8" title="1">if order.StartedAt != nil </span><span class="cov0" title="0">{
                meta["started_at"] = order.StartedAt.Format(time.RFC3339)
        }</span>
        <span class="cov8" title="1">if order.CompletedAt != nil </span><span class="cov0" title="0">{
                meta["completed_at"] = order.CompletedAt.Format(time.RFC3339)
        }</span>
        <span class="cov8" title="1">if input.RefundAmountCents != nil </span><span class="cov8" title="1">{
                meta["refund_amount_cents"] = order.RefundAmountCents
        }</span>
        <span class="cov8" title="1">if order.RefundReason != "" </span><span class="cov8" title="1">{
                meta["refund_reason"] = order.RefundReason
        }</span>
        <span class="cov8" title="1">if order.RefundedAt != nil </span><span class="cov8" title="1">{
                meta["refunded_at"] = order.RefundedAt.Format(time.RFC3339)
        }</span>
        <span class="cov8" title="1">s.appendLogAsync(ctx, string(model.OpEntityOrder), order.ID, string(action), meta)
        if rid, ok := logging.RequestIDFromContext(ctx); ok </span><span class="cov0" title="0">{
                slog.Info("order_status_changed", slog.Uint64("order_id", order.ID), slog.String("status", string(order.Status)), slog.String("request_id", rid))
        }</span> else<span class="cov8" title="1"> {
                slog.Info("order_status_changed", slog.Uint64("order_id", order.ID), slog.String("status", string(order.Status)))
        }</span>
        <span class="cov8" title="1">return order, nil</span>
}

// ConfirmOrder 将订单从 pending 确认到 confirmed。
func (s *AdminService) ConfirmOrder(ctx context.Context, id uint64, note string) (*model.Order, error) <span class="cov0" title="0">{
        order, err := s.orders.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">note = strings.TrimSpace(note)
        return s.UpdateOrder(ctx, id, UpdateOrderInput{
                Status:          model.OrderStatusConfirmed,
                TotalPriceCents: order.TotalPriceCents,
                Currency:        order.Currency,
                ScheduledStart:  order.ScheduledStart,
                ScheduledEnd:    order.ScheduledEnd,
                CancelReason:    order.CancelReason,
                StartedAt:       order.StartedAt,
                CompletedAt:     order.CompletedAt,
                RefundReason:    order.RefundReason,
                RefundedAt:      order.RefundedAt,
                Note:            note,
        })</span>
}

// StartOrder 将订单置为进行中，并记录实际开始时间。
func (s *AdminService) StartOrder(ctx context.Context, id uint64, note string) (*model.Order, error) <span class="cov0" title="0">{
        order, err := s.orders.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">note = strings.TrimSpace(note)
        startedAt := time.Now().UTC()
        return s.UpdateOrder(ctx, id, UpdateOrderInput{
                Status:          model.OrderStatusInProgress,
                TotalPriceCents: order.TotalPriceCents,
                Currency:        order.Currency,
                ScheduledStart:  order.ScheduledStart,
                ScheduledEnd:    order.ScheduledEnd,
                CancelReason:    order.CancelReason,
                StartedAt:       &amp;startedAt,
                CompletedAt:     order.CompletedAt,
                RefundReason:    order.RefundReason,
                RefundedAt:      order.RefundedAt,
                Note:            note,
        })</span>
}

// CompleteOrder 完成订单服务，并记录完成时间。
func (s *AdminService) CompleteOrder(ctx context.Context, id uint64, note string) (*model.Order, error) <span class="cov0" title="0">{
        order, err := s.orders.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">note = strings.TrimSpace(note)
        completedAt := time.Now().UTC()
        return s.UpdateOrder(ctx, id, UpdateOrderInput{
                Status:          model.OrderStatusCompleted,
                TotalPriceCents: order.TotalPriceCents,
                Currency:        order.Currency,
                ScheduledStart:  order.ScheduledStart,
                ScheduledEnd:    order.ScheduledEnd,
                CancelReason:    order.CancelReason,
                StartedAt:       order.StartedAt,
                CompletedAt:     &amp;completedAt,
                RefundReason:    order.RefundReason,
                RefundedAt:      order.RefundedAt,
                Note:            note,
        })</span>
}

// RefundOrder 执行退款并记录退款信息。
func (s *AdminService) RefundOrder(ctx context.Context, id uint64, input RefundOrderInput) (*model.Order, error) <span class="cov0" title="0">{
        order, err := s.orders.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">reason := strings.TrimSpace(input.Reason)
        if reason == "" </span><span class="cov0" title="0">{
                return nil, ErrValidation
        }</span>
        <span class="cov0" title="0">switch order.Status </span>{
        case model.OrderStatusCompleted, model.OrderStatusInProgress, model.OrderStatusConfirmed:<span class="cov0" title="0"></span>
                // allowed
        default:<span class="cov0" title="0">
                return nil, ErrValidation</span>
        }
        <span class="cov0" title="0">amount := order.TotalPriceCents
        if input.AmountCents != nil </span><span class="cov0" title="0">{
                if *input.AmountCents &lt;= 0 || *input.AmountCents &gt; order.TotalPriceCents </span><span class="cov0" title="0">{
                        return nil, ErrValidation
                }</span>
                <span class="cov0" title="0">amount = *input.AmountCents</span>
        }
        <span class="cov0" title="0">refundedAt := time.Now().UTC()
        note := strings.TrimSpace(input.Note)
        updatedOrder, err := s.UpdateOrder(ctx, id, UpdateOrderInput{
                Status:            model.OrderStatusRefunded,
                TotalPriceCents:   order.TotalPriceCents,
                Currency:          order.Currency,
                ScheduledStart:    order.ScheduledStart,
                ScheduledEnd:      order.ScheduledEnd,
                CancelReason:      order.CancelReason,
                StartedAt:         order.StartedAt,
                CompletedAt:       order.CompletedAt,
                RefundAmountCents: &amp;amount,
                RefundReason:      reason,
                RefundedAt:        &amp;refundedAt,
                Note:              note,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 更新相关支付为已退款状态（若存在）
        <span class="cov0" title="0">payments, err := s.listPaymentsByOrder(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, pay := range payments </span><span class="cov0" title="0">{
                if pay.Status == model.PaymentStatusRefunded </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if pay.Status == model.PaymentStatusPaid || pay.Status == model.PaymentStatusPending </span><span class="cov0" title="0">{
                        _, updErr := s.UpdatePayment(ctx, pay.ID, UpdatePaymentInput{
                                Status:          model.PaymentStatusRefunded,
                                ProviderTradeNo: pay.ProviderTradeNo,
                                ProviderRaw:     pay.ProviderRaw,
                                PaidAt:          pay.PaidAt,
                                RefundedAt:      &amp;refundedAt,
                        })
                        if updErr != nil &amp;&amp; !errors.Is(updErr, ErrValidation) </span><span class="cov0" title="0">{
                                return nil, updErr
                        }</span>
                }
        }
        <span class="cov0" title="0">return updatedOrder, nil</span>
}

// GetOrderPayments 返回订单下的所有支付记录。
func (s *AdminService) GetOrderPayments(ctx context.Context, orderID uint64) ([]model.Payment, error) <span class="cov8" title="1">{
        return s.listPaymentsByOrder(ctx, orderID)
}</span>

// GetOrderRefunds 汇总订单退款记录（基于支付信息与订单字段）。
func (s *AdminService) GetOrderRefunds(ctx context.Context, orderID uint64) ([]OrderRefundItem, error) <span class="cov8" title="1">{
        order, err := s.orders.Get(ctx, orderID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">payments, err := s.listPaymentsByOrder(ctx, orderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := make([]OrderRefundItem, 0)
        for _, pay := range payments </span><span class="cov8" title="1">{
                if pay.Status != model.PaymentStatusRefunded </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">item := OrderRefundItem{
                        ID:          pay.ID,
                        OrderID:     orderID,
                        PaymentID:   pay.ID,
                        AmountCents: pay.AmountCents,
                        Method:      string(pay.Method),
                        Status:      mapRefundStatus(pay.Status),
                        RefundedAt:  pay.RefundedAt,
                        CreatedAt:   pay.CreatedAt,
                        Reason:      order.RefundReason,
                        Note:        order.RefundReason,
                }
                result = append(result, item)</span>
        }

        // 如果订单存在退款金额但支付记录未覆盖，则补充一条摘要信息
        <span class="cov8" title="1">if order.RefundAmountCents &gt; 0 </span><span class="cov8" title="1">{
                hasSummary := false
                for _, item := range result </span><span class="cov8" title="1">{
                        if item.AmountCents == order.RefundAmountCents </span><span class="cov8" title="1">{
                                hasSummary = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !hasSummary </span><span class="cov8" title="1">{
                        createdAt := order.UpdatedAt
                        if order.RefundedAt != nil </span><span class="cov8" title="1">{
                                createdAt = *order.RefundedAt
                        }</span>
                        <span class="cov8" title="1">item := OrderRefundItem{
                                ID:          orderID*10 + 1,
                                OrderID:     orderID,
                                PaymentID:   0,
                                AmountCents: order.RefundAmountCents,
                                Method:      "unknown",
                                Status:      "success",
                                Reason:      order.RefundReason,
                                RefundedAt:  order.RefundedAt,
                                CreatedAt:   createdAt,
                                Note:        order.RefundReason,
                        }
                        result = append(result, item)</span>
                }
        }

        <span class="cov8" title="1">sort.Slice(result, func(i, j int) bool </span><span class="cov8" title="1">{
                return result[i].CreatedAt.Before(result[j].CreatedAt)
        }</span>)
        <span class="cov8" title="1">return result, nil</span>
}

// GetOrderReviews 返回订单相关的全部评价。
func (s *AdminService) GetOrderReviews(ctx context.Context, orderID uint64) ([]model.Review, error) <span class="cov8" title="1">{
        reviews := make([]model.Review, 0)
        page := 1
        orderIDCopy := orderID
        for </span><span class="cov8" title="1">{
                opts := repository.ReviewListOptions{
                        Page:     page,
                        PageSize: 200,
                        OrderID:  &amp;orderIDCopy,
                }
                items, pagination, err := s.ListReviews(ctx, opts)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">reviews = append(reviews, items...)
                if pagination == nil || !pagination.HasNext </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">page++</span>
        }
        <span class="cov8" title="1">return reviews, nil</span>
}

// GetOrderTimeline 汇总订单的状态流转与关键事件。
func (s *AdminService) GetOrderTimeline(ctx context.Context, orderID uint64) ([]OrderTimelineItem, error) <span class="cov8" title="1">{
        order, err := s.orders.Get(ctx, orderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">logs, err := s.collectOperationLogs(ctx, string(model.OpEntityOrder), orderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">userCache := make(map[uint64]*model.User)
        items := make([]OrderTimelineItem, 0, len(logs))
        for _, logEntry := range logs </span><span class="cov8" title="1">{
                meta := map[string]any{}
                if len(logEntry.MetadataJSON) &gt; 0 </span><span class="cov8" title="1">{
                        _ = json.Unmarshal(logEntry.MetadataJSON, &amp;meta)
                }</span>
                <span class="cov8" title="1">item := OrderTimelineItem{
                        ID:        logEntry.ID,
                        OrderID:   orderID,
                        EventType: mapTimelineEventType(logEntry.Action),
                        Title:     mapTimelineTitle(logEntry.Action),
                        Metadata:  meta,
                        CreatedAt: logEntry.CreatedAt,
                }
                if note, ok := meta["note"].(string); ok &amp;&amp; strings.TrimSpace(note) != "" </span><span class="cov8" title="1">{
                        item.Description = strings.TrimSpace(note)
                }</span> else<span class="cov8" title="1"> if reason, ok := meta["reason"].(string); ok &amp;&amp; strings.TrimSpace(reason) != "" </span><span class="cov0" title="0">{
                        item.Description = strings.TrimSpace(reason)
                }</span>
                <span class="cov8" title="1">if before, ok := meta["from_status"].(string); ok </span><span class="cov8" title="1">{
                        item.StatusBefore = before
                }</span>
                <span class="cov8" title="1">if after, ok := meta["status"].(string); ok </span><span class="cov8" title="1">{
                        item.StatusAfter = after
                }</span>
                <span class="cov8" title="1">if logEntry.ActorUserID != nil </span><span class="cov8" title="1">{
                        if user := s.resolveUser(ctx, userCache, *logEntry.ActorUserID); user != nil </span><span class="cov8" title="1">{
                                item.Operator = user.Name
                                item.OperatorRole = string(user.Role)
                                id := user.ID
                                item.OperatorID = &amp;id
                        }</span>
                }
                <span class="cov8" title="1">items = append(items, item)</span>
        }

        // 追加支付关键事件
        <span class="cov8" title="1">payments, err := s.listPaymentsByOrder(ctx, orderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, pay := range payments </span><span class="cov8" title="1">{
                if pay.PaidAt != nil </span><span class="cov8" title="1">{
                        item := OrderTimelineItem{
                                ID:        pay.ID*10 + 1,
                                OrderID:   orderID,
                                PaymentID: ptrUint64(pay.ID),
                                EventType: "action",
                                Title:     "支付确认",
                                Metadata: map[string]any{
                                        "payment_status": pay.Status,
                                        "payment_method": pay.Method,
                                        "amount_cents":   pay.AmountCents,
                                },
                                CreatedAt: *pay.PaidAt,
                        }
                        items = append(items, item)
                }</span>
                <span class="cov8" title="1">if pay.RefundedAt != nil </span><span class="cov0" title="0">{
                        item := OrderTimelineItem{
                                ID:          pay.ID*10 + 2,
                                OrderID:     orderID,
                                PaymentID:   ptrUint64(pay.ID),
                                EventType:   "status_change",
                                Title:       "支付退款",
                                Description: strings.TrimSpace(order.RefundReason),
                                Metadata: map[string]any{
                                        "payment_status": pay.Status,
                                        "payment_method": pay.Method,
                                        "amount_cents":   pay.AmountCents,
                                },
                                CreatedAt:   *pay.RefundedAt,
                                StatusAfter: string(model.OrderStatusRefunded),
                        }
                        items = append(items, item)
                }</span>
        }

        <span class="cov8" title="1">sort.Slice(items, func(i, j int) bool </span><span class="cov8" title="1">{
                return items[i].CreatedAt.Before(items[j].CreatedAt)
        }</span>)

        <span class="cov8" title="1">return items, nil</span>
}

// DeleteOrder 删除订单（软删）。
func (s *AdminService) DeleteOrder(ctx context.Context, id uint64) error <span class="cov8" title="1">{
        if err := s.orders.Delete(ctx, id); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">s.invalidateCache(ctx, cacheKeyOrders)
        s.appendLogAsync(ctx, string(model.OpEntityOrder), id, string(model.OpActionDelete), nil)
        return nil</span>
}

// --- Payment management ---

// UpdatePaymentInput 调整支付状态。
type UpdatePaymentInput struct {
        Status          model.PaymentStatus
        ProviderTradeNo string
        ProviderRaw     json.RawMessage
        PaidAt          *time.Time
        RefundedAt      *time.Time
}

// CreatePaymentInput 创建支付记录。
type CreatePaymentInput struct {
        OrderID     uint64
        UserID      uint64
        Method      model.PaymentMethod
        AmountCents int64
        Currency    model.Currency
        ProviderRaw json.RawMessage
}

// CreatePayment 新建支付记录，默认状态 pending。
func (s *AdminService) CreatePayment(ctx context.Context, in CreatePaymentInput) (*model.Payment, error) <span class="cov0" title="0">{
        if in.OrderID == 0 || in.UserID == 0 || in.AmountCents &lt;= 0 || !model.IsValidCurrency(in.Currency) </span><span class="cov0" title="0">{
                return nil, ErrValidation
        }</span>
        <span class="cov0" title="0">if in.Method == "" </span><span class="cov0" title="0">{
                return nil, ErrValidation
        }</span>
        <span class="cov0" title="0">if _, err := s.orders.Get(ctx, in.OrderID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if _, err := s.users.Get(ctx, in.UserID); err != nil </span><span class="cov0" title="0">{
                return nil, mapUserError(err)
        }</span>
        <span class="cov0" title="0">pay := &amp;model.Payment{
                OrderID:     in.OrderID,
                UserID:      in.UserID,
                Method:      in.Method,
                AmountCents: in.AmountCents,
                Currency:    in.Currency,
                Status:      model.PaymentStatusPending,
                ProviderRaw: in.ProviderRaw,
        }
        if err := s.payments.Create(ctx, pay); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">s.invalidateCache(ctx, cacheKeyPayments)
        s.appendLogAsync(ctx, string(model.OpEntityPayment), pay.ID, string(model.OpActionCreate), map[string]any{"status": pay.Status, "method": pay.Method})
        return pay, nil</span>
}

// CapturePaymentInput 确认入账。
type CapturePaymentInput struct {
        ProviderTradeNo string
        ProviderRaw     json.RawMessage
        PaidAt          *time.Time
}

// CapturePayment 将支付置为 paid。
func (s *AdminService) CapturePayment(ctx context.Context, id uint64, in CapturePaymentInput) (*model.Payment, error) <span class="cov8" title="1">{
        pay, err := s.payments.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !isAllowedPaymentTransition(pay.Status, model.PaymentStatusPaid) </span><span class="cov0" title="0">{
                return nil, ErrValidation
        }</span>
        <span class="cov8" title="1">pay.Status = model.PaymentStatusPaid
        pay.ProviderTradeNo = strings.TrimSpace(in.ProviderTradeNo)
        pay.ProviderRaw = in.ProviderRaw
        if in.PaidAt != nil </span><span class="cov8" title="1">{
                pay.PaidAt = in.PaidAt
        }</span> else<span class="cov0" title="0"> {
                now := time.Now().UTC()
                pay.PaidAt = &amp;now
        }</span>
        <span class="cov8" title="1">if err := s.payments.Update(ctx, pay); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">s.invalidateCache(ctx, cacheKeyPayments)
        s.appendLogAsync(ctx, string(model.OpEntityPayment), pay.ID, string(model.OpActionCapture), map[string]any{"trade_no": pay.ProviderTradeNo})
        return pay, nil</span>
}

// ListPayments 列出支付记录。
func (s *AdminService) ListPayments(ctx context.Context, opts repository.PaymentListOptions) ([]model.Payment, *model.Pagination, error) <span class="cov8" title="1">{
        normalized := opts
        normalized.Page = repository.NormalizePage(opts.Page)
        normalized.PageSize = repository.NormalizePageSize(opts.PageSize)

        payments, total, err := s.payments.List(ctx, normalized)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">pagination := buildPagination(normalized.Page, normalized.PageSize, total)
        return payments, &amp;pagination, nil</span>
}

// GetPayment 获取支付详情。
func (s *AdminService) GetPayment(ctx context.Context, id uint64) (*model.Payment, error) <span class="cov8" title="1">{
        return s.payments.Get(ctx, id)
}</span>

// UpdatePayment 更新支付状态。
func (s *AdminService) UpdatePayment(ctx context.Context, id uint64, input UpdatePaymentInput) (*model.Payment, error) <span class="cov8" title="1">{
        payment, err := s.payments.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !isValidPaymentStatus(input.Status) </span><span class="cov8" title="1">{
                return nil, ErrValidation
        }</span>

        <span class="cov8" title="1">if !isAllowedPaymentTransition(payment.Status, input.Status) </span><span class="cov8" title="1">{
                return nil, ErrValidation
        }</span>

        <span class="cov8" title="1">payment.Status = input.Status
        payment.ProviderTradeNo = strings.TrimSpace(input.ProviderTradeNo)
        payment.ProviderRaw = input.ProviderRaw
        payment.PaidAt = input.PaidAt
        payment.RefundedAt = input.RefundedAt

        if err := s.payments.Update(ctx, payment); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">s.invalidateCache(ctx, cacheKeyPayments)
        payAction := model.OpActionUpdateStatus
        if input.Status == model.PaymentStatusRefunded </span><span class="cov0" title="0">{
                payAction = model.OpActionRefund
        }</span>
        <span class="cov8" title="1">s.appendLogAsync(ctx, string(model.OpEntityPayment), payment.ID, string(payAction), map[string]any{"status": payment.Status})
        if rid, ok := logging.RequestIDFromContext(ctx); ok </span><span class="cov0" title="0">{
                slog.Info("payment_status_changed", slog.Uint64("payment_id", payment.ID), slog.String("status", string(payment.Status)), slog.String("request_id", rid))
        }</span> else<span class="cov8" title="1"> {
                slog.Info("payment_status_changed", slog.Uint64("payment_id", payment.ID), slog.String("status", string(payment.Status)))
        }</span>
        <span class="cov8" title="1">return payment, nil</span>
}

// DeletePayment 删除支付记录。
func (s *AdminService) DeletePayment(ctx context.Context, id uint64) error <span class="cov8" title="1">{
        if err := s.payments.Delete(ctx, id); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">s.invalidateCache(ctx, cacheKeyPayments)
        s.appendLogAsync(ctx, string(model.OpEntityPayment), id, string(model.OpActionDelete), nil)
        return nil</span>
}

// appendLogAsync 追加操作日志（尽力而为，不影响主流程）。
func (s *AdminService) appendLogAsync(ctx context.Context, entity string, id uint64, action string, meta map[string]any) <span class="cov8" title="1">{
        if s.tx == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">_ = s.tx.WithTx(ctx, func(r *common.Repos) error </span><span class="cov0" title="0">{
                var raw []byte
                if meta != nil </span><span class="cov0" title="0">{
                        if b, err := json.Marshal(meta); err == nil </span><span class="cov0" title="0">{
                                raw = b
                        }</span>
                }
                <span class="cov0" title="0">var actorPtr *uint64
                if uid, ok := logging.ActorUserIDFromContext(ctx); ok </span><span class="cov0" title="0">{
                        actorID := uid
                        actorPtr = &amp;actorID
                }</span>
                <span class="cov0" title="0">log := &amp;model.OperationLog{EntityType: entity, EntityID: id, Action: action, ActorUserID: actorPtr, MetadataJSON: raw}
                return r.OpLogs.Append(ctx, log)</span>
        })
}

func isValidOrderStatus(status model.OrderStatus) bool <span class="cov8" title="1">{
        switch status </span>{
        case model.OrderStatusPending, model.OrderStatusConfirmed, model.OrderStatusInProgress,
                model.OrderStatusCompleted, model.OrderStatusCanceled, model.OrderStatusRefunded:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func isAllowedOrderTransition(prev, next model.OrderStatus) bool <span class="cov8" title="1">{
        if prev == next </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">switch prev </span>{
        case model.OrderStatusPending:<span class="cov8" title="1">
                return next == model.OrderStatusConfirmed || next == model.OrderStatusCanceled || next == model.OrderStatusRefunded</span>
        case model.OrderStatusConfirmed:<span class="cov8" title="1">
                return next == model.OrderStatusInProgress || next == model.OrderStatusCanceled || next == model.OrderStatusRefunded</span>
        case model.OrderStatusInProgress:<span class="cov0" title="0">
                return next == model.OrderStatusCompleted || next == model.OrderStatusCanceled || next == model.OrderStatusRefunded</span>
        case model.OrderStatusCompleted:<span class="cov0" title="0">
                return next == model.OrderStatusRefunded</span>
        case model.OrderStatusCanceled, model.OrderStatusRefunded:<span class="cov0" title="0">
                return false</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func isValidPaymentStatus(status model.PaymentStatus) bool <span class="cov8" title="1">{
        switch status </span>{
        case model.PaymentStatusPending, model.PaymentStatusPaid, model.PaymentStatusFailed, model.PaymentStatusRefunded:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func isAllowedPaymentTransition(prev, next model.PaymentStatus) bool <span class="cov8" title="1">{
        if prev == next </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">switch prev </span>{
        case model.PaymentStatusPending:<span class="cov8" title="1">
                return next == model.PaymentStatusPaid || next == model.PaymentStatusFailed || next == model.PaymentStatusRefunded</span>
        case model.PaymentStatusPaid:<span class="cov8" title="1">
                return next == model.PaymentStatusRefunded</span>
        case model.PaymentStatusFailed, model.PaymentStatusRefunded:<span class="cov0" title="0">
                return false</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func (s *AdminService) listPaymentsByOrder(ctx context.Context, orderID uint64) ([]model.Payment, error) <span class="cov8" title="1">{
        result := make([]model.Payment, 0)
        page := 1
        for </span><span class="cov8" title="1">{
                opts := repository.PaymentListOptions{
                        Page:     page,
                        PageSize: 200,
                }
                orderIDCopy := orderID
                opts.OrderID = &amp;orderIDCopy
                items, pagination, err := s.ListPayments(ctx, opts)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">result = append(result, items...)
                if pagination == nil || !pagination.HasNext </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">page++</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

func (s *AdminService) collectOperationLogs(ctx context.Context, entityType string, entityID uint64) ([]model.OperationLog, error) <span class="cov8" title="1">{
        all := make([]model.OperationLog, 0)
        page := 1
        for </span><span class="cov8" title="1">{
                opts := repository.OperationLogListOptions{
                        Page:     page,
                        PageSize: 200,
                }
                items, pagination, err := s.ListOperationLogs(ctx, entityType, entityID, opts)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">all = append(all, items...)
                if pagination == nil || !pagination.HasNext </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">page++</span>
        }
        <span class="cov8" title="1">return all, nil</span>
}

func (s *AdminService) resolveUser(ctx context.Context, cache map[uint64]*model.User, id uint64) *model.User <span class="cov8" title="1">{
        if user, ok := cache[id]; ok </span><span class="cov0" title="0">{
                return user
        }</span>
        <span class="cov8" title="1">user, err := s.users.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                cache[id] = nil
                return nil
        }</span>
        <span class="cov8" title="1">cache[id] = user
        return user</span>
}

func mapUserError(err error) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if errors.Is(err, repository.ErrNotFound) </span><span class="cov8" title="1">{
                return ErrUserNotFound
        }</span>
        <span class="cov0" title="0">return err</span>
}

func mapRefundStatus(status model.PaymentStatus) string <span class="cov8" title="1">{
        switch status </span>{
        case model.PaymentStatusRefunded:<span class="cov8" title="1">
                return "success"</span>
        case model.PaymentStatusPending:<span class="cov0" title="0">
                return "pending"</span>
        case model.PaymentStatusFailed:<span class="cov0" title="0">
                return "failed"</span>
        default:<span class="cov0" title="0">
                return strings.ToLower(string(status))</span>
        }
}

func mapTimelineEventType(action string) string <span class="cov8" title="1">{
        switch action </span>{
        case string(model.OpActionCreate):<span class="cov8" title="1">
                return "system"</span>
        case string(model.OpActionAssignPlayer):<span class="cov0" title="0">
                return "action"</span>
        case string(model.OpActionConfirm), string(model.OpActionStart), string(model.OpActionComplete),
                string(model.OpActionUpdateStatus), string(model.OpActionCancel), string(model.OpActionRefund):<span class="cov0" title="0">
                return "status_change"</span>
        default:<span class="cov8" title="1">
                return "action"</span>
        }
}

func mapTimelineTitle(action string) string <span class="cov8" title="1">{
        switch action </span>{
        case string(model.OpActionCreate):<span class="cov8" title="1">
                return "订单创建"</span>
        case string(model.OpActionAssignPlayer):<span class="cov0" title="0">
                return "指派陪玩师"</span>
        case string(model.OpActionConfirm):<span class="cov0" title="0">
                return "订单确认"</span>
        case string(model.OpActionStart):<span class="cov0" title="0">
                return "开始服务"</span>
        case string(model.OpActionComplete):<span class="cov0" title="0">
                return "完成订单"</span>
        case string(model.OpActionCancel):<span class="cov0" title="0">
                return "订单取消"</span>
        case string(model.OpActionRefund):<span class="cov0" title="0">
                return "订单退款"</span>
        case string(model.OpActionUpdateStatus):<span class="cov0" title="0">
                return "状态更新"</span>
        default:<span class="cov8" title="1">
                return strings.ReplaceAll(action, "_", " ")</span>
        }
}

func ptrUint64(id uint64) *uint64 <span class="cov8" title="1">{
        return &amp;id
}</span>

func (s *AdminService) invalidateCache(ctx context.Context, keys ...string) <span class="cov8" title="1">{
        if s.cache == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">for _, key := range keys </span><span class="cov8" title="1">{
                _ = s.cache.Delete(ctx, key)
        }</span>
}

func buildPagination(page, pageSize int, total int64) model.Pagination <span class="cov8" title="1">{
        totalPages := 0
        if pageSize &gt; 0 </span><span class="cov8" title="1">{
                totalPages = int((total + int64(pageSize) - 1) / int64(pageSize))
        }</span>

        <span class="cov8" title="1">return model.Pagination{
                Page:       page,
                PageSize:   pageSize,
                Total:      int(total),
                TotalPages: totalPages,
                HasNext:    page &lt; totalPages,
                HasPrev:    page &gt; 1,
        }</span>
}

// ListOperationLogs 返回实体的操作日志。
func (s *AdminService) ListOperationLogs(ctx context.Context, entityType string, entityID uint64, opts repository.OperationLogListOptions) ([]model.OperationLog, *model.Pagination, error) <span class="cov8" title="1">{
        if s.tx == nil </span><span class="cov8" title="1">{
                return nil, nil, errors.New("transaction manager not configured")
        }</span>
        <span class="cov8" title="1">var logs []model.OperationLog
        var total int64
        err := s.tx.WithTx(ctx, func(r *common.Repos) error </span><span class="cov8" title="1">{
                norm := repository.OperationLogListOptions{
                        Page:        repository.NormalizePage(opts.Page),
                        PageSize:    repository.NormalizePageSize(opts.PageSize),
                        Action:      opts.Action,
                        ActorUserID: opts.ActorUserID,
                        DateFrom:    opts.DateFrom,
                        DateTo:      opts.DateTo,
                }
                items, cnt, err := r.OpLogs.ListByEntity(ctx, entityType, entityID, norm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">logs, total = items, cnt
                return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">p := buildPagination(repository.NormalizePage(opts.Page), repository.NormalizePageSize(opts.PageSize), total)
        return logs, &amp;p, nil</span>
}

// --- Review management ---

// ListReviews 列出评价。
func (s *AdminService) ListReviews(ctx context.Context, opts repository.ReviewListOptions) ([]model.Review, *model.Pagination, error) <span class="cov8" title="1">{
        if s.tx == nil </span><span class="cov0" title="0">{
                return nil, nil, errors.New("transaction manager not configured")
        }</span>
        <span class="cov8" title="1">var items []model.Review
        var total int64
        err := s.tx.WithTx(ctx, func(r *common.Repos) error </span><span class="cov8" title="1">{
                page := repository.NormalizePage(opts.Page)
                size := repository.NormalizePageSize(opts.PageSize)
                out, cnt, err := r.Reviews.List(ctx, repository.ReviewListOptions{
                        Page: page, PageSize: size, OrderID: opts.OrderID, UserID: opts.UserID, PlayerID: opts.PlayerID, DateFrom: opts.DateFrom, DateTo: opts.DateTo,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">items, total = out, cnt
                return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">p := buildPagination(repository.NormalizePage(opts.Page), repository.NormalizePageSize(opts.PageSize), total)
        return items, &amp;p, nil</span>
}

// GetReview 返回评价详情。
func (s *AdminService) GetReview(ctx context.Context, id uint64) (*model.Review, error) <span class="cov0" title="0">{
        if s.tx == nil </span><span class="cov0" title="0">{
                return nil, errors.New("transaction manager not configured")
        }</span>
        <span class="cov0" title="0">var item *model.Review
        err := s.tx.WithTx(ctx, func(r *common.Repos) error </span><span class="cov0" title="0">{
                var err error
                item, err = r.Reviews.Get(ctx, id)
                return err
        }</span>)
        <span class="cov0" title="0">return item, err</span>
}

// CreateReview 新建评价。
func (s *AdminService) CreateReview(ctx context.Context, r model.Review) (*model.Review, error) <span class="cov0" title="0">{
        if !r.Score.Valid() || r.OrderID == 0 || r.UserID == 0 || r.PlayerID == 0 </span><span class="cov0" title="0">{
                return nil, ErrValidation
        }</span>
        <span class="cov0" title="0">if s.tx == nil </span><span class="cov0" title="0">{
                return nil, errors.New("transaction manager not configured")
        }</span>
        <span class="cov0" title="0">err := s.tx.WithTx(ctx, func(txr *common.Repos) error </span><span class="cov0" title="0">{ return txr.Reviews.Create(ctx, &amp;r) }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">s.appendLogAsync(ctx, string(model.OpEntityReview), r.ID, string(model.OpActionCreate), map[string]any{"order_id": r.OrderID, "player_id": r.PlayerID})
        return &amp;r, nil</span>
}

// UpdateReview 修改评价分数/内容。
func (s *AdminService) UpdateReview(ctx context.Context, id uint64, score model.Rating, content string) (*model.Review, error) <span class="cov0" title="0">{
        if !score.Valid() </span><span class="cov0" title="0">{
                return nil, ErrValidation
        }</span>
        <span class="cov0" title="0">if s.tx == nil </span><span class="cov0" title="0">{
                return nil, errors.New("transaction manager not configured")
        }</span>
        <span class="cov0" title="0">var item *model.Review
        err := s.tx.WithTx(ctx, func(r *common.Repos) error </span><span class="cov0" title="0">{
                obj, err := r.Reviews.Get(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">obj.Score = score
                obj.Content = strings.TrimSpace(content)
                if err := r.Reviews.Update(ctx, obj); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">item = obj
                return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">s.appendLogAsync(ctx, string(model.OpEntityReview), id, string(model.OpActionUpdate), nil)
        return item, nil</span>
}

// DeleteReview 删除评价。
func (s *AdminService) DeleteReview(ctx context.Context, id uint64) error <span class="cov0" title="0">{
        if s.tx == nil </span><span class="cov0" title="0">{
                return errors.New("transaction manager not configured")
        }</span>
        <span class="cov0" title="0">return s.tx.WithTx(ctx, func(r *common.Repos) error </span><span class="cov0" title="0">{ return r.Reviews.Delete(ctx, id) }</span>)
}

func getCachedList[T any](ctx context.Context, c cache.Cache, key string, ttl time.Duration, fetch func() ([]T, error)) ([]T, error) <span class="cov8" title="1">{
        if c != nil </span><span class="cov8" title="1">{
                if raw, ok, err := c.Get(ctx, key); err == nil &amp;&amp; ok </span><span class="cov8" title="1">{
                        var cached []T
                        if err := json.Unmarshal([]byte(raw), &amp;cached); err == nil </span><span class="cov8" title="1">{
                                return cached, nil
                        }</span>
                        <span class="cov0" title="0">_ = c.Delete(ctx, key)</span>
                }
        }

        <span class="cov8" title="1">result, err := fetch()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if c != nil </span><span class="cov8" title="1">{
                if data, err := json.Marshal(result); err == nil </span><span class="cov8" title="1">{
                        _ = c.Set(ctx, key, string(data), ttl)
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package auth

import (
        "context"
        "errors"
        "net/mail"
        "time"

        "golang.org/x/crypto/bcrypt"

        "gamelink/internal/auth"
        "gamelink/internal/model"
        "gamelink/internal/repository"
        "gamelink/internal/service"
)

var (
        ErrInvalidCredentials = service.ErrInvalidCredentials
        ErrUserDisabled       = service.ErrUserDisabled
        ErrNotFound           = service.ErrNotFound
)

// AuthService 认证服务
//
// 功能：
// 1. 用户登录验证
// 2. Token生成和验证
// 3. 用户注册
type AuthService struct {
        userRepo   repository.UserRepository
        jwtManager *auth.JWTManager
}

// NewAuthService 创建认证服务
func NewAuthService(userRepo repository.UserRepository, jwtManager *auth.JWTManager) *AuthService <span class="cov8" title="1">{
        return &amp;AuthService{
                userRepo:   userRepo,
                jwtManager: jwtManager,
        }
}</span>

// GetUser returns a user by id (for /auth/me endpoint).
func (s *AuthService) GetUser(ctx context.Context, id uint64) (*model.User, error) <span class="cov8" title="1">{
        return s.userRepo.Get(ctx, id)
}</span>

// Me verifies Authorization header and returns current user.
func (s *AuthService) Me(ctx context.Context, authorizationHeader string) (*model.User, error) <span class="cov8" title="1">{
        if authorizationHeader == "" </span><span class="cov8" title="1">{
                return nil, errors.New("missing authorization header")
        }</span>
        <span class="cov8" title="1">token, err := auth.ExtractTokenFromHeader(authorizationHeader)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">claims, err := s.jwtManager.VerifyToken(token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if auth.IsTokenExpired(claims) </span><span class="cov0" title="0">{
                return nil, errors.New("token expired")
        }</span>
        <span class="cov8" title="1">user, err := s.userRepo.Get(ctx, claims.UserID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if user.Status != model.UserStatusActive </span><span class="cov8" title="1">{
                return nil, ErrUserDisabled
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}

// LoginRequest 登录请求
type LoginRequest struct {
        Username string `json:"username"` // 用户名（可以是邮箱或手机号）
        Password string `json:"password"` // 密码
}

// LoginResponse 登录响应
type LoginResponse struct {
        Token     string     `json:"token"`      // JWT Token
        ExpiresAt time.Time  `json:"expires_at"` // 过期时间
        User      model.User `json:"user"`       // 用户信息
}

// RegisterRequest 注册请求
type RegisterRequest struct {
        Phone    string     `json:"phone"`
        Email    string     `json:"email"`
        Password string     `json:"password"`
        Name     string     `json:"name"`
        Role     model.Role `json:"role"`
}

// Login 用户登录
//
// 参数：
// - ctx: 上下文
// - req: 登录请求
//
// 返回：
// - LoginResponse: 包含Token和用户信息
// - error: 错误信息
func (s *AuthService) Login(ctx context.Context, req LoginRequest) (*LoginResponse, error) <span class="cov8" title="1">{
        // 验证输入
        if req.Username == "" || req.Password == "" </span><span class="cov8" title="1">{
                return nil, errors.New("username and password are required")
        }</span>

        // 查找用户（通过邮箱或手机号）
        <span class="cov8" title="1">var user *model.User
        var err error

        // 先尝试通过邮箱查找
        if isValidEmail(req.Username) </span><span class="cov8" title="1">{
                user, err = s.userRepo.FindByEmail(ctx, req.Username)
        }</span> else<span class="cov8" title="1"> {
                // 通过手机号查找
                user, err = s.userRepo.FindByPhone(ctx, req.Username)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if err == repository.ErrNotFound </span><span class="cov8" title="1">{
                        return nil, ErrInvalidCredentials
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }

        // 检查用户状态
        <span class="cov8" title="1">if user.Status != model.UserStatusActive </span><span class="cov8" title="1">{
                return nil, ErrUserDisabled
        }</span>

        // 验证密码
        <span class="cov8" title="1">if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(req.Password)); err != nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidCredentials
        }</span>

        // 生成JWT Token
        <span class="cov8" title="1">token, err := s.jwtManager.GenerateToken(user.ID, string(user.Role))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 更新最后登录时间
        <span class="cov8" title="1">now := time.Now()
        user.LastLoginAt = &amp;now
        // 忽略更新时间错误，不影响登录流程
        _ = s.userRepo.Update(ctx, user)

        return &amp;LoginResponse{
                Token:     token,
                ExpiresAt: time.Now().Add(24 * time.Hour), // 与JWT Token有效期一致
                User:      *user,
        }, nil</span>
}

// Register 用户注册
//
// 参数：
// - ctx: 上下文
// - req: 注册请求
//
// 返回：
// - LoginResponse: 包含Token和用户信息
// - error: 错误信息
func (s *AuthService) Register(ctx context.Context, req RegisterRequest) (*LoginResponse, error) <span class="cov8" title="1">{
        // 验证输入
        if err := validateRegisterInput(req); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // 检查邮箱是否已存在
        <span class="cov8" title="1">if req.Email != "" </span><span class="cov8" title="1">{
                if _, err := s.userRepo.FindByEmail(ctx, req.Email); err == nil </span><span class="cov8" title="1">{
                        return nil, errors.New("email already registered")
                }</span> else<span class="cov8" title="1"> if err != repository.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // 检查手机号是否已存在
        <span class="cov8" title="1">if req.Phone != "" </span><span class="cov8" title="1">{
                if _, err := s.userRepo.FindByPhone(ctx, req.Phone); err == nil </span><span class="cov8" title="1">{
                        return nil, errors.New("phone already registered")
                }</span> else<span class="cov8" title="1"> if err != repository.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // 加密密码
        <span class="cov8" title="1">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 创建用户
        <span class="cov8" title="1">user := &amp;model.User{
                Phone:        req.Phone,
                Email:        req.Email,
                PasswordHash: string(hashedPassword),
                Name:         req.Name,
                Role:         req.Role,
                Status:       model.UserStatusActive, // 默认激活状态
        }

        if err := s.userRepo.Create(ctx, user); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // 生成JWT Token
        <span class="cov8" title="1">token, err := s.jwtManager.GenerateToken(user.ID, string(user.Role))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;LoginResponse{
                Token:     token,
                ExpiresAt: time.Now().Add(24 * time.Hour),
                User:      *user,
        }, nil</span>
}

// RefreshToken 刷新Token
func (s *AuthService) RefreshToken(ctx context.Context, tokenString string) (string, error) <span class="cov8" title="1">{
        // 验证当前Token
        claims, err := s.jwtManager.VerifyToken(tokenString)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // 检查用户是否仍然存在且处于激活状态
        <span class="cov8" title="1">user, err := s.userRepo.Get(ctx, claims.UserID)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">if user.Status != model.UserStatusActive </span><span class="cov8" title="1">{
                return "", ErrUserDisabled
        }</span>

        // 刷新Token
        <span class="cov8" title="1">newToken, err := s.jwtManager.RefreshToken(claims)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return newToken, nil</span>
}

// validateRegisterInput 验证注册输入
func validateRegisterInput(req RegisterRequest) error <span class="cov8" title="1">{
        if req.Name == "" </span><span class="cov8" title="1">{
                return errors.New("name is required")
        }</span>
        <span class="cov8" title="1">if req.Email == "" &amp;&amp; req.Phone == "" </span><span class="cov8" title="1">{
                return errors.New("email or phone is required")
        }</span>
        <span class="cov8" title="1">if req.Password == "" </span><span class="cov8" title="1">{
                return errors.New("password is required")
        }</span>
        <span class="cov8" title="1">if len(req.Password) &lt; 6 </span><span class="cov8" title="1">{
                return errors.New("password must be at least 6 characters")
        }</span>
        <span class="cov8" title="1">if req.Role == "" </span><span class="cov8" title="1">{
                req.Role = model.RoleUser // 默认角色
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// isValidEmail 检查是否是有效的邮箱格式
func isValidEmail(email string) bool <span class="cov8" title="1">{
        if email == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">_, err := mail.ParseAddress(email)
        return err == nil</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">package commission

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "math"
        "time"

        "gamelink/internal/model"
        "gamelink/internal/repository"
        commissionrepo "gamelink/internal/repository/commission"
)

var (
        // ErrNotFound 记录不存在
        ErrNotFound = repository.ErrNotFound
        // ErrValidation 表示输入校验失败
        ErrValidation = errors.New("validation failed")
        // ErrAlreadyRecorded 抽成已记录
        ErrAlreadyRecorded = errors.New("commission already recorded")
        // ErrAlreadySettled 已经结算
        ErrAlreadySettled = errors.New("already settled")
)

// CommissionService 抽成服务
type CommissionService struct {
        commissions commissionrepo.CommissionRepository
        orders      repository.OrderRepository
        players     repository.PlayerRepository
}

// NewCommissionService 创建抽成服务
func NewCommissionService(
        commissions commissionrepo.CommissionRepository,
        orders repository.OrderRepository,
        players repository.PlayerRepository,
) *CommissionService <span class="cov8" title="1">{
        return &amp;CommissionService{
                commissions: commissions,
                orders:      orders,
                players:     players,
        }
}</span>

// CalculateCommission 计算订单抽成（便捷方法：通过orderID）
func (s *CommissionService) CalculateCommission(ctx context.Context, orderID uint64) (*CommissionCalculation, error) <span class="cov8" title="1">{
        // 获取订单
        order, err := s.orders.Get(ctx, orderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 调用完整的三层抽成计算
        <span class="cov8" title="1">return s.CalculateOrderCommission(ctx, order)</span>
}

// RecordCommission 记录订单抽成
func (s *CommissionService) RecordCommission(ctx context.Context, orderID uint64) error <span class="cov8" title="1">{
        // 1. 检查是否已记录
        existing, _ := s.commissions.GetRecordByOrderID(ctx, orderID)
        if existing != nil </span><span class="cov8" title="1">{
                return ErrAlreadyRecorded
        }</span>

        // 2. 计算抽成
        <span class="cov8" title="1">calc, err := s.CalculateCommission(ctx, orderID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 3. 获取订单信息
        <span class="cov8" title="1">order, err := s.orders.Get(ctx, orderID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 4. 创建抽成记录
        <span class="cov8" title="1">now := time.Now()
        playerID := order.GetPlayerID()
        if playerID == 0 </span><span class="cov0" title="0">{
                return errors.New("order has no player assigned")
        }</span>
        
        <span class="cov8" title="1">record := &amp;model.CommissionRecord{
                OrderID:            orderID,
                PlayerID:           playerID,
                TotalAmountCents:   calc.TotalAmountCents,
                CommissionRate:     calc.CommissionRate,
                CommissionCents:    calc.CommissionCents,
                PlayerIncomeCents:  calc.PlayerIncomeCents,
                SettlementStatus:   "pending",
                SettlementMonth:    now.Format("2006-01"),
        }

        return s.commissions.CreateRecord(ctx, record)</span>
}

// PlayerMonthStats 玩家月度统计
type PlayerMonthStats struct {
        PlayerID             uint64
        OrderCount           int64
        TotalAmountCents     int64
        TotalCommissionCents int64
        TotalIncomeCents     int64
}

// SettleMonth 月度结算
func (s *CommissionService) SettleMonth(ctx context.Context, month string) error <span class="cov8" title="1">{
        // 1. 检查是否已经结算过
        settlements, _, err := s.commissions.ListSettlements(ctx, commissionrepo.SettlementListOptions{
                SettlementMonth: &amp;month,
                Page:            1,
                PageSize:        1,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(settlements) &gt; 0 </span><span class="cov8" title="1">{
                return ErrAlreadySettled
        }</span>

        // 2. 获取该月所有待结算记录
        <span class="cov8" title="1">status := "pending"
        records, _, err := s.commissions.ListRecords(ctx, commissionrepo.CommissionRecordListOptions{
                SettlementMonth:  &amp;month,
                SettlementStatus: &amp;status,
                Page:             1,
                PageSize:         10000,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(records) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no records to settle for month %s", month)
        }</span>

        // 3. 按陪玩师分组统计
        <span class="cov8" title="1">playerStats := make(map[uint64]*PlayerMonthStats)
        for _, record := range records </span><span class="cov8" title="1">{
                stats, exists := playerStats[record.PlayerID]
                if !exists </span><span class="cov8" title="1">{
                        stats = &amp;PlayerMonthStats{PlayerID: record.PlayerID}
                        playerStats[record.PlayerID] = stats
                }</span>
                <span class="cov8" title="1">stats.OrderCount++
                stats.TotalAmountCents += record.TotalAmountCents
                stats.TotalCommissionCents += record.CommissionCents
                stats.TotalIncomeCents += record.PlayerIncomeCents</span>
        }

        // 4. 为每个陪玩师创建月度结算记录
        <span class="cov8" title="1">for _, stats := range playerStats </span><span class="cov8" title="1">{
                settlement := &amp;model.MonthlySettlement{
                        PlayerID:             stats.PlayerID,
                        SettlementMonth:      month,
                        TotalOrderCount:      stats.OrderCount,
                        TotalAmountCents:     stats.TotalAmountCents,
                        TotalCommissionCents: stats.TotalCommissionCents,
                        TotalIncomeCents:     stats.TotalIncomeCents,
                        BonusCents:           0, // 奖金在排名系统中计算
                        FinalIncomeCents:     stats.TotalIncomeCents,
                        Status:               "pending",
                }

                err := s.commissions.CreateSettlement(ctx, settlement)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create settlement for player %d: %w", stats.PlayerID, err)
                }</span>
        }

        // 5. 更新抽成记录状态
        <span class="cov8" title="1">now := time.Now()
        for _, record := range records </span><span class="cov8" title="1">{
                record.SettlementStatus = "settled"
                record.SettledAt = &amp;now
                if err := s.commissions.UpdateRecord(ctx, &amp;record); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update record %d: %w", record.ID, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetPlayerCommissionSummary 获取玩家抽成汇总
func (s *CommissionService) GetPlayerCommissionSummary(ctx context.Context, playerID uint64, month string) (*CommissionSummaryResponse, error) <span class="cov0" title="0">{
        // 获取月度收入
        income, err := s.commissions.GetPlayerMonthlyIncome(ctx, playerID, month)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 获取抽成记录
        <span class="cov0" title="0">records, total, err := s.commissions.ListRecords(ctx, commissionrepo.CommissionRecordListOptions{
                PlayerID: &amp;playerID,
                Page:     1,
                PageSize: 1,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var totalCommission int64
        var totalIncome int64
        if len(records) &gt; 0 </span><span class="cov0" title="0">{
                // 统计所有抽成记录
        allRecords, _, _ := s.commissions.ListRecords(ctx, commissionrepo.CommissionRecordListOptions{
                        PlayerID: &amp;playerID,
                        Page:     1,
                        PageSize: 10000,
                })
                for _, r := range allRecords </span><span class="cov0" title="0">{
                        totalCommission += r.CommissionCents
                        totalIncome += r.PlayerIncomeCents
                }</span>
        }

        <span class="cov0" title="0">return &amp;CommissionSummaryResponse{
                MonthlyIncome:   income,
                TotalCommission: totalCommission,
                TotalIncome:     totalIncome,
                TotalOrders:     total,
        }, nil</span>
}

// CommissionSummaryResponse 抽成汇总响应
type CommissionSummaryResponse struct {
        MonthlyIncome   int64 `json:"monthlyIncome"`
        TotalCommission int64 `json:"totalCommission"`
        TotalIncome     int64 `json:"totalIncome"`
        TotalOrders     int64 `json:"totalOrders"`
}

// GetCommissionRecords 获取抽成记录列表
func (s *CommissionService) GetCommissionRecords(ctx context.Context, playerID uint64, page, pageSize int) (*CommissionRecordListResponse, error) <span class="cov0" title="0">{
        records, total, err := s.commissions.ListRecords(ctx, commissionrepo.CommissionRecordListOptions{
                PlayerID: &amp;playerID,
                Page:     page,
                PageSize: pageSize,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 转换为DTO
        <span class="cov0" title="0">recordDTOs := make([]CommissionRecordDTO, 0, len(records))
        for _, r := range records </span><span class="cov0" title="0">{
                recordDTOs = append(recordDTOs, CommissionRecordDTO{
                        ID:                 r.ID,
                        OrderID:            r.OrderID,
                        TotalAmountCents:   r.TotalAmountCents,
                        CommissionRate:     r.CommissionRate,
                        CommissionCents:    r.CommissionCents,
                        PlayerIncomeCents:  r.PlayerIncomeCents,
                        SettlementStatus:   r.SettlementStatus,
                        SettlementMonth:    r.SettlementMonth,
                        CreatedAt:          r.CreatedAt,
                })
        }</span>

        <span class="cov0" title="0">return &amp;CommissionRecordListResponse{
                Records: recordDTOs,
                Total:   total,
        }, nil</span>
}

// CommissionRecordDTO 抽成记录DTO
type CommissionRecordDTO struct {
        ID                 uint64    `json:"id"`
        OrderID            uint64    `json:"orderId"`
        TotalAmountCents   int64     `json:"totalAmountCents"`
        CommissionRate     int       `json:"commissionRate"`
        CommissionCents    int64     `json:"commissionCents"`
        PlayerIncomeCents  int64     `json:"playerIncomeCents"`
        SettlementStatus   string    `json:"settlementStatus"`
        SettlementMonth    string    `json:"settlementMonth"`
        CreatedAt          time.Time `json:"createdAt"`
}

// CommissionRecordListResponse 抽成记录列表响应
type CommissionRecordListResponse struct {
        Records []CommissionRecordDTO `json:"records"`
        Total   int64                 `json:"total"`
}

// GetMonthlySettlements 获取月度结算列表
func (s *CommissionService) GetMonthlySettlements(ctx context.Context, playerID uint64, page, pageSize int) (*SettlementListResponse, error) <span class="cov0" title="0">{
        settlements, total, err := s.commissions.ListSettlements(ctx, commissionrepo.SettlementListOptions{
                PlayerID: &amp;playerID,
                Page:     page,
                PageSize: pageSize,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 转换为DTO
        <span class="cov0" title="0">settlementDTOs := make([]SettlementDTO, 0, len(settlements))
        for _, s := range settlements </span><span class="cov0" title="0">{
                settlementDTOs = append(settlementDTOs, SettlementDTO{
                        ID:                   s.ID,
                        SettlementMonth:      s.SettlementMonth,
                        TotalOrderCount:      s.TotalOrderCount,
                        TotalAmountCents:     s.TotalAmountCents,
                        TotalCommissionCents: s.TotalCommissionCents,
                        TotalIncomeCents:     s.TotalIncomeCents,
                        BonusCents:           s.BonusCents,
                        FinalIncomeCents:     s.FinalIncomeCents,
                        Status:               s.Status,
                        CreatedAt:            s.CreatedAt,
                        SettledAt:            s.SettledAt,
                })
        }</span>

        <span class="cov0" title="0">return &amp;SettlementListResponse{
                Settlements: settlementDTOs,
                Total:       total,
        }, nil</span>
}

// SettlementDTO 结算DTO
type SettlementDTO struct {
        ID                   uint64     `json:"id"`
        SettlementMonth      string     `json:"settlementMonth"`
        TotalOrderCount      int64      `json:"totalOrderCount"`
        TotalAmountCents     int64      `json:"totalAmountCents"`
        TotalCommissionCents int64      `json:"totalCommissionCents"`
        TotalIncomeCents     int64      `json:"totalIncomeCents"`
        BonusCents           int64      `json:"bonusCents"`
        FinalIncomeCents     int64      `json:"finalIncomeCents"`
        Status               string     `json:"status"`
        CreatedAt            time.Time  `json:"createdAt"`
        SettledAt            *time.Time `json:"settledAt"`
}

// SettlementListResponse 结算列表响应
type SettlementListResponse struct {
        Settlements []SettlementDTO `json:"settlements"`
        Total       int64           `json:"total"`
}

// CreateCommissionRule 创建抽成规则（管理员）
func (s *CommissionService) CreateCommissionRule(ctx context.Context, req CreateCommissionRuleRequest) (*model.CommissionRule, error) <span class="cov8" title="1">{
        // 验证抽成比例
        if req.Rate &lt; 0 || req.Rate &gt; 100 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("commission rate must be between 0 and 100")
        }</span>

        <span class="cov8" title="1">rule := &amp;model.CommissionRule{
                Name:        req.Name,
                Description: req.Description,
                Type:        req.Type,
                Rate:        req.Rate,
                IsActive:    true,
                GameID:      req.GameID,
                PlayerID:    req.PlayerID,
                ServiceType: req.ServiceType,
        }

        if err := s.commissions.CreateRule(ctx, rule); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return rule, nil</span>
}

// CreateCommissionRuleRequest 创建抽成规则请求
type CreateCommissionRuleRequest struct {
        Name        string  `json:"name" binding:"required,max=128"`
        Description string  `json:"description"`
        Type        string  `json:"type" binding:"required,oneof=default special gift"`
        Rate        int     `json:"rate" binding:"required,min=0,max=100"`
        GameID      *uint64 `json:"gameId"`
        PlayerID    *uint64 `json:"playerId"`
        ServiceType *string `json:"serviceType"`
}

// UpdateCommissionRule 更新抽成规则（管理员）
func (s *CommissionService) UpdateCommissionRule(ctx context.Context, id uint64, req UpdateCommissionRuleRequest) error <span class="cov0" title="0">{
        rule, err := s.commissions.GetRule(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if req.Name != nil </span><span class="cov0" title="0">{
                rule.Name = *req.Name
        }</span>
        <span class="cov0" title="0">if req.Description != nil </span><span class="cov0" title="0">{
                rule.Description = *req.Description
        }</span>
        <span class="cov0" title="0">if req.Rate != nil </span><span class="cov0" title="0">{
                if *req.Rate &lt; 0 || *req.Rate &gt; 100 </span><span class="cov0" title="0">{
                        return fmt.Errorf("commission rate must be between 0 and 100")
                }</span>
                <span class="cov0" title="0">rule.Rate = *req.Rate</span>
        }
        <span class="cov0" title="0">if req.IsActive != nil </span><span class="cov0" title="0">{
                rule.IsActive = *req.IsActive
        }</span>

        <span class="cov0" title="0">return s.commissions.UpdateRule(ctx, rule)</span>
}

// UpdateCommissionRuleRequest 更新抽成规则请求
type UpdateCommissionRuleRequest struct {
        Name        *string `json:"name"`
        Description *string `json:"description"`
        Rate        *int    `json:"rate"`
        IsActive    *bool   `json:"isActive"`
}

// GetPlatformStats 获取平台统计（管理员）
func (s *CommissionService) GetPlatformStats(ctx context.Context, month string) (*PlatformStatsResponse, error) <span class="cov0" title="0">{
        stats, err := s.commissions.GetMonthlyStats(ctx, month)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;PlatformStatsResponse{
                Month:             month,
                TotalOrders:       stats.TotalOrders,
                TotalIncome:       stats.TotalIncome,
                TotalCommission:   stats.TotalCommission,
                TotalPlayerIncome: stats.TotalPlayerIncome,
        }, nil</span>
}

// PlatformStatsResponse 平台统计响应
type PlatformStatsResponse struct {
        Month             string `json:"month"`
        TotalOrders       int64  `json:"totalOrders"`
        TotalIncome       int64  `json:"totalIncome"`
        TotalCommission   int64  `json:"totalCommission"`
        TotalPlayerIncome int64  `json:"totalPlayerIncome"`
}

// ============================================================================
// 三层抽成计算逻辑
// ============================================================================

// CalculateOrderCommission 计算订单的实际抽成（三层取最低）
//
// 抽成来源：
// 1. 服务项目抽成 (service_items.commission_rate)
// 2. 陪玩师专属抽成 (commission_rules WHERE player_id = ?)
// 3. 排名抽成 (基于上月排名，前N名享受优惠)
//
// 实际抽成 = MIN(服务项目抽成, 陪玩师抽成, 排名抽成)
//
// 注意：礼物订单不参与排名优惠
func (s *CommissionService) CalculateOrderCommission(ctx context.Context, order *model.Order) (*CommissionCalculation, error) <span class="cov8" title="1">{
        var candidateRates []CommissionCandidate

        // 1. 获取服务项目抽成（基础抽成）
        serviceItem, err := s.getServiceItemForOrder(ctx, order.ItemID)
        if err == nil &amp;&amp; serviceItem != nil </span><span class="cov0" title="0">{
                candidateRates = append(candidateRates, CommissionCandidate{
                        Source: "服务项目",
                        Rate:   int(serviceItem.CommissionRate * 100),
                        Detail: serviceItem.Name,
                })
        }</span>

        // 2. 查找陪玩师专属抽成规则
        <span class="cov8" title="1">playerID := order.GetPlayerID()
        if playerID &gt; 0 </span><span class="cov8" title="1">{
                playerRule, err := s.commissions.GetRuleForOrder(ctx, order.GameID, order.PlayerID, nil)
                if err == nil &amp;&amp; playerRule != nil </span><span class="cov8" title="1">{
                        candidateRates = append(candidateRates, CommissionCandidate{
                                Source: "陪玩师专属",
                                Rate:   playerRule.Rate,
                                Detail: playerRule.Name,
                        })
                }</span>
        }

        // 3. 查找排名抽成（基于上月排名）
        // 注意：礼物订单不参与排名优惠
        <span class="cov8" title="1">if !order.IsGiftOrder() &amp;&amp; playerID &gt; 0 </span><span class="cov8" title="1">{
                rankingRate, rankingDetail := s.getRankingCommissionRate(ctx, playerID)
                if rankingRate &gt; 0 &amp;&amp; rankingRate &lt; 100 </span><span class="cov0" title="0">{
                        candidateRates = append(candidateRates, CommissionCandidate{
                                Source: "排名优惠",
                                Rate:   rankingRate,
                                Detail: rankingDetail,
                        })
                }</span>
        }

        // 如果没有任何规则，使用默认20%
        <span class="cov8" title="1">if len(candidateRates) == 0 </span><span class="cov8" title="1">{
                defaultRule, err := s.commissions.GetDefaultRule(ctx)
                defaultRate := 20 // 默认20%
                defaultDetail := "平台默认20%抽成"
                
                if err == nil &amp;&amp; defaultRule != nil </span><span class="cov8" title="1">{
                        defaultRate = defaultRule.Rate
                        defaultDetail = defaultRule.Name
                }</span>
                
                <span class="cov8" title="1">candidateRates = append(candidateRates, CommissionCandidate{
                        Source: "默认规则",
                        Rate:   defaultRate,
                        Detail: defaultDetail,
                })</span>
        }

        // 取最低抽成比例
        <span class="cov8" title="1">finalRate := selectLowestRate(candidateRates)
        totalAmount := order.TotalPriceCents
        commissionCents := totalAmount * int64(finalRate.Rate) / 100
        playerIncome := totalAmount - commissionCents

        return &amp;CommissionCalculation{
                OrderID:           order.ID,
                TotalAmountCents:  totalAmount,
                CommissionRate:    finalRate.Rate,
                CommissionCents:   commissionCents,
                PlayerIncomeCents: playerIncome,
                AppliedRule:       finalRate.Source,
                AppliedRuleDetail: finalRate.Detail,
                CandidateRates:    candidateRates,
        }, nil</span>
}

// CommissionCandidate 抽成候选项
type CommissionCandidate struct {
        Source string `json:"source"` // 来源：服务项目/陪玩师专属/排名优惠/默认规则
        Rate   int    `json:"rate"`   // 抽成比例
        Detail string `json:"detail"` // 详细说明
}

// CommissionCalculation 抽成计算结果
type CommissionCalculation struct {
        OrderID           uint64                `json:"orderId"`
        TotalAmountCents  int64                 `json:"totalAmountCents"`
        CommissionRate    int                   `json:"commissionRate"`    // 实际使用的抽成比例
        CommissionCents   int64                 `json:"commissionCents"`   // 平台抽成
        PlayerIncomeCents int64                 `json:"playerIncomeCents"` // 陪玩师收入
        AppliedRule       string                `json:"appliedRule"`       // 实际应用的规则
        AppliedRuleDetail string                `json:"appliedRuleDetail"` // 规则详情
        CandidateRates    []CommissionCandidate `json:"candidateRates"`    // 所有候选抽成
}

// getRankingCommissionRate 获取陪玩师的排名抽成比例
func (s *CommissionService) getRankingCommissionRate(ctx context.Context, playerID uint64) (int, string) <span class="cov8" title="1">{
        // TODO: 查询陪玩师上月排名
        // 1. 获取上月（例如：当前是2月，查询11月的排名）
        // lastMonth := time.Now().AddDate(0, -1, 0).Format("2006-01")

        // 2. 查询该陪玩师在上月的排名
        // rankings, err := s.rankings.GetPlayerRankings(ctx, playerID, lastMonth)

        // 3. 查找对应的排名抽成配置
        // for _, ranking := range rankings {
        //     config := s.findRankingCommissionConfig(ctx, ranking.RankingType, lastMonth)
        //     if config != nil {
        //         // 解析JSON规则
        //         var rules []model.RankingCommissionRule
        //         json.Unmarshal([]byte(config.RulesJSON), &amp;rules)
        //
        //         // 查找该排名对应的抽成
        //         for _, rule := range rules {
        //             if ranking.Rank &gt;= rule.RankStart &amp;&amp; ranking.Rank &lt;= rule.RankEnd {
        //                 return rule.CommissionRate, fmt.Sprintf("%s第%d名", config.Name, ranking.Rank)
        //             }
        //         }
        //     }
        // }

    return 0, "" // 暂时返回0，等待排名系统完整实现
}</span>

// getServiceItemForOrder 获取订单的服务项
func (s *CommissionService) getServiceItemForOrder(ctx context.Context, itemID uint64) (*model.ServiceItem, error) <span class="cov8" title="1">{
        // TODO: 需要注入 ServiceItemRepository
        // return s.serviceItems.Get(ctx, itemID)
        return nil, nil // 暂时返回nil
}</span>

// selectLowestRate 选择最低抽成比例
func selectLowestRate(candidates []CommissionCandidate) CommissionCandidate <span class="cov8" title="1">{
        if len(candidates) == 0 </span><span class="cov0" title="0">{
                return CommissionCandidate{
                        Source: "默认规则",
                        Rate:   20,
                        Detail: "平台默认20%抽成",
                }
        }</span>

        <span class="cov8" title="1">lowest := candidates[0]
        for _, candidate := range candidates[1:] </span><span class="cov0" title="0">{
                if candidate.Rate &lt; lowest.Rate </span><span class="cov0" title="0">{
                        lowest = candidate
                }</span>
        }

        <span class="cov8" title="1">return lowest</span>
}

// ParseRankingCommissionRules 解析排名抽成规则JSON
func ParseRankingCommissionRules(rulesJSON string) ([]model.RankingCommissionRule, error) <span class="cov0" title="0">{
        var rules []model.RankingCommissionRule
        if err := json.Unmarshal([]byte(rulesJSON), &amp;rules); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return rules, nil</span>
}

// FindCommissionRateForRank 根据排名查找对应的抽成比例
func FindCommissionRateForRank(rules []model.RankingCommissionRule, rank int) int <span class="cov0" title="0">{
        for _, rule := range rules </span><span class="cov0" title="0">{
                if rank &gt;= rule.RankStart &amp;&amp; rank &lt;= rule.RankEnd </span><span class="cov0" title="0">{
                        return rule.CommissionRate
                }</span>
        }
    <span class="cov0" title="0">return 0</span> // 不在任何规则范围内
}

// ValidateRankingRules 验证排名规则的合法性
func ValidateRankingRules(rules []model.RankingCommissionRule) error <span class="cov0" title="0">{
        for _, rule := range rules </span><span class="cov0" title="0">{
                if rule.RankStart &lt; 1 || rule.RankEnd &lt; rule.RankStart </span><span class="cov0" title="0">{
                        return ErrValidation
                }</span>
                <span class="cov0" title="0">if rule.CommissionRate &lt; 0 || rule.CommissionRate &gt; 100 </span><span class="cov0" title="0">{
                        return ErrValidation
                }</span>
        }

        // 检查是否有重叠
        <span class="cov0" title="0">for i := 0; i &lt; len(rules); i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(rules); j++ </span><span class="cov0" title="0">{
                        if rangesOverlap(rules[i].RankStart, rules[i].RankEnd, rules[j].RankStart, rules[j].RankEnd) </span><span class="cov0" title="0">{
                                return ErrValidation
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// rangesOverlap 检查两个范围是否重叠
func rangesOverlap(start1, end1, start2, end2 int) bool <span class="cov0" title="0">{
        return math.Max(float64(start1), float64(start2)) &lt;= math.Min(float64(end1), float64(end2))
}</span>
</pre>
		
		<pre class="file" id="file102" style="display: none">package earnings

import (
        "context"
        "errors"
        "time"

        "gamelink/internal/model"
        "gamelink/internal/repository"
        withdrawrepo "gamelink/internal/repository/withdraw"
)

var (
        // ErrNotFound 记录不存在
        ErrNotFound = repository.ErrNotFound
        // ErrValidation 表示输入校验失败
        ErrValidation = errors.New("validation failed")
        // ErrInsufficientBalance 余额不足
        ErrInsufficientBalance = errors.New("insufficient balance")
        // ErrUnauthorized 无权操作
        ErrUnauthorized = errors.New("unauthorized")
)

// WithdrawStatus 提现状态
type WithdrawStatus string

const (
        // WithdrawPending 待处理
        WithdrawPending WithdrawStatus = "pending"
        // WithdrawApproved 已批准
        WithdrawApproved WithdrawStatus = "approved"
        // WithdrawRejected 已拒绝
        WithdrawRejected WithdrawStatus = "rejected"
        // WithdrawCompleted 已完成
        WithdrawCompleted WithdrawStatus = "completed"
)

// EarningsService 收益服务
//
// 功能：
// 1. 收益概览
// 2. 收益趋势
// 3. 提现管理
type EarningsService struct {
        players   repository.PlayerRepository
        orders    repository.OrderRepository
        withdraws withdrawrepo.WithdrawRepository
}

// NewEarningsService 创建收益服务
func NewEarningsService(
        players repository.PlayerRepository,
        orders repository.OrderRepository,
        withdraws withdrawrepo.WithdrawRepository,
) *EarningsService <span class="cov8" title="1">{
        return &amp;EarningsService{
                players:   players,
                orders:    orders,
                withdraws: withdraws,
        }
}</span>

// EarningsSummaryResponse 收益概览响应
type EarningsSummaryResponse struct {
        TodayEarnings    int64 `json:"todayEarnings"`    // 今日收益（分）
        MonthEarnings    int64 `json:"monthEarnings"`    // 本月收益
        TotalEarnings    int64 `json:"totalEarnings"`    // 累计收益
        AvailableBalance int64 `json:"availableBalance"` // 可提现余额
        PendingBalance   int64 `json:"pendingBalance"`   // 待结算余额
        WithdrawTotal    int64 `json:"withdrawTotal"`    // 累计提现
}

// DailyEarningDTO 每日收益
type DailyEarningDTO struct {
        Date       string `json:"date"`       // YYYY-MM-DD
        Earnings   int64  `json:"earnings"`   // 当日收益
        OrderCount int    `json:"orderCount"` // 订单数
}

// EarningsTrendResponse 收益趋势响应
type EarningsTrendResponse struct {
        Trend []DailyEarningDTO `json:"trend"`
}

// WithdrawRequest 提现请求
type WithdrawRequest struct {
        AmountCents int64  `json:"amountCents" binding:"required,min=10000"` // 最低100元
        Method      string `json:"method" binding:"required,oneof=alipay wechat bank"`
        AccountInfo string `json:"accountInfo" binding:"required"` // 账号信息
}

// WithdrawResponse 提现响应
type WithdrawResponse struct {
        WithdrawID uint64 `json:"withdrawId"`
        Status     string `json:"status"`
}

// WithdrawRecordDTO 提现记录
type WithdrawRecordDTO struct {
        ID          uint64     `json:"id"`
        AmountCents int64      `json:"amountCents"`
        Method      string     `json:"method"`
        Status      string     `json:"status"`
        CreatedAt   time.Time  `json:"createdAt"`
        ProcessedAt *time.Time `json:"processedAt"`
}

// WithdrawHistoryResponse 提现记录响应
type WithdrawHistoryResponse struct {
        Records []WithdrawRecordDTO `json:"records"`
        Total   int64               `json:"total"`
}

// GetEarningsSummary 获取收益概览
func (s *EarningsService) GetEarningsSummary(ctx context.Context, userID uint64) (*EarningsSummaryResponse, error) <span class="cov8" title="1">{
        // 查找陪玩师
        player, err := s.findPlayerByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">playerIDPtr := &amp;player.ID

        // 今日收益
        todayStart := time.Now().Truncate(24 * time.Hour)
        todayEnd := todayStart.Add(24 * time.Hour)
        todayEarnings, err := s.calculateEarnings(ctx, playerIDPtr, &amp;todayStart, &amp;todayEnd)
        if err != nil </span><span class="cov0" title="0">{
                todayEarnings = 0
        }</span>

        // 本月收益
        <span class="cov8" title="1">now := time.Now()
        monthStart := time.Date(now.Year(), now.Month(), 1, 0, 0, 0, 0, now.Location())
        monthEnd := monthStart.AddDate(0, 1, 0)
        monthEarnings, err := s.calculateEarnings(ctx, playerIDPtr, &amp;monthStart, &amp;monthEnd)
        if err != nil </span><span class="cov0" title="0">{
                monthEarnings = 0
        }</span>

        // 累计收益
        <span class="cov8" title="1">totalEarnings, err := s.calculateEarnings(ctx, playerIDPtr, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                totalEarnings = 0
        }</span>

        // 从数据库获取余额信息
        <span class="cov8" title="1">var balance *withdrawrepo.PlayerBalance
        if s.withdraws != nil </span><span class="cov8" title="1">{
                balance, err = s.withdraws.GetPlayerBalance(ctx, player.ID)
        }</span>
        <span class="cov8" title="1">if s.withdraws == nil || err != nil </span><span class="cov8" title="1">{
                // 如果获取失败或withdraws为nil，使用计算值
                // 80%可提现，20%待结算
                availableBalance := totalEarnings * 8 / 10
                pendingBalance := totalEarnings - availableBalance
                balance = &amp;withdrawrepo.PlayerBalance{
                        TotalEarnings:    totalEarnings,
                        WithdrawTotal:    0,
                        PendingWithdraw:  0,
                        AvailableBalance: availableBalance,
                        PendingBalance:   pendingBalance,
                }
        }</span>

        <span class="cov8" title="1">return &amp;EarningsSummaryResponse{
                TodayEarnings:    todayEarnings,
                MonthEarnings:    monthEarnings,
                TotalEarnings:    balance.TotalEarnings,
                AvailableBalance: balance.AvailableBalance,
                PendingBalance:   balance.PendingBalance,
                WithdrawTotal:    balance.WithdrawTotal,
        }, nil</span>
}

// GetEarningsTrend 获取收益趋势
func (s *EarningsService) GetEarningsTrend(ctx context.Context, userID uint64, days int) (*EarningsTrendResponse, error) <span class="cov8" title="1">{
        // 查找陪玩师
        player, err := s.findPlayerByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if days &lt; 7 </span><span class="cov8" title="1">{
                days = 7
        }</span>
        <span class="cov8" title="1">if days &gt; 90 </span><span class="cov8" title="1">{
                days = 90
        }</span>

        <span class="cov8" title="1">playerIDPtr := &amp;player.ID
        trend := make([]DailyEarningDTO, 0, days)

        // 计算每日收益
        now := time.Now()
        for i := days - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                date := now.AddDate(0, 0, -i).Truncate(24 * time.Hour)
                dateEnd := date.Add(24 * time.Hour)

                earnings, err := s.calculateEarnings(ctx, playerIDPtr, &amp;date, &amp;dateEnd)
                if err != nil </span><span class="cov0" title="0">{
                        earnings = 0
                }</span>

                <span class="cov8" title="1">orderCount, err := s.countOrders(ctx, playerIDPtr, &amp;date, &amp;dateEnd)
                if err != nil </span><span class="cov0" title="0">{
                        orderCount = 0
                }</span>

                <span class="cov8" title="1">trend = append(trend, DailyEarningDTO{
                        Date:       date.Format("2006-01-02"),
                        Earnings:   earnings,
                        OrderCount: int(orderCount),
                })</span>
        }

        <span class="cov8" title="1">return &amp;EarningsTrendResponse{
                Trend: trend,
        }, nil</span>
}

// RequestWithdraw 申请提现
func (s *EarningsService) RequestWithdraw(ctx context.Context, userID uint64, req WithdrawRequest) (*WithdrawResponse, error) <span class="cov8" title="1">{
        // 查找陪玩师
        player, err := s.findPlayerByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 获取可提现余额
        <span class="cov8" title="1">summary, err := s.GetEarningsSummary(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 检查余额
        <span class="cov8" title="1">if summary.AvailableBalance &lt; req.AmountCents </span><span class="cov8" title="1">{
                return nil, ErrInsufficientBalance
        }</span>

        // 创建提现记录
        <span class="cov8" title="1">withdraw := &amp;model.Withdraw{
                PlayerID:    player.ID,
                UserID:      userID,
                AmountCents: req.AmountCents,
                Method:      model.WithdrawMethod(req.Method),
                AccountInfo: req.AccountInfo, // TODO: 需要加密存储敏感信息
                Status:      model.WithdrawStatusPending,
        }

        if err := s.withdraws.Create(ctx, withdraw); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;WithdrawResponse{
                WithdrawID: withdraw.ID,
                Status:     string(withdraw.Status),
        }, nil</span>
}

// GetWithdrawHistory 获取提现记录
func (s *EarningsService) GetWithdrawHistory(ctx context.Context, userID uint64, page, pageSize int) (*WithdrawHistoryResponse, error) <span class="cov8" title="1">{
        // 查找陪玩师
        player, err := s.findPlayerByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 默认分页参数
        <span class="cov8" title="1">if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov8" title="1">if pageSize &lt; 1 || pageSize &gt; 100 </span><span class="cov0" title="0">{
                pageSize = 20
        }</span>

        // 从数据库获取提现记录
        <span class="cov8" title="1">playerID := player.ID
        withdraws, total, err := s.withdraws.List(ctx, withdrawrepo.WithdrawListOptions{
                PlayerID: &amp;playerID,
                Page:     page,
                PageSize: pageSize,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 转换为DTO
        <span class="cov8" title="1">records := make([]WithdrawRecordDTO, 0, len(withdraws))
        for _, w := range withdraws </span><span class="cov0" title="0">{
                records = append(records, WithdrawRecordDTO{
                        ID:          w.ID,
                        AmountCents: w.AmountCents,
                        Method:      string(w.Method),
                        Status:      string(w.Status),
                        CreatedAt:   w.CreatedAt,
                        ProcessedAt: w.ProcessedAt,
                })
        }</span>

        <span class="cov8" title="1">return &amp;WithdrawHistoryResponse{
                Records: records,
                Total:   total,
        }, nil</span>
}

// calculateEarnings 计算收益
func (s *EarningsService) calculateEarnings(ctx context.Context, playerID *uint64, dateFrom, dateTo *time.Time) (int64, error) <span class="cov8" title="1">{
        // 查询已完成的订单
        orders, _, err := s.orders.List(ctx, repository.OrderListOptions{
                PlayerID: playerID,
                Statuses: []model.OrderStatus{model.OrderStatusCompleted},
                DateFrom: dateFrom,
                DateTo:   dateTo,
                Page:     1,
                PageSize: 10000, // 获取所有订单
        })
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">var total int64
        for _, o := range orders </span><span class="cov8" title="1">{
                total += o.TotalPriceCents
        }</span>

        <span class="cov8" title="1">return total, nil</span>
}

// countOrders 统计订单数
func (s *EarningsService) countOrders(ctx context.Context, playerID *uint64, dateFrom, dateTo *time.Time) (int64, error) <span class="cov8" title="1">{
        _, total, err := s.orders.List(ctx, repository.OrderListOptions{
                PlayerID: playerID,
                Statuses: []model.OrderStatus{model.OrderStatusCompleted},
                DateFrom: dateFrom,
                DateTo:   dateTo,
                Page:     1,
                PageSize: 1,
        })
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return total, nil</span>
}

// findPlayerByUserID 根据用户ID查找陪玩师
func (s *EarningsService) findPlayerByUserID(ctx context.Context, userID uint64) (*model.Player, error) <span class="cov8" title="1">{
        players, _, err := s.players.ListPaged(ctx, 1, 100)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, p := range players </span><span class="cov8" title="1">{
                if p.UserID == userID </span><span class="cov8" title="1">{
                        return &amp;p, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, ErrNotFound</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package gift

import (
        "context"
        "errors"
        "fmt"
        "time"

        "gamelink/internal/model"
        "gamelink/internal/repository"
        commissionrepo "gamelink/internal/repository/commission"
        serviceitemrepo "gamelink/internal/repository/serviceitem"
)

var (
        // ErrNotFound 记录不存�?
        ErrNotFound = repository.ErrNotFound
        // ErrValidation 表示输入校验失败
        ErrValidation = errors.New("validation failed")
        // ErrInvalidGiftItem 无效的礼物项�?
        ErrInvalidGiftItem = errors.New("invalid gift item")
)

// GiftService 礼物服务（基于统一订单系统�?
type GiftService struct {
        items       serviceitemrepo.ServiceItemRepository
        orders      repository.OrderRepository
        players     repository.PlayerRepository
        commissions commissionrepo.CommissionRepository
}

// NewGiftService 创建礼物服务
func NewGiftService(
        items serviceitemrepo.ServiceItemRepository,
        orders repository.OrderRepository,
        players repository.PlayerRepository,
        commissions commissionrepo.CommissionRepository,
) *GiftService <span class="cov8" title="1">{
        return &amp;GiftService{
                items:       items,
                orders:      orders,
                players:     players,
                commissions: commissions,
        }
}</span>

// SendGiftRequest 赠送礼物请�?
type SendGiftRequest struct {
        PlayerID    uint64  `json:"playerId" binding:"required"`              // 接收礼物的陪玩师
        GiftItemID  uint64  `json:"giftItemId" binding:"required"`            // 礼物项目ID
        Quantity    int     `json:"quantity" binding:"required,min=1,max=99"` // 数量
        Message     string  `json:"message" binding:"max=200"`                // 留言
        IsAnonymous bool    `json:"isAnonymous"`                              // 是否匿名
        OrderID     *uint64 `json:"orderId"`                                  // 关联的护航订单（可选）
}

// SendGift 赠送礼�?
func (s *GiftService) SendGift(ctx context.Context, userID uint64, req SendGiftRequest) (*GiftOrderResponse, error) <span class="cov8" title="1">{
        // 1. 验证礼物项目
        giftItem, err := s.items.Get(ctx, req.GiftItemID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // 确保是礼物类�?
        <span class="cov8" title="1">if !giftItem.IsGift() </span><span class="cov8" title="1">{
                return nil, ErrInvalidGiftItem
        }</span>

        // 确保礼物是激活状�?
        <span class="cov8" title="1">if !giftItem.IsActive </span><span class="cov8" title="1">{
                return nil, errors.New("gift item is not active")
        }</span>

        // 2. 验证陪玩�?
        <span class="cov8" title="1">player, err := s.players.Get(ctx, req.PlayerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("player not found: %w", err)
        }</span>

        // 3. 计算价格和抽�?
        <span class="cov8" title="1">platformCommission, playerIncome := giftItem.CalculateCommission(req.Quantity)
        totalPrice := giftItem.BasePriceCents * int64(req.Quantity)

        // 4. 生成订单�?
        orderNo := generateOrderNo("GIFT")

        // 5. 创建礼物订单
        order := &amp;model.Order{
                OrderNo:           orderNo,
                UserID:            userID,
                ItemID:            req.GiftItemID,
                PlayerID:          &amp;req.PlayerID, // 礼物订单的PlayerID就是接收�?
                RecipientPlayerID: &amp;req.PlayerID, // 明确标识接收�?
                Quantity:          req.Quantity,
                UnitPriceCents:    giftItem.BasePriceCents,
                TotalPriceCents:   totalPrice,
                CommissionCents:   platformCommission,
                PlayerIncomeCents: playerIncome,
                Status:            model.OrderStatusPending,
                Title:             fmt.Sprintf("赠送礼物：%s", giftItem.Name),
                Description:       fmt.Sprintf("�?%s 赠�?%s x%d", player.Nickname, giftItem.Name, req.Quantity),
                GiftMessage:       req.Message,
                IsAnonymous:       req.IsAnonymous,
        }

        // 创建订单
        if err := s.orders.Create(ctx, order); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // TODO: 自动完成支付（这里简化，实际需要支付流程）
        // 礼物订单支付后立即送达
        <span class="cov8" title="1">if err := s.deliverGift(ctx, order); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;GiftOrderResponse{
                OrderID:     order.ID,
                OrderNo:     order.OrderNo,
                PlayerID:    req.PlayerID,
                GiftName:    giftItem.Name,
                Quantity:    req.Quantity,
                TotalPrice:  totalPrice,
                Status:      string(order.Status),
                DeliveredAt: order.DeliveredAt,
        }, nil</span>
}

// deliverGift 送达礼物
func (s *GiftService) deliverGift(ctx context.Context, order *model.Order) error <span class="cov8" title="1">{
        // 更新订单状态为已完�?
        now := time.Now()
        order.Status = model.OrderStatusCompleted
        order.DeliveredAt = &amp;now
        order.CompletedAt = &amp;now

        if err := s.orders.Update(ctx, order); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 记录抽成
        <span class="cov8" title="1">record := &amp;model.CommissionRecord{
                OrderID:           order.ID,
                PlayerID:          *order.RecipientPlayerID,
                TotalAmountCents:  order.TotalPriceCents,
                CommissionRate:    int(order.CommissionCents * 100 / order.TotalPriceCents),
                CommissionCents:   order.CommissionCents,
                PlayerIncomeCents: order.PlayerIncomeCents,
                SettlementStatus:  "pending",
                SettlementMonth:   now.Format("2006-01"),
        }

        if err := s.commissions.CreateRecord(ctx, record); err != nil </span>{<span class="cov0" title="0">
                // 记录抽成失败不影响礼物送达
                // TODO: 记录日志
        }</span>

        // TODO: 发送通知给陪玩师

        <span class="cov8" title="1">return nil</span>
}

// GiftOrderResponse 礼物订单响应
type GiftOrderResponse struct {
        OrderID     uint64     `json:"orderId"`
        OrderNo     string     `json:"orderNo"`
        PlayerID    uint64     `json:"playerId"`
        GiftName    string     `json:"giftName"`
        Quantity    int        `json:"quantity"`
        TotalPrice  int64      `json:"totalPrice"`
        Status      string     `json:"status"`
        DeliveredAt *time.Time `json:"deliveredAt"`
}

// GetPlayerReceivedGifts 获取陪玩师收到的礼物
func (s *GiftService) GetPlayerReceivedGifts(ctx context.Context, playerID uint64, page, pageSize int) (*ReceivedGiftsResponse, error) <span class="cov8" title="1">{
        // 查询该陪玩师收到的礼物订�?
        orders, _, err := s.orders.List(ctx, repository.OrderListOptions{
                PlayerID: &amp;playerID,
                Page:     page,
                PageSize: pageSize,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 只返回礼物订�?
        <span class="cov8" title="1">gifts := make([]ReceivedGiftDTO, 0)
        for _, order := range orders </span><span class="cov8" title="1">{
                if order.IsGiftOrder() </span><span class="cov8" title="1">{
                        // 获取礼物项目信息
                        item, err := s.items.Get(ctx, order.ItemID)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">gifts = append(gifts, ReceivedGiftDTO{
                                OrderID:     order.ID,
                                OrderNo:     order.OrderNo,
                                GiftName:    item.Name,
                                GiftIcon:    item.IconURL,
                                Quantity:    order.Quantity,
                                TotalPrice:  order.TotalPriceCents,
                                Income:      order.PlayerIncomeCents,
                                Message:     order.GiftMessage,
                                IsAnonymous: order.IsAnonymous,
                                SenderName:  "", // TODO: 如果不匿名，获取发送者信�?
                                DeliveredAt: order.DeliveredAt,
                                CreatedAt:   order.CreatedAt,
                        })</span>
                }
        }

        <span class="cov8" title="1">return &amp;ReceivedGiftsResponse{
                Gifts: gifts,
                Total: int64(len(gifts)),
        }, nil</span>
}

// ReceivedGiftDTO 收到的礼物DTO
type ReceivedGiftDTO struct {
        OrderID     uint64     `json:"orderId"`
        OrderNo     string     `json:"orderNo"`
        GiftName    string     `json:"giftName"`
        GiftIcon    string     `json:"giftIcon"`
        Quantity    int        `json:"quantity"`
        TotalPrice  int64      `json:"totalPrice"`
        Income      int64      `json:"income"`
        Message     string     `json:"message"`
        IsAnonymous bool       `json:"isAnonymous"`
        SenderName  string     `json:"senderName,omitempty"`
        DeliveredAt *time.Time `json:"deliveredAt"`
        CreatedAt   time.Time  `json:"createdAt"`
}

// ReceivedGiftsResponse 收到的礼物列表响�?
type ReceivedGiftsResponse struct {
        Gifts []ReceivedGiftDTO `json:"gifts"`
        Total int64             `json:"total"`
}

// GetGiftStats 获取陪玩师礼物统�?
func (s *GiftService) GetGiftStats(ctx context.Context, playerID uint64) (*GiftStatsResponse, error) <span class="cov8" title="1">{
        // 查询所有礼物订�?
        playerIDPtr := &amp;playerID
        orders, _, err := s.orders.List(ctx, repository.OrderListOptions{
                PlayerID: playerIDPtr,
                Statuses: []model.OrderStatus{model.OrderStatusCompleted},
                Page:     1,
                PageSize: 10000,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var totalGifts int64
        var totalIncome int64
        var giftCount int64

        for _, order := range orders </span><span class="cov8" title="1">{
                if order.IsGiftOrder() </span><span class="cov8" title="1">{
                        totalGifts += int64(order.Quantity)
                        totalIncome += order.PlayerIncomeCents
                        giftCount++
                }</span>
        }

        <span class="cov8" title="1">return &amp;GiftStatsResponse{
                TotalGiftsReceived: totalGifts,
                TotalGiftIncome:    totalIncome,
                TotalGiftOrders:    giftCount,
        }, nil</span>
}

// GiftStatsResponse 礼物统计响应
type GiftStatsResponse struct {
        TotalGiftsReceived int64 `json:"totalGiftsReceived"` // 收到的礼物总数
        TotalGiftIncome    int64 `json:"totalGiftIncome"`    // 礼物总收入（分）
        TotalGiftOrders    int64 `json:"totalGiftOrders"`    // 礼物订单�?
}

// generateOrderNo 生成订单�?
func generateOrderNo(prefix string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s%d", prefix, time.Now().UnixNano())
}</span>
</pre>
		
		<pre class="file" id="file104" style="display: none">package item

import (
        "context"
        "errors"
        "fmt"
        "time"

        "gamelink/internal/model"
        "gamelink/internal/repository"
        serviceitemrepo "gamelink/internal/repository/serviceitem"
)

var (
        // ErrNotFound 服务项目不存�?
        ErrNotFound = repository.ErrNotFound
        // ErrValidation 表示输入校验失败
        ErrValidation = errors.New("validation failed")
)

// ServiceItemService 服务项目服务（统一管理护航服务和礼物）
type ServiceItemService struct {
        items  serviceitemrepo.ServiceItemRepository
        games  repository.GameRepository
        players repository.PlayerRepository
}

// NewServiceItemService 创建服务项目服务
func NewServiceItemService(
        items serviceitemrepo.ServiceItemRepository,
        games repository.GameRepository,
        players repository.PlayerRepository,
) *ServiceItemService <span class="cov8" title="1">{
        return &amp;ServiceItemService{
                items:  items,
                games:  games,
                players: players,
        }
}</span>

// CreateServiceItemRequest 创建服务项目请求
type CreateServiceItemRequest struct {
        ItemCode        string                         `json:"itemCode" binding:"required,max=32"`
        Name            string                         `json:"name" binding:"required,max=128"`
        Description     string                         `json:"description"`
        SubCategory     model.ServiceItemSubCategory   `json:"subCategory" binding:"required,oneof=solo team gift"`
        GameID          *uint64                        `json:"gameId"`
        PlayerID        *uint64                        `json:"playerId"`
        RankLevel       string                         `json:"rankLevel"`
        BasePriceCents  int64                          `json:"basePriceCents" binding:"required,min=0"`
        ServiceHours    int                            `json:"serviceHours" binding:"min=0"`
        CommissionRate  float64                        `json:"commissionRate" binding:"required,min=0,max=1"`
        MinUsers        int                            `json:"minUsers" binding:"min=1"`
        MaxPlayers      int                            `json:"maxPlayers" binding:"min=1"`
        Tags            string                         `json:"tags"`
        IconURL         string                         `json:"iconUrl"`
        SortOrder       int                            `json:"sortOrder"`
}

// CreateServiceItem 创建服务项目
func (s *ServiceItemService) CreateServiceItem(ctx context.Context, req CreateServiceItemRequest) (*model.ServiceItem, error) <span class="cov8" title="1">{
        // 验证游戏ID（如果提供）
        if req.GameID != nil </span><span class="cov8" title="1">{
                _, err := s.games.Get(ctx, *req.GameID)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid game_id: %w", err)
                }</span>
        }

        // 验证陪玩师ID（如果提供）
        <span class="cov8" title="1">if req.PlayerID != nil </span><span class="cov0" title="0">{
                _, err := s.players.Get(ctx, *req.PlayerID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid player_id: %w", err)
                }</span>
        }

        // 验证礼物的service_hours必须�?
        <span class="cov8" title="1">if req.SubCategory == model.SubCategoryGift &amp;&amp; req.ServiceHours != 0 </span><span class="cov8" title="1">{
                return nil, errors.New("gift items must have service_hours = 0")
        }</span>

        <span class="cov8" title="1">item := &amp;model.ServiceItem{
                ItemCode:       req.ItemCode,
                Name:           req.Name,
                Description:    req.Description,
                Category:       "escort", // 统一�?escort
                SubCategory:    req.SubCategory,
                GameID:         req.GameID,
                PlayerID:       req.PlayerID,
                RankLevel:      req.RankLevel,
                BasePriceCents: req.BasePriceCents,
                ServiceHours:   req.ServiceHours,
                CommissionRate: req.CommissionRate,
                MinUsers:       req.MinUsers,
                MaxPlayers:     req.MaxPlayers,
                Tags:           req.Tags,
                IconURL:        req.IconURL,
                IsActive:       true,
                SortOrder:      req.SortOrder,
        }

        if err := s.items.Create(ctx, item); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return item, nil</span>
}

// UpdateServiceItemRequest 更新服务项目请求
type UpdateServiceItemRequest struct {
        Name           *string  `json:"name"`
        Description    *string  `json:"description"`
        BasePriceCents *int64   `json:"basePriceCents"`
        ServiceHours   *int     `json:"serviceHours"`
        CommissionRate *float64 `json:"commissionRate"`
        RankLevel      *string  `json:"rankLevel"`
        Tags           *string  `json:"tags"`
        IconURL        *string  `json:"iconUrl"`
        IsActive       *bool    `json:"isActive"`
        SortOrder      *int     `json:"sortOrder"`
}

// UpdateServiceItem 更新服务项目
func (s *ServiceItemService) UpdateServiceItem(ctx context.Context, id uint64, req UpdateServiceItemRequest) error <span class="cov8" title="1">{
        item, err := s.items.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 更新字段
        <span class="cov8" title="1">if req.Name != nil </span><span class="cov8" title="1">{
                item.Name = *req.Name
        }</span>
        <span class="cov8" title="1">if req.Description != nil </span><span class="cov0" title="0">{
                item.Description = *req.Description
        }</span>
        <span class="cov8" title="1">if req.BasePriceCents != nil </span><span class="cov8" title="1">{
                if *req.BasePriceCents &lt; 0 </span><span class="cov0" title="0">{
                        return errors.New("base price must be &gt;= 0")
                }</span>
                <span class="cov8" title="1">item.BasePriceCents = *req.BasePriceCents</span>
        }
        <span class="cov8" title="1">if req.ServiceHours != nil </span><span class="cov0" title="0">{
                // 礼物的service_hours必须�?
                if item.IsGift() &amp;&amp; *req.ServiceHours != 0 </span><span class="cov0" title="0">{
                        return errors.New("gift items must have service_hours = 0")
                }</span>
                <span class="cov0" title="0">item.ServiceHours = *req.ServiceHours</span>
        }
        <span class="cov8" title="1">if req.CommissionRate != nil </span><span class="cov0" title="0">{
                if *req.CommissionRate &lt; 0 || *req.CommissionRate &gt; 1 </span><span class="cov0" title="0">{
                        return errors.New("commission rate must be between 0 and 1")
                }</span>
                <span class="cov0" title="0">item.CommissionRate = *req.CommissionRate</span>
        }
        <span class="cov8" title="1">if req.RankLevel != nil </span><span class="cov0" title="0">{
                item.RankLevel = *req.RankLevel
        }</span>
        <span class="cov8" title="1">if req.Tags != nil </span><span class="cov0" title="0">{
                item.Tags = *req.Tags
        }</span>
        <span class="cov8" title="1">if req.IconURL != nil </span><span class="cov0" title="0">{
                item.IconURL = *req.IconURL
        }</span>
        <span class="cov8" title="1">if req.IsActive != nil </span><span class="cov0" title="0">{
                item.IsActive = *req.IsActive
        }</span>
        <span class="cov8" title="1">if req.SortOrder != nil </span><span class="cov0" title="0">{
                item.SortOrder = *req.SortOrder
        }</span>

        <span class="cov8" title="1">return s.items.Update(ctx, item)</span>
}

// DeleteServiceItem 删除服务项目
func (s *ServiceItemService) DeleteServiceItem(ctx context.Context, id uint64) error <span class="cov8" title="1">{
        _, err := s.items.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return s.items.Delete(ctx, id)</span>
}

// ServiceItemDTO 服务项目DTO
type ServiceItemDTO struct {
        ID             uint64    `json:"id"`
        ItemCode       string    `json:"itemCode"`
        Name           string    `json:"name"`
        Description    string    `json:"description"`
        Category       string    `json:"category"`
        SubCategory    string    `json:"subCategory"`
        GameID         *uint64   `json:"gameId"`
        GameName       string    `json:"gameName,omitempty"`
        PlayerID       *uint64   `json:"playerId"`
        PlayerNickname string    `json:"playerNickname,omitempty"`
        RankLevel      string    `json:"rankLevel"`
        BasePriceCents int64     `json:"basePriceCents"`
        ServiceHours   int       `json:"serviceHours"`
        CommissionRate float64   `json:"commissionRate"`
        MinUsers       int       `json:"minUsers"`
        MaxPlayers     int       `json:"maxPlayers"`
        Tags           string    `json:"tags"`
        IconURL        string    `json:"iconUrl"`
        IsActive       bool      `json:"isActive"`
        SortOrder      int       `json:"sortOrder"`
        CreatedAt      time.Time `json:"createdAt"`
        UpdatedAt      time.Time `json:"updatedAt"`
}

// GetServiceItem 获取服务项目详情
func (s *ServiceItemService) GetServiceItem(ctx context.Context, id uint64) (*ServiceItemDTO, error) <span class="cov8" title="1">{
        item, err := s.items.Get(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return s.toDTO(ctx, item), nil</span>
}

// ListServiceItems 获取服务项目列表
func (s *ServiceItemService) ListServiceItems(ctx context.Context, req ListServiceItemsRequest) (*ServiceItemListResponse, error) <span class="cov8" title="1">{
        items, total, err := s.items.List(ctx, serviceitemrepo.ServiceItemListOptions{
                Category:    req.Category,
                SubCategory: req.SubCategory,
                GameID:      req.GameID,
                PlayerID:    req.PlayerID,
                IsActive:    req.IsActive,
                Page:        req.Page,
                PageSize:    req.PageSize,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 转换为DTO
        <span class="cov8" title="1">itemDTOs := make([]ServiceItemDTO, 0, len(items))
        for _, item := range items </span><span class="cov8" title="1">{
                itemDTOs = append(itemDTOs, *s.toDTO(ctx, &amp;item))
        }</span>

        <span class="cov8" title="1">return &amp;ServiceItemListResponse{
                Items: itemDTOs,
                Total: total,
        }, nil</span>
}

// ListServiceItemsRequest 服务项目列表请求
type ListServiceItemsRequest struct {
        Category    *string                        `form:"category"`
        SubCategory *model.ServiceItemSubCategory  `form:"subCategory"`
        GameID      *uint64                        `form:"gameId"`
        PlayerID    *uint64                        `form:"playerId"`
        IsActive    *bool                          `form:"isActive"`
        Page        int                            `form:"page"`
        PageSize    int                            `form:"pageSize"`
}

// ServiceItemListResponse 服务项目列表响应
type ServiceItemListResponse struct {
        Items []ServiceItemDTO `json:"items"`
        Total int64            `json:"total"`
}

// GetGiftList 获取礼物列表（用户端�?
func (s *ServiceItemService) GetGiftList(ctx context.Context, page, pageSize int) (*ServiceItemListResponse, error) <span class="cov8" title="1">{
        items, total, err := s.items.GetGifts(ctx, page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 转换为DTO
        <span class="cov8" title="1">itemDTOs := make([]ServiceItemDTO, 0, len(items))
        for _, item := range items </span><span class="cov8" title="1">{
                itemDTOs = append(itemDTOs, *s.toDTO(ctx, &amp;item))
        }</span>

        <span class="cov8" title="1">return &amp;ServiceItemListResponse{
                Items: itemDTOs,
                Total: total,
        }, nil</span>
}

// toDTO 转换为DTO
func (s *ServiceItemService) toDTO(ctx context.Context, item *model.ServiceItem) *ServiceItemDTO <span class="cov8" title="1">{
        dto := &amp;ServiceItemDTO{
                ID:             item.ID,
                ItemCode:       item.ItemCode,
                Name:           item.Name,
                Description:    item.Description,
                Category:       item.Category,
                SubCategory:    string(item.SubCategory),
                GameID:         item.GameID,
                PlayerID:       item.PlayerID,
                RankLevel:      item.RankLevel,
                BasePriceCents: item.BasePriceCents,
                ServiceHours:   item.ServiceHours,
                CommissionRate: item.CommissionRate,
                MinUsers:       item.MinUsers,
                MaxPlayers:     item.MaxPlayers,
                Tags:           item.Tags,
                IconURL:        item.IconURL,
                IsActive:       item.IsActive,
                SortOrder:      item.SortOrder,
                CreatedAt:      item.CreatedAt,
                UpdatedAt:      item.UpdatedAt,
        }

        // 获取游戏名称
        if item.GameID != nil </span><span class="cov0" title="0">{
                game, err := s.games.Get(ctx, *item.GameID)
                if err == nil </span><span class="cov0" title="0">{
                        dto.GameName = game.Name
                }</span>
        }

        // 获取陪玩师昵�?
        <span class="cov8" title="1">if item.PlayerID != nil </span><span class="cov0" title="0">{
                player, err := s.players.Get(ctx, *item.PlayerID)
                if err == nil </span><span class="cov0" title="0">{
                        dto.PlayerNickname = player.Nickname
                }</span>
        }

        <span class="cov8" title="1">return dto</span>
}

// BatchUpdateStatusRequest 批量更新状态请�?
type BatchUpdateStatusRequest struct {
        IDs      []uint64 `json:"ids" binding:"required"`
        IsActive bool     `json:"isActive"`
}

// BatchUpdateStatus 批量更新状�?
func (s *ServiceItemService) BatchUpdateStatus(ctx context.Context, req BatchUpdateStatusRequest) error <span class="cov8" title="1">{
        if len(req.IDs) == 0 </span><span class="cov8" title="1">{
                return errors.New("no item ids provided")
        }</span>
        <span class="cov8" title="1">return s.items.BatchUpdateStatus(ctx, req.IDs, req.IsActive)</span>
}

// BatchUpdatePriceRequest 批量更新价格请求
type BatchUpdatePriceRequest struct {
        IDs            []uint64 `json:"ids" binding:"required"`
        BasePriceCents int64    `json:"basePriceCents" binding:"required,min=0"`
}

// BatchUpdatePrice 批量更新价格
func (s *ServiceItemService) BatchUpdatePrice(ctx context.Context, req BatchUpdatePriceRequest) error <span class="cov8" title="1">{
        if len(req.IDs) == 0 </span><span class="cov0" title="0">{
                return errors.New("no item ids provided")
        }</span>
        <span class="cov8" title="1">return s.items.BatchUpdatePrice(ctx, req.IDs, req.BasePriceCents)</span>
}

</pre>
		
		<pre class="file" id="file105" style="display: none">package order

import (
        "context"
        "errors"
        "time"

        "gamelink/internal/model"
        "gamelink/internal/repository"
        commissionrepo "gamelink/internal/repository/commission"
)

var (
        // ErrNotFound 订单不存在
        ErrNotFound = repository.ErrNotFound
        // ErrValidation 表示输入校验失败
        ErrValidation = errors.New("validation failed")
        // ErrInvalidTransition 订单状态流转不合法
        ErrInvalidTransition = errors.New("invalid order status transition")
        // ErrUnauthorized 无权操作
        ErrUnauthorized = errors.New("unauthorized")
)

// OrderService 订单服务
//
// 功能：
// 1. 用户端订单管理（创建、查询、取消、完成）
// 2. 陪玩师端订单管理（接单、开始、完成）
// 3. 订单状态流转管理
type OrderService struct {
        orders      repository.OrderRepository
        players     repository.PlayerRepository
        users       repository.UserRepository
        games       repository.GameRepository
        payments    repository.PaymentRepository
        reviews     repository.ReviewRepository
        commissions commissionrepo.CommissionRepository
}

// NewOrderService 创建订单服务
func NewOrderService(
        orders repository.OrderRepository,
        players repository.PlayerRepository,
        users repository.UserRepository,
        games repository.GameRepository,
        payments repository.PaymentRepository,
        reviews repository.ReviewRepository,
        commissions commissionrepo.CommissionRepository,
) *OrderService <span class="cov8" title="1">{
        return &amp;OrderService{
                orders:      orders,
                players:     players,
                users:       users,
                games:       games,
                payments:    payments,
                reviews:     reviews,
                commissions: commissions,
        }
}</span>

// CreateOrderRequest 创建订单请求
type CreateOrderRequest struct {
        PlayerID       uint64     `json:"playerId" binding:"required"`
        GameID         uint64     `json:"gameId" binding:"required"`
        ServiceID      *uint64    `json:"serviceId"`           // 可选：关联服务
        Title          string     `json:"title" binding:"required,max=128"`
        Description    string     `json:"description"`
        ScheduledStart *time.Time `json:"scheduledStart" binding:"required"`
        DurationHours  float32    `json:"durationHours" binding:"required,min=0.5,max=24"`
}

// CreateOrderResponse 创建订单响应
type CreateOrderResponse struct {
        OrderID     uint64 `json:"orderId"`
        PriceCents  int64  `json:"priceCents"`
        NeedPayment bool   `json:"needPayment"`
}

// OrderCardDTO 订单卡片信息（列表展示）
type OrderCardDTO struct {
        ID             uint64            `json:"id"`
        Title          string            `json:"title"`
        PlayerNickname string            `json:"playerNickname"`
        PlayerAvatar   string            `json:"playerAvatar"`
        GameName       string            `json:"gameName"`
        Status         model.OrderStatus `json:"status"`
        PriceCents     int64             `json:"priceCents"`
        ScheduledStart *time.Time        `json:"scheduledStart"`
        CreatedAt      time.Time         `json:"createdAt"`
        CanPay         bool              `json:"canPay"`
        CanCancel      bool              `json:"canCancel"`
        CanComplete    bool              `json:"canComplete"`
        CanReview      bool              `json:"canReview"`
}

// OrderDetailDTO 订单详情信息
type OrderDetailDTO struct {
        OrderCardDTO
        Description  string     `json:"description"`
        ScheduledEnd *time.Time `json:"scheduledEnd"`
        StartedAt    *time.Time `json:"startedAt"`
        CompletedAt  *time.Time `json:"completedAt"`
        CancelReason string     `json:"cancelReason"`
        RefundAmount int64      `json:"refundAmount"`
        RefundReason string     `json:"refundReason"`
}

// OrderTimelineDTO 订单时间线
type OrderTimelineDTO struct {
        Time    time.Time `json:"time"`
        Status  string    `json:"status"`
        Message string    `json:"message"`
}

// PaymentDTO 支付信息
type PaymentDTO struct {
        ID          uint64              `json:"id"`
        Method      model.PaymentMethod `json:"method"`
        AmountCents int64               `json:"amountCents"`
        Status      model.PaymentStatus `json:"status"`
        PaidAt      *time.Time          `json:"paidAt"`
        CreatedAt   time.Time           `json:"createdAt"`
}

// ReviewDTO 评价信息
type ReviewDTO struct {
        ID        uint64 `json:"id"`
        Rating    int    `json:"rating"`
        Comment   string `json:"comment"`
        CreatedAt string `json:"createdAt"`
}

// PlayerCardDTO 陪玩师卡片信息
type PlayerCardDTO struct {
        ID        uint64 `json:"id"`
        Nickname  string `json:"nickname"`
        AvatarURL string `json:"avatarUrl"`
        Rank      string `json:"rank"`
}

// MyOrderListRequest 我的订单列表请求
type MyOrderListRequest struct {
        Status   string `form:"status"` // pending/confirmed/in_progress/completed/canceled
        Page     int    `form:"page"`
        PageSize int    `form:"pageSize"`
}

// MyOrderListResponse 我的订单列表响应
type MyOrderListResponse struct {
        Orders []OrderCardDTO `json:"orders"`
        Total  int64          `json:"total"`
}

// OrderDetailResponse 订单详情响应
type OrderDetailResponse struct {
        Order    OrderDetailDTO     `json:"order"`
        Player   *PlayerCardDTO     `json:"player"`
        Payment  *PaymentDTO        `json:"payment"`
        Review   *ReviewDTO         `json:"review"`
        Timeline []OrderTimelineDTO `json:"timeline"`
}

// CancelOrderRequest 取消订单请求
type CancelOrderRequest struct {
        Reason string `json:"reason" binding:"required,max=500"`
}

// CompleteOrderRequest 确认完成订单请求
type CompleteOrderRequest struct {
        Confirm bool `json:"confirm"`
}

// CreateOrder 创建订单（用户端）
func (s *OrderService) CreateOrder(ctx context.Context, userID uint64, req CreateOrderRequest) (*CreateOrderResponse, error) <span class="cov8" title="1">{
        // 验证陪玩师
        player, err := s.players.Get(ctx, req.PlayerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 验证游戏
        <span class="cov8" title="1">_, err = s.games.Get(ctx, req.GameID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 从陪玩师时薪计算价格（简化版本）
        // TODO: 后续集成 ServiceItem，从 service_items 表获取价格
        <span class="cov8" title="1">hourlyRate := player.HourlyRateCents
        totalPrice := int64(float32(hourlyRate) * req.DurationHours)

        // 默认抽成20%
        commissionRate := 20
        commissionCents := totalPrice * int64(commissionRate) / 100
        playerIncomeCents := totalPrice - commissionCents

        // 计算结束时间
        scheduledEnd := req.ScheduledStart.Add(time.Duration(req.DurationHours * float32(time.Hour)))

        // 创建订单（使用新的 Order 结构）
        playerID := req.PlayerID
        gameID := req.GameID
        order := &amp;model.Order{
                OrderNo:           model.GenerateEscortOrderNo(),
                UserID:            userID,
                ItemID:            1, // TODO: 需要从 service_items 选择对应的服务项
                PlayerID:          &amp;playerID,
                GameID:            &amp;gameID,
                Quantity:          1,
                UnitPriceCents:    totalPrice,
                TotalPriceCents:   totalPrice,
                CommissionCents:   commissionCents,
                PlayerIncomeCents: playerIncomeCents,
                Currency:          model.CurrencyCNY,
                Status:            model.OrderStatusPending,
                Title:             req.Title,
                Description:       req.Description,
                ScheduledStart:    req.ScheduledStart,
                ScheduledEnd:      &amp;scheduledEnd,
        }

        if err := s.orders.Create(ctx, order); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;CreateOrderResponse{
                OrderID:     order.ID,
                PriceCents:  totalPrice,
                NeedPayment: true,
        }, nil</span>
}

// GetMyOrders 获取我的订单列表（用户端）
func (s *OrderService) GetMyOrders(ctx context.Context, userID uint64, req MyOrderListRequest) (*MyOrderListResponse, error) <span class="cov8" title="1">{
        // 默认分页参数
        if req.Page &lt; 1 </span><span class="cov0" title="0">{
                req.Page = 1
        }</span>
        <span class="cov8" title="1">if req.PageSize &lt; 1 || req.PageSize &gt; 100 </span><span class="cov0" title="0">{
                req.PageSize = 20
        }</span>

        // 构建查询条件
        <span class="cov8" title="1">opts := repository.OrderListOptions{
                UserID:   &amp;userID,
                Page:     req.Page,
                PageSize: req.PageSize,
        }

        // 状态过滤
        if req.Status != "" </span><span class="cov8" title="1">{
                opts.Statuses = []model.OrderStatus{model.OrderStatus(req.Status)}
        }</span>

        // 查询订单
        <span class="cov8" title="1">orders, total, err := s.orders.List(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 转换为 DTO
        <span class="cov8" title="1">orderCards := make([]OrderCardDTO, 0, len(orders))
        for _, o := range orders </span><span class="cov8" title="1">{
                card, err := s.toOrderCardDTO(ctx, &amp;o, userID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">orderCards = append(orderCards, *card)</span>
        }

        <span class="cov8" title="1">return &amp;MyOrderListResponse{
                Orders: orderCards,
                Total:  total,
        }, nil</span>
}

// GetOrderDetail 获取订单详情
func (s *OrderService) GetOrderDetail(ctx context.Context, userID uint64, orderID uint64) (*OrderDetailResponse, error) <span class="cov8" title="1">{
        // 获取订单
        order, err := s.orders.Get(ctx, orderID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // 权限检查：只能查看自己的订单或者自己接的订单
        <span class="cov8" title="1">if order.UserID != userID &amp;&amp; order.GetPlayerID() != userID </span><span class="cov8" title="1">{
                return nil, ErrUnauthorized
        }</span>

        // 获取陪玩师信息
        <span class="cov8" title="1">var playerCard *PlayerCardDTO
        playerID := order.GetPlayerID()
        if playerID &gt; 0 </span><span class="cov8" title="1">{
                player, err := s.players.Get(ctx, playerID)
                if err == nil </span><span class="cov8" title="1">{
                        user, err := s.users.Get(ctx, player.UserID)
                        if err == nil </span><span class="cov8" title="1">{
                                playerCard = &amp;PlayerCardDTO{
                                        ID:        player.ID,
                                        Nickname:  player.Nickname,
                                        AvatarURL: user.AvatarURL,
                                        Rank:      player.Rank,
                                }
                        }</span>
                }
        }

        // 获取支付信息
        <span class="cov8" title="1">var paymentDTO *PaymentDTO
        orderIDPtr := &amp;orderID
        payments, _, err := s.payments.List(ctx, repository.PaymentListOptions{
                OrderID:  orderIDPtr,
                Page:     1,
                PageSize: 1,
        })
        if err == nil &amp;&amp; len(payments) &gt; 0 </span><span class="cov8" title="1">{
                p := payments[0]
                paymentDTO = &amp;PaymentDTO{
                        ID:          p.ID,
                        Method:      p.Method,
                        AmountCents: p.AmountCents,
                        Status:      p.Status,
                        PaidAt:      p.PaidAt,
                        CreatedAt:   p.CreatedAt,
                }
        }</span>

        // 获取评价信息
        <span class="cov8" title="1">var reviewDTO *ReviewDTO
        reviews, _, err := s.reviews.List(ctx, repository.ReviewListOptions{
                OrderID:  orderIDPtr,
                Page:     1,
                PageSize: 1,
        })
        if err == nil &amp;&amp; len(reviews) &gt; 0 </span><span class="cov8" title="1">{
                r := reviews[0]
                reviewDTO = &amp;ReviewDTO{
                        ID:        r.ID,
                        Rating:    int(r.Score),
                        Comment:   r.Content,
                        CreatedAt: r.CreatedAt.Format("2006-01-02 15:04:05"),
                }
        }</span>

        // 构建时间线
        <span class="cov8" title="1">timeline := s.buildOrderTimeline(order)

        // 构建订单详情
        card, err := s.toOrderCardDTO(ctx, order, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">detailDTO := OrderDetailDTO{
                OrderCardDTO: *card,
                Description:  order.Description,
                ScheduledEnd: order.ScheduledEnd,
                StartedAt:    order.StartedAt,
                CompletedAt:  order.CompletedAt,
                CancelReason: order.CancelReason,
                RefundAmount: order.RefundAmountCents,
                RefundReason: order.RefundReason,
        }

        return &amp;OrderDetailResponse{
                Order:    detailDTO,
                Player:   playerCard,
                Payment:  paymentDTO,
                Review:   reviewDTO,
                Timeline: timeline,
        }, nil</span>
}

// CancelOrder 取消订单（用户端）
func (s *OrderService) CancelOrder(ctx context.Context, userID uint64, orderID uint64, req CancelOrderRequest) error <span class="cov8" title="1">{
        // 获取订单
        order, err := s.orders.Get(ctx, orderID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // 权限检查
        <span class="cov8" title="1">if order.UserID != userID </span><span class="cov8" title="1">{
                return ErrUnauthorized
        }</span>

        // 状态检查：只有 pending 或 confirmed 状态可以取消
        <span class="cov8" title="1">if order.Status != model.OrderStatusPending &amp;&amp; order.Status != model.OrderStatusConfirmed </span><span class="cov8" title="1">{
                return ErrInvalidTransition
        }</span>

        // 保存原始状态
        <span class="cov8" title="1">originalStatus := order.Status

        // 更新订单状态
        order.Status = model.OrderStatusCanceled
        order.CancelReason = req.Reason

        // 如果已支付，需要退款
        if originalStatus == model.OrderStatusConfirmed </span><span class="cov8" title="1">{
                // 查找支付记录并执行退款
                orderIDPtr := &amp;orderID
                payments, _, err := s.payments.List(ctx, repository.PaymentListOptions{
                        OrderID:  orderIDPtr,
                        Page:     1,
                        PageSize: 1,
                })
                if err == nil &amp;&amp; len(payments) &gt; 0 </span><span class="cov0" title="0">{
                        payment := payments[0]
                        // 如果支付已完成，执行退款
                        if payment.Status == model.PaymentStatusPaid </span><span class="cov0" title="0">{
                                // 注意：这里直接更新订单状态，实际退款由支付服务的RefundPayment处理
                                now := time.Now()
                                order.RefundAmountCents = order.TotalPriceCents
                                order.RefundReason = "用户取消订单"
                                order.RefundedAt = &amp;now
                                order.Status = model.OrderStatusRefunded
                        }</span>
                }
        }

        <span class="cov8" title="1">return s.orders.Update(ctx, order)</span>
}

// CompleteOrder 确认完成订单（用户端）
func (s *OrderService) CompleteOrder(ctx context.Context, userID uint64, orderID uint64) error <span class="cov8" title="1">{
        // 获取订单
        order, err := s.orders.Get(ctx, orderID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // 权限检查
        <span class="cov8" title="1">if order.UserID != userID </span><span class="cov8" title="1">{
                return ErrUnauthorized
        }</span>

        // 状态检查：只有 in_progress 状态可以完成
        <span class="cov8" title="1">if order.Status != model.OrderStatusInProgress </span><span class="cov8" title="1">{
                return ErrInvalidTransition
        }</span>

        // 更新订单状态
        <span class="cov8" title="1">now := time.Now()
        order.Status = model.OrderStatusCompleted
        order.CompletedAt = &amp;now

        if err := s.orders.Update(ctx, order); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 订单完成后，自动记录抽成
        <span class="cov8" title="1">if err := s.recordCommissionAsync(ctx, orderID); err != nil </span>{<span class="cov0" title="0">
                // 记录日志但不影响订单完成
                // TODO: 使用日志系统
                // log.Printf("Failed to record commission for order %d: %v", orderID, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// recordCommissionAsync 异步记录抽成
func (s *OrderService) recordCommissionAsync(ctx context.Context, orderID uint64) error <span class="cov8" title="1">{
        // 检查是否已记录
        existing, _ := s.commissions.GetRecordByOrderID(ctx, orderID)
        if existing != nil </span><span class="cov0" title="0">{
                return nil // 已记录，跳过
        }</span>

        // 获取订单
        <span class="cov8" title="1">order, err := s.orders.Get(ctx, orderID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 获取抽成规则
        <span class="cov8" title="1">rule, err := s.commissions.GetRuleForOrder(ctx, order.GameID, order.PlayerID, nil)
        if err != nil || rule == nil </span><span class="cov0" title="0">{
                // 使用默认规则
                rule, err = s.commissions.GetDefaultRule(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        rule = &amp;model.CommissionRule{Rate: 20} // 默认20%
                }</span>
        }

        // 计算抽成
        <span class="cov8" title="1">totalAmount := order.TotalPriceCents
        commissionRate := rule.Rate
        commissionAmount := totalAmount * int64(commissionRate) / 100
        playerIncome := totalAmount - commissionAmount

        // 创建抽成记录
        now := time.Now()
        playerID := order.GetPlayerID()
        if playerID == 0 </span><span class="cov0" title="0">{
                return errors.New("order has no player assigned")
        }</span>
        
        <span class="cov8" title="1">record := &amp;model.CommissionRecord{
                OrderID:            orderID,
                PlayerID:           playerID,
                TotalAmountCents:   totalAmount,
                CommissionRate:     commissionRate,
                CommissionCents:    commissionAmount,
                PlayerIncomeCents:  playerIncome,
                SettlementStatus:   "pending",
                SettlementMonth:    now.Format("2006-01"),
        }

        return s.commissions.CreateRecord(ctx, record)</span>
}

// toOrderCardDTO 转换为订单卡�?DTO
func (s *OrderService) toOrderCardDTO(ctx context.Context, order *model.Order, userID uint64) (*OrderCardDTO, error) <span class="cov8" title="1">{
        // 获取陪玩师信息
        var playerNickname, playerAvatar string
        playerID := order.GetPlayerID()
        if playerID &gt; 0 </span><span class="cov8" title="1">{
                player, err := s.players.Get(ctx, playerID)
                if err == nil </span><span class="cov8" title="1">{
                        playerNickname = player.Nickname
                        user, err := s.users.Get(ctx, player.UserID)
                        if err == nil </span><span class="cov8" title="1">{
                                playerAvatar = user.AvatarURL
                        }</span>
                }
        }

        // 获取游戏信息
        <span class="cov8" title="1">var gameName string
        gameID := order.GetGameID()
        if gameID &gt; 0 </span><span class="cov8" title="1">{
                game, err := s.games.Get(ctx, gameID)
                if err == nil </span><span class="cov8" title="1">{
                        gameName = game.Name
                }</span>
        }

        // 判断操作权限
        <span class="cov8" title="1">canPay := order.Status == model.OrderStatusPending &amp;&amp; order.UserID == userID
        canCancel := (order.Status == model.OrderStatusPending || order.Status == model.OrderStatusConfirmed) &amp;&amp; order.UserID == userID
        canComplete := order.Status == model.OrderStatusInProgress &amp;&amp; order.UserID == userID
        canReview := order.Status == model.OrderStatusCompleted &amp;&amp; order.UserID == userID

        // 检查是否已评价
        if canReview </span><span class="cov8" title="1">{
                orderIDPtr := &amp;order.ID
                reviews, _, err := s.reviews.List(ctx, repository.ReviewListOptions{
                        OrderID:  orderIDPtr,
                        Page:     1,
                        PageSize: 1,
                })
                if err == nil &amp;&amp; len(reviews) &gt; 0 </span><span class="cov8" title="1">{
                        canReview = false // 已评价
                }</span>
        }

        <span class="cov8" title="1">return &amp;OrderCardDTO{
                ID:             order.ID,
                Title:          order.Title,
                PlayerNickname: playerNickname,
                PlayerAvatar:   playerAvatar,
                GameName:       gameName,
                Status:         order.Status,
                PriceCents:     order.TotalPriceCents,
                ScheduledStart: order.ScheduledStart,
                CreatedAt:      order.CreatedAt,
                CanPay:         canPay,
                CanCancel:      canCancel,
                CanComplete:    canComplete,
                CanReview:      canReview,
        }, nil</span>
}

// buildOrderTimeline 构建订单时间线
func (s *OrderService) buildOrderTimeline(order *model.Order) []OrderTimelineDTO <span class="cov8" title="1">{
        ctx := context.Background()
        timeline := []OrderTimelineDTO{
                {
                        Time:    order.CreatedAt,
                        Status:  string(model.OrderStatusPending),
                                Message: "订单已创建",
                },
        }

        // 获取支付记录以获取真实的支付时间
        if order.Status != model.OrderStatusPending </span><span class="cov8" title="1">{
                paidTime := order.CreatedAt // 默认使用订单创建时间
                orderIDPtr := &amp;order.ID
                payments, _, err := s.payments.List(ctx, repository.PaymentListOptions{
                        OrderID:  orderIDPtr,
                        Page:     1,
                        PageSize: 1,
                })
                if err == nil &amp;&amp; len(payments) &gt; 0 </span><span class="cov8" title="1">{
                        payment := payments[0]
                        if payment.PaidAt != nil </span><span class="cov8" title="1">{
                                paidTime = *payment.PaidAt
                        }</span>
                }

                <span class="cov8" title="1">timeline = append(timeline, OrderTimelineDTO{
                        Time:    paidTime,
                        Status:  string(model.OrderStatusConfirmed),
                        Message: "订单已支付",
                })</span>
        }

        <span class="cov8" title="1">if order.StartedAt != nil </span><span class="cov8" title="1">{
                timeline = append(timeline, OrderTimelineDTO{
                        Time:    *order.StartedAt,
                        Status:  string(model.OrderStatusInProgress),
                        Message: "订单进行中",
                })
        }</span>

        <span class="cov8" title="1">if order.CompletedAt != nil </span><span class="cov8" title="1">{
                timeline = append(timeline, OrderTimelineDTO{
                        Time:    *order.CompletedAt,
                        Status:  string(model.OrderStatusCompleted),
                        Message: "订单已完成",
                })
        }</span>

        <span class="cov8" title="1">if order.Status == model.OrderStatusCanceled </span><span class="cov0" title="0">{
                timeline = append(timeline, OrderTimelineDTO{
                        Time:    order.UpdatedAt,
                        Status:  string(model.OrderStatusCanceled),
                        Message: "订单已取消： " + order.CancelReason,
                })
        }</span>

        <span class="cov8" title="1">if order.RefundedAt != nil </span><span class="cov0" title="0">{
                timeline = append(timeline, OrderTimelineDTO{
                        Time:    *order.RefundedAt,
                        Status:  string(model.OrderStatusRefunded),
                        Message: "订单已退款",
                })
        }</span>

        <span class="cov8" title="1">return timeline</span>
}

// AvailableOrdersRequest 可接订单列表请求
type AvailableOrdersRequest struct {
        GameID   *uint64 `form:"gameId"`
        Page     int     `form:"page"`
        PageSize int     `form:"pageSize"`
}

// AvailableOrderDTO 可接订单信息
type AvailableOrderDTO struct {
        ID             uint64     `json:"id"`
        Title          string     `json:"title"`
        Description    string     `json:"description"`
        GameName       string     `json:"gameName"`
        UserNickname   string     `json:"userNickname"`
        PriceCents     int64      `json:"priceCents"`
        ScheduledStart *time.Time `json:"scheduledStart"`
        DurationHours  float32    `json:"durationHours"`
        CreatedAt      time.Time  `json:"createdAt"`
}

// GetAvailableOrders 获取可接订单列表（陪玩师端）
func (s *OrderService) GetAvailableOrders(ctx context.Context, req AvailableOrdersRequest) ([]AvailableOrderDTO, int64, error) <span class="cov0" title="0">{
        // 默认分页参数
        if req.Page &lt; 1 </span><span class="cov0" title="0">{
                req.Page = 1
        }</span>
        <span class="cov0" title="0">if req.PageSize &lt; 1 || req.PageSize &gt; 100 </span><span class="cov0" title="0">{
                req.PageSize = 20
        }</span>

        // 构建查询条件：查询已支付但未接单的订单
        <span class="cov0" title="0">opts := repository.OrderListOptions{
                Statuses: []model.OrderStatus{model.OrderStatusConfirmed},
                GameID:   req.GameID,
                Page:     req.Page,
                PageSize: req.PageSize,
        }

        orders, total, err := s.orders.List(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 转换�?DTO
        <span class="cov0" title="0">availableOrders := make([]AvailableOrderDTO, 0, len(orders))
        for _, o := range orders </span><span class="cov0" title="0">{
                // 获取游戏信息
                var gameName string
                gameID := o.GetGameID()
                if gameID &gt; 0 </span><span class="cov0" title="0">{
                        game, err := s.games.Get(ctx, gameID)
                        if err == nil </span><span class="cov0" title="0">{
                                gameName = game.Name
                        }</span>
                }

                // 获取用户信息
                <span class="cov0" title="0">var userNickname string
                if o.UserID &gt; 0 </span><span class="cov0" title="0">{
                        user, err := s.users.Get(ctx, o.UserID)
                        if err == nil </span><span class="cov0" title="0">{
                                userNickname = user.Name
                        }</span>
                }

                // 计算时长
                <span class="cov0" title="0">var durationHours float32
                if o.ScheduledStart != nil &amp;&amp; o.ScheduledEnd != nil </span><span class="cov0" title="0">{
                        duration := o.ScheduledEnd.Sub(*o.ScheduledStart)
                        durationHours = float32(duration.Hours())
                }</span>

                <span class="cov0" title="0">availableOrders = append(availableOrders, AvailableOrderDTO{
                        ID:             o.ID,
                        Title:          o.Title,
                        Description:    o.Description,
                        GameName:       gameName,
                        UserNickname:   userNickname,
                        PriceCents:     o.TotalPriceCents,
                        ScheduledStart: o.ScheduledStart,
                        DurationHours:  durationHours,
                        CreatedAt:      o.CreatedAt,
                })</span>
        }

        <span class="cov0" title="0">return availableOrders, total, nil</span>
}

// AcceptOrder 接单（陪玩师端）
func (s *OrderService) AcceptOrder(ctx context.Context, playerUserID uint64, orderID uint64) error <span class="cov8" title="1">{
        // 查找陪玩师
        players, _, err := s.players.ListPaged(ctx, 1, 100)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var playerID uint64
        for _, p := range players </span><span class="cov8" title="1">{
                if p.UserID == playerUserID </span><span class="cov8" title="1">{
                        playerID = p.ID
                        break</span>
                }
        }

        <span class="cov8" title="1">if playerID == 0 </span><span class="cov0" title="0">{
                return errors.New("player not found")
        }</span>

        // 获取订单
        <span class="cov8" title="1">order, err := s.orders.Get(ctx, orderID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // 状态检查：只有 confirmed 状态可以接单
        <span class="cov8" title="1">if order.Status != model.OrderStatusConfirmed </span><span class="cov8" title="1">{
                return ErrInvalidTransition
        }</span>

        // 接单
        <span class="cov8" title="1">order.SetPlayerID(playerID)
        order.Status = model.OrderStatusInProgress
        now := time.Now()
        order.StartedAt = &amp;now

        return s.orders.Update(ctx, order)</span>
}

// CompleteOrderByPlayer 完成订单（陪玩师端）
func (s *OrderService) CompleteOrderByPlayer(ctx context.Context, playerUserID uint64, orderID uint64) error <span class="cov8" title="1">{
        // 查找陪玩师
        players, _, err := s.players.ListPaged(ctx, 1, 100)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var playerID uint64
        for _, p := range players </span><span class="cov8" title="1">{
                if p.UserID == playerUserID </span><span class="cov8" title="1">{
                        playerID = p.ID
                        break</span>
                }
        }

        <span class="cov8" title="1">if playerID == 0 </span><span class="cov0" title="0">{
                return errors.New("player not found")
        }</span>

        // 获取订单
        <span class="cov8" title="1">order, err := s.orders.Get(ctx, orderID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // 权限检查
        <span class="cov8" title="1">if order.GetPlayerID() != playerID </span><span class="cov8" title="1">{
                return ErrUnauthorized
        }</span>

        // 状态检查：只有 in_progress 状态可以完成
        <span class="cov8" title="1">if order.Status != model.OrderStatusInProgress </span><span class="cov8" title="1">{
                return ErrInvalidTransition
        }</span>

        // 完成订单
        <span class="cov8" title="1">now := time.Now()
        order.Status = model.OrderStatusCompleted
        order.CompletedAt = &amp;now

        if err := s.orders.Update(ctx, order); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 订单完成后，自动记录抽成
        <span class="cov8" title="1">if err := s.recordCommissionAsync(ctx, orderID); err != nil </span>{<span class="cov0" title="0">
                // 记录日志但不影响订单完成
                // TODO: 使用日志系统
                // log.Printf("Failed to record commission for order %d: %v", orderID, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package payment

import (
        "context"
        "errors"
        "fmt"
        "time"

        "gamelink/internal/model"
        "gamelink/internal/repository"
)

var (
        // ErrNotFound 支付记录不存在
        ErrNotFound = repository.ErrNotFound
        // ErrValidation 表示输入校验失败
        ErrValidation = errors.New("validation failed")
        // ErrOrderAlreadyPaid 订单已支付
        ErrOrderAlreadyPaid = errors.New("order already paid")
        // ErrInvalidOrderStatus 订单状态不正确
        ErrInvalidOrderStatus = errors.New("invalid order status")
)

// PaymentService 支付服务
//
// 功能：
// 1. 创建支付
// 2. 查询支付状态
// 3. 取消支付
// 4. 处理支付回调（Mock版本）
type PaymentService struct {
        payments repository.PaymentRepository
        orders   repository.OrderRepository
}

// NewPaymentService 创建支付服务
func NewPaymentService(
        payments repository.PaymentRepository,
        orders repository.OrderRepository,
) *PaymentService <span class="cov8" title="1">{
        return &amp;PaymentService{
                payments: payments,
                orders:   orders,
        }
}</span>

// CreatePaymentRequest 创建支付请求
type CreatePaymentRequest struct {
        OrderID uint64              `json:"orderId" binding:"required"`
        Method  model.PaymentMethod `json:"method" binding:"required,oneof=wechat alipay"`
}

// CreatePaymentResponse 创建支付响应
type CreatePaymentResponse struct {
        PaymentID uint64                 `json:"paymentId"`
        PayInfo   map[string]interface{} `json:"payInfo"` // 支付参数（对接支付SDK）
}

// PaymentStatusResponse 支付状态响应
type PaymentStatusResponse struct {
        PaymentID uint64              `json:"paymentId"`
        OrderID   uint64              `json:"orderId"`
        Status    model.PaymentStatus `json:"status"`
        PaidAt    *time.Time          `json:"paidAt"`
}

// CreatePayment 创建支付
func (s *PaymentService) CreatePayment(ctx context.Context, userID uint64, req CreatePaymentRequest) (*CreatePaymentResponse, error) <span class="cov8" title="1">{
        // 验证订单
        order, err := s.orders.Get(ctx, req.OrderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 权限检查
        <span class="cov8" title="1">if order.UserID != userID </span><span class="cov8" title="1">{
                return nil, errors.New("unauthorized")
        }</span>

        // 状态检查：只有 pending 状态可以支付
        <span class="cov8" title="1">if order.Status != model.OrderStatusPending </span><span class="cov8" title="1">{
                return nil, ErrInvalidOrderStatus
        }</span>

        // 检查是否已有支付记录
        <span class="cov8" title="1">orderIDPtr := &amp;req.OrderID
        existingPayments, _, err := s.payments.List(ctx, repository.PaymentListOptions{
                OrderID:  orderIDPtr,
                Page:     1,
                PageSize: 1,
        })
        if err == nil &amp;&amp; len(existingPayments) &gt; 0 </span><span class="cov0" title="0">{
                // 检查是否已支付
                if existingPayments[0].Status == model.PaymentStatusPaid </span><span class="cov0" title="0">{
                        return nil, ErrOrderAlreadyPaid
                }</span>
        }

        // 创建支付记录
        <span class="cov8" title="1">payment := &amp;model.Payment{
                OrderID:     req.OrderID,
                UserID:      userID,
                Method:      req.Method,
                AmountCents: order.TotalPriceCents,
                Currency:    order.Currency,
                Status:      model.PaymentStatusPending,
        }

        if err := s.payments.Create(ctx, payment); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Mock: 生成支付参数
        <span class="cov8" title="1">payInfo := s.generateMockPayInfo(payment.ID, req.Method, order.TotalPriceCents)

        // Mock: 自动标记为已支付（仅用于测试）
        // 在生产环境中，这里应该等待支付回调
        if err := s.mockPaymentSuccess(ctx, payment.ID, order); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;CreatePaymentResponse{
                PaymentID: payment.ID,
                PayInfo:   payInfo,
        }, nil</span>
}

// GetPaymentStatus 查询支付状态
func (s *PaymentService) GetPaymentStatus(ctx context.Context, paymentID uint64) (*PaymentStatusResponse, error) <span class="cov8" title="1">{
        payment, err := s.payments.Get(ctx, paymentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;PaymentStatusResponse{
                PaymentID: payment.ID,
                OrderID:   payment.OrderID,
                Status:    payment.Status,
                PaidAt:    payment.PaidAt,
        }, nil</span>
}

// CancelPayment 取消支付
func (s *PaymentService) CancelPayment(ctx context.Context, userID uint64, paymentID uint64) error <span class="cov8" title="1">{
        payment, err := s.payments.Get(ctx, paymentID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 权限检查
        <span class="cov8" title="1">if payment.UserID != userID </span><span class="cov0" title="0">{
                return errors.New("unauthorized")
        }</span>

        // 状态检查：只有 pending 状态可以取消
        <span class="cov8" title="1">if payment.Status != model.PaymentStatusPending </span><span class="cov0" title="0">{
                return errors.New("cannot cancel payment")
        }</span>

        // 更新支付状态
        <span class="cov8" title="1">payment.Status = model.PaymentStatusFailed

        return s.payments.Update(ctx, payment)</span>
}

// generateMockPayInfo 生成 Mock 支付参数
func (s *PaymentService) generateMockPayInfo(paymentID uint64, method model.PaymentMethod, amountCents int64) map[string]interface{} <span class="cov8" title="1">{
        payInfo := map[string]interface{}{
                "paymentId":   paymentID,
                "method":      string(method),
                "amountCents": amountCents,
                "currency":    "CNY",
                "timestamp":   time.Now().Unix(),
        }

        // 根据支付方式生成不同的参数
        switch method </span>{
        case model.PaymentMethodWeChat:<span class="cov8" title="1">
                payInfo["prepay_id"] = fmt.Sprintf("wx_mock_%d", paymentID)
                payInfo["code_url"] = fmt.Sprintf("weixin://wxpay/bizpayurl?pr=mock%d", paymentID)</span>
        case model.PaymentMethodAlipay:<span class="cov8" title="1">
                payInfo["trade_no"] = fmt.Sprintf("ali_mock_%d", paymentID)
                payInfo["qr_code"] = fmt.Sprintf("https://qr.alipay.com/mock%d", paymentID)</span>
        }

        <span class="cov8" title="1">return payInfo</span>
}

// mockPaymentSuccess Mock 支付成功（仅用于测试）
func (s *PaymentService) mockPaymentSuccess(ctx context.Context, paymentID uint64, order *model.Order) error <span class="cov8" title="1">{
        // 更新支付状态
        payment, err := s.payments.Get(ctx, paymentID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">now := time.Now()
        payment.Status = model.PaymentStatusPaid
        payment.PaidAt = &amp;now
        payment.ProviderTradeNo = fmt.Sprintf("mock_trade_%d", paymentID)

        if err := s.payments.Update(ctx, payment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 更新订单状态
        <span class="cov8" title="1">order.Status = model.OrderStatusConfirmed
        if err := s.orders.Update(ctx, order); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// HandlePaymentCallback 处理支付回调
//
// 注意：这是一个简化版本，生产环境需要：
// 1. 验证支付提供商签名
// 2. 防止重复回调
// 3. 使用事务确保数据一致性
func (s *PaymentService) HandlePaymentCallback(ctx context.Context, provider string, data map[string]interface{}) error <span class="cov8" title="1">{
        // 获取支付ID
        paymentID, ok := data["payment_id"].(uint64)
        if !ok </span><span class="cov8" title="1">{
                // 尝试从其他字段获取
                if id, ok := data["payment_id"].(float64); ok </span><span class="cov8" title="1">{
                        paymentID = uint64(id)
                }</span> else<span class="cov0" title="0"> {
                        return errors.New("missing payment_id in callback data")
                }</span>
        }

        // 获取支付记录
        <span class="cov8" title="1">payment, err := s.payments.Get(ctx, paymentID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 验证支付状态：只处理待支付的订单
        <span class="cov8" title="1">if payment.Status != model.PaymentStatusPending </span><span class="cov0" title="0">{
                // 已经处理过，返回成功避免重复处理
                return nil
        }</span>

        // 验证支付提供商
        <span class="cov8" title="1">expectedProvider := string(payment.Method)
        if provider != expectedProvider </span><span class="cov0" title="0">{
                return fmt.Errorf("provider mismatch: expected %s, got %s", expectedProvider, provider)
        }</span>

        // 验证金额
        <span class="cov8" title="1">if amountCents, ok := data["amount_cents"].(int64); ok </span><span class="cov8" title="1">{
                if amountCents != payment.AmountCents </span><span class="cov0" title="0">{
                        return fmt.Errorf("amount mismatch: expected %d, got %d", payment.AmountCents, amountCents)
                }</span>
        }

        // 获取订单
        <span class="cov8" title="1">order, err := s.orders.Get(ctx, payment.OrderID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 更新支付状态
        <span class="cov8" title="1">now := time.Now()
        payment.Status = model.PaymentStatusPaid
        payment.PaidAt = &amp;now

        // 设置第三方交易号
        if tradeNo, ok := data["trade_no"].(string); ok </span><span class="cov8" title="1">{
                payment.ProviderTradeNo = tradeNo
        }</span> else<span class="cov0" title="0"> {
                payment.ProviderTradeNo = fmt.Sprintf("%s_%d_%d", provider, paymentID, now.Unix())
        }</span>

        <span class="cov8" title="1">if err := s.payments.Update(ctx, payment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 更新订单状态为已确认
        <span class="cov8" title="1">order.Status = model.OrderStatusConfirmed
        if err := s.orders.Update(ctx, order); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// RefundPayment 退款
//
// 注意：这是一个简化版本，生产环境需要：
// 1. 调用真实的支付提供商退款API
// 2. 处理部分退款
// 3. 处理退款失败重试
func (s *PaymentService) RefundPayment(ctx context.Context, paymentID uint64, reason string) error <span class="cov8" title="1">{
        payment, err := s.payments.Get(ctx, paymentID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 验证支付状态：只有已支付的订单可以退款
        <span class="cov8" title="1">if payment.Status != model.PaymentStatusPaid </span><span class="cov0" title="0">{
                return fmt.Errorf("payment status must be paid, current: %s", payment.Status)
        }</span>

        // TODO: 调用支付提供商退款接口
        // 这里简化处理，直接标记为已退款
        // 生产环境需要根据支付方式调用不同的退款API：
        // switch payment.Method {
        // case model.PaymentMethodWeChat:
        //     err = s.wechatClient.Refund(...)
        // case model.PaymentMethodAlipay:
        //     err = s.alipayClient.Refund(...)
        // }

        // 更新支付状态
        <span class="cov8" title="1">now := time.Now()
        payment.Status = model.PaymentStatusRefunded
        payment.RefundedAt = &amp;now

        if err := s.payments.Update(ctx, payment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 更新订单状态
        <span class="cov8" title="1">order, err := s.orders.Get(ctx, payment.OrderID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">order.Status = model.OrderStatusRefunded
        order.RefundAmountCents = payment.AmountCents
        order.RefundReason = reason
        order.RefundedAt = &amp;now

        return s.orders.Update(ctx, order)</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package permission

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "gamelink/internal/cache"
        "gamelink/internal/model"
        "gamelink/internal/repository"
        "gamelink/internal/service"
)

var (
        ErrValidation = service.ErrValidation
        ErrNotFound   = service.ErrNotFound
)

// PermissionService 提供权限管理的业务逻辑。
type PermissionService struct {
        permissions repository.PermissionRepository
        cache       cache.Cache
}

// NewPermissionService 创建权限服务实例。
func NewPermissionService(permissions repository.PermissionRepository, cache cache.Cache) *PermissionService <span class="cov8" title="1">{
        return &amp;PermissionService{
                permissions: permissions,
                cache:       cache,
        }
}</span>

const (
        cacheKeyPermissions       = "admin:permissions"
        cacheKeyPermissionsByRole = "admin:permissions:role:%d"
        cacheKeyPermissionsByUser = "admin:permissions:user:%d"
        cacheTTLPermissions       = 30 * time.Minute
)

// ListPermissions 获取所有权限列表。
func (s *PermissionService) ListPermissions(ctx context.Context) ([]model.Permission, error) <span class="cov8" title="1">{
        return s.permissions.List(ctx)
}</span>

// ListPermissionsPaged 分页获取权限列表。
func (s *PermissionService) ListPermissionsPaged(ctx context.Context, page, pageSize int) ([]model.Permission, int64, error) <span class="cov8" title="1">{
        if page &lt; 1 </span><span class="cov8" title="1">{
                page = 1
        }</span>
        <span class="cov8" title="1">if pageSize &lt; 1 || pageSize &gt; 100 </span><span class="cov8" title="1">{
                pageSize = 20
        }</span>
        <span class="cov8" title="1">return s.permissions.ListPaged(ctx, page, pageSize)</span>
}

// ListPermissionsByGroup 按分组获取权限。
func (s *PermissionService) ListPermissionsByGroup(ctx context.Context, group string) ([]model.Permission, error) <span class="cov8" title="1">{
        grouped, err := s.permissions.ListByGroup(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return grouped[group], nil</span>
}

// GetPermission 根据ID获取权限。
func (s *PermissionService) GetPermission(ctx context.Context, id uint64) (*model.Permission, error) <span class="cov8" title="1">{
        return s.permissions.Get(ctx, id)
}</span>

// CreatePermission 创建权限。
func (s *PermissionService) CreatePermission(ctx context.Context, permission *model.Permission) error <span class="cov8" title="1">{
        // 校验必填字段
        if permission.Method == "" || permission.Path == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: method and path are required", ErrValidation)
        }</span>

        // 检查 method+path 是否已存在
        <span class="cov8" title="1">existing, err := s.permissions.GetByMethodAndPath(ctx, string(permission.Method), permission.Path)
        if err == nil &amp;&amp; existing != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: permission with method %s and path %s already exists", ErrValidation, permission.Method, permission.Path)
        }</span>

        // 创建权限
        <span class="cov8" title="1">if err := s.permissions.Create(ctx, permission); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 清除缓存
        <span class="cov8" title="1">s.invalidatePermissionCache()
        return nil</span>
}

// UpdatePermission 更新权限。
func (s *PermissionService) UpdatePermission(ctx context.Context, permission *model.Permission) error <span class="cov8" title="1">{
        if permission.ID == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: permission ID is required", ErrValidation)
        }</span>

        <span class="cov8" title="1">if err := s.permissions.Update(ctx, permission); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 清除缓存
        <span class="cov8" title="1">s.invalidatePermissionCache()
        return nil</span>
}

// DeletePermission 删除权限。
func (s *PermissionService) DeletePermission(ctx context.Context, id uint64) error <span class="cov8" title="1">{
        if err := s.permissions.Delete(ctx, id); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 清除缓存
        <span class="cov8" title="1">s.invalidatePermissionCache()
        return nil</span>
}

// UpsertPermission 根据 method+path 存在则更新，不存在则创建。
func (s *PermissionService) UpsertPermission(ctx context.Context, permission *model.Permission) error <span class="cov8" title="1">{
        if err := s.permissions.UpsertByMethodPath(ctx, permission); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 清除缓存
        <span class="cov8" title="1">s.invalidatePermissionCache()
        return nil</span>
}

// ListPermissionsByRoleID 获取指定角色拥有的所有权限。
func (s *PermissionService) ListPermissionsByRoleID(ctx context.Context, roleID uint64) ([]model.Permission, error) <span class="cov8" title="1">{
        cacheKey := fmt.Sprintf(cacheKeyPermissionsByRole, roleID)

        // 尝试从缓存获取
        if value, ok, err := s.cache.Get(ctx, cacheKey); err == nil &amp;&amp; ok </span><span class="cov8" title="1">{
                var permissions []model.Permission
                if err := json.Unmarshal([]byte(value), &amp;permissions); err == nil </span><span class="cov8" title="1">{
                        return permissions, nil
                }</span>
        }

        // 从数据库获取
        <span class="cov8" title="1">permissions, err := s.permissions.ListByRoleID(ctx, roleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 写入缓存
        <span class="cov8" title="1">if data, err := json.Marshal(permissions); err == nil </span><span class="cov8" title="1">{
                _ = s.cache.Set(ctx, cacheKey, string(data), cacheTTLPermissions)
        }</span>
        <span class="cov8" title="1">return permissions, nil</span>
}

// ListPermissionsByUserID 获取指定用户拥有的所有权限（通过角色）。
func (s *PermissionService) ListPermissionsByUserID(ctx context.Context, userID uint64) ([]model.Permission, error) <span class="cov8" title="1">{
        cacheKey := fmt.Sprintf(cacheKeyPermissionsByUser, userID)

        // 尝试从缓存获取
        if value, ok, err := s.cache.Get(ctx, cacheKey); err == nil &amp;&amp; ok </span><span class="cov8" title="1">{
                var permissions []model.Permission
                if err := json.Unmarshal([]byte(value), &amp;permissions); err == nil </span><span class="cov8" title="1">{
                        return permissions, nil
                }</span>
        }

        // 从数据库获取
        <span class="cov8" title="1">permissions, err := s.permissions.ListByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 写入缓存
        <span class="cov8" title="1">if data, err := json.Marshal(permissions); err == nil </span><span class="cov8" title="1">{
                _ = s.cache.Set(ctx, cacheKey, string(data), cacheTTLPermissions)
        }</span>
        <span class="cov8" title="1">return permissions, nil</span>
}

// CheckUserHasPermission 检查用户是否拥有指定权限。
func (s *PermissionService) CheckUserHasPermission(ctx context.Context, userID uint64, method model.HTTPMethod, path string) (bool, error) <span class="cov8" title="1">{
        permissions, err := s.ListPermissionsByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">for _, perm := range permissions </span><span class="cov8" title="1">{
                if perm.Method == method &amp;&amp; perm.Path == path </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }

        <span class="cov8" title="1">return false, nil</span>
}

// ListPermissionGroups 获取所有权限分组列表。
func (s *PermissionService) ListPermissionGroups(ctx context.Context) ([]string, error) <span class="cov8" title="1">{
        return s.permissions.ListGroups(ctx)
}</span>

// invalidatePermissionCache 清除权限相关缓存。
func (s *PermissionService) invalidatePermissionCache() <span class="cov8" title="1">{
        ctx := context.Background()
        _ = s.cache.Delete(ctx, cacheKeyPermissions)
        // 注意：用户和角色的权限缓存需要在分配权限时清除
}</span>

</pre>
		
		<pre class="file" id="file108" style="display: none">package player

import (
        "context"
        "errors"
        "fmt"
        "time"

        "gamelink/internal/cache"
        "gamelink/internal/model"
        "gamelink/internal/repository"
)

var (
        // ErrNotFound 玩家不存在
        ErrNotFound = repository.ErrNotFound
        // ErrValidation 表示输入校验失败
        ErrValidation = errors.New("validation failed")
        // ErrPlayerNotVerified 陪玩师未通过审核
        ErrPlayerNotVerified = errors.New("player not verified")
        // ErrAlreadyPlayer 用户已是陪玩师
        ErrAlreadyPlayer = errors.New("user is already a player")
)

// PlayerService 陪玩师服务
//
// 功能：
// 1. 用户端查询陪玩师列表和详情
// 2. 陪玩师端管理个人资料
// 3. 陪玩师申请和审核
type PlayerService struct {
        players    repository.PlayerRepository
        users      repository.UserRepository
        games      repository.GameRepository
        orders     repository.OrderRepository
        reviews    repository.ReviewRepository
        playerTags repository.PlayerTagRepository
        cache      cache.Cache
}

// NewPlayerService 创建陪玩师服务
func NewPlayerService(
        players repository.PlayerRepository,
        users repository.UserRepository,
        games repository.GameRepository,
        orders repository.OrderRepository,
        reviews repository.ReviewRepository,
        playerTags repository.PlayerTagRepository,
        cache cache.Cache,
) *PlayerService <span class="cov8" title="1">{
        return &amp;PlayerService{
                players:    players,
                users:      users,
                games:      games,
                orders:     orders,
                reviews:    reviews,
                playerTags: playerTags,
                cache:      cache,
        }
}</span>

// PlayerCardDTO 陪玩师卡片信息（列表展示）
type PlayerCardDTO struct {
        ID              uint64  `json:"id"`
        UserID          uint64  `json:"userId"`
        Nickname        string  `json:"nickname"`
        AvatarURL       string  `json:"avatarUrl"`
        Bio             string  `json:"bio"`
        Rank            string  `json:"rank"`
        RatingAverage   float32 `json:"ratingAverage"`
        RatingCount     uint32  `json:"ratingCount"`
        HourlyRateCents int64   `json:"hourlyRateCents"`
        MainGame        string  `json:"mainGame"`   // 游戏名称
        IsOnline        bool    `json:"isOnline"`   // 在线状态
        OrderCount      int64   `json:"orderCount"` // 历史订单数
}

// PlayerDetailDTO 陪玩师详情信息
type PlayerDetailDTO struct {
        PlayerCardDTO
        Tags           []string `json:"tags"`           // 服务标签
        GoodRatio      float32  `json:"goodRatio"`      // 好评率
        AvgResponseMin int      `json:"avgResponseMin"` // 平均响应时间（分钟）
}

// PlayerStatsDTO 陪玩师统计数据
type PlayerStatsDTO struct {
        TotalOrders     int64   `json:"totalOrders"`
        CompletedOrders int64   `json:"completedOrders"`
        RepeatRate      float32 `json:"repeatRate"` // 复购率
}

// PlayerListRequest 陪玩师列表请求
type PlayerListRequest struct {
        GameID     *uint64  `form:"gameId"`     // 游戏筛选
        MinPrice   *int64   `form:"minPrice"`   // 最低价格（分）
        MaxPrice   *int64   `form:"maxPrice"`   // 最高价格（分）
        MinRating  *float32 `form:"minRating"`  // 最低评分
        OnlineOnly bool     `form:"onlineOnly"` // 仅在线
        SortBy     string   `form:"sortBy"`     // 排序：price/rating/orders
        Page       int      `form:"page"`
        PageSize   int      `form:"pageSize"`
}

// PlayerListResponse 陪玩师列表响应
type PlayerListResponse struct {
        Players []PlayerCardDTO `json:"players"`
        Total   int64           `json:"total"`
}

// PlayerDetailResponse 陪玩师详情响应
type PlayerDetailResponse struct {
        Player  PlayerDetailDTO `json:"player"`
        Reviews []ReviewDTO     `json:"reviews"` // 最新评价
        Stats   PlayerStatsDTO  `json:"stats"`
}

// ReviewDTO 评价信息
type ReviewDTO struct {
        ID            uint64 `json:"id"`
        UserNickname  string `json:"userNickname"`
        UserAvatarURL string `json:"userAvatarUrl"`
        Rating        int    `json:"rating"`
        Comment       string `json:"comment"`
        CreatedAt     string `json:"createdAt"`
}

// ApplyPlayerRequest 申请成为陪玩师请求
type ApplyPlayerRequest struct {
        Nickname        string   `json:"nickname" binding:"required,max=64"`
        Bio             string   `json:"bio" binding:"max=500"`
        MainGameID      uint64   `json:"mainGameId" binding:"required"`
        Rank            string   `json:"rank" binding:"required,max=32"`
        HourlyRateCents int64    `json:"hourlyRateCents" binding:"required,min=1000"`
        Tags            []string `json:"tags"`
        ProofImages     []string `json:"proofImages"` // 段位证明图片
}

// ApplyPlayerResponse 申请陪玩师响应
type ApplyPlayerResponse struct {
        PlayerID           uint64                   `json:"playerId"`
        VerificationStatus model.VerificationStatus `json:"verificationStatus"`
}

// UpdatePlayerProfileRequest 更新陪玩师资料请求
type UpdatePlayerProfileRequest struct {
        Nickname        string   `json:"nickname" binding:"required,max=64"`
        Bio             string   `json:"bio" binding:"max=500"`
        Rank            string   `json:"rank"`
        HourlyRateCents int64    `json:"hourlyRateCents" binding:"min=1000"`
        Tags            []string `json:"tags"`
}

// SetPlayerStatusRequest 设置在线状态请求
type SetPlayerStatusRequest struct {
        Online bool `json:"online"`
}

// ListPlayers 获取陪玩师列表（用户端）
func (s *PlayerService) ListPlayers(ctx context.Context, req PlayerListRequest) (*PlayerListResponse, error) <span class="cov8" title="1">{
        // 默认分页参数
        if req.Page &lt; 1 </span><span class="cov0" title="0">{
                req.Page = 1
        }</span>
        <span class="cov8" title="1">if req.PageSize &lt; 1 || req.PageSize &gt; 100 </span><span class="cov0" title="0">{
                req.PageSize = 20
        }</span>

        // 获取所有陪玩师
        <span class="cov8" title="1">players, total, err := s.players.ListPaged(ctx, req.Page, req.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 转换为 DTO
        <span class="cov8" title="1">playerCards := make([]PlayerCardDTO, 0, len(players))
        for _, p := range players </span><span class="cov8" title="1">{
                // 过滤条件
                if req.GameID != nil &amp;&amp; p.MainGameID != *req.GameID </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if req.MinPrice != nil &amp;&amp; p.HourlyRateCents &lt; *req.MinPrice </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if req.MaxPrice != nil &amp;&amp; p.HourlyRateCents &gt; *req.MaxPrice </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if req.MinRating != nil &amp;&amp; p.RatingAverage &lt; *req.MinRating </span><span class="cov0" title="0">{
                        continue</span>
                }
                // 只显示已审核通过的陪玩师
                <span class="cov8" title="1">if p.VerificationStatus != model.VerificationVerified </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 获取用户信息
                <span class="cov8" title="1">user, err := s.users.Get(ctx, p.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 获取游戏信息
                <span class="cov8" title="1">var gameName string
                if p.MainGameID &gt; 0 </span><span class="cov8" title="1">{
                        game, err := s.games.Get(ctx, p.MainGameID)
                        if err == nil </span><span class="cov8" title="1">{
                                gameName = game.Name
                        }</span>
                }

                // 获取订单数
                <span class="cov8" title="1">orderCount, err := s.getPlayerOrderCount(ctx, p.ID)
                if err != nil </span><span class="cov0" title="0">{
                        orderCount = 0
                }</span>

                <span class="cov8" title="1">playerCards = append(playerCards, PlayerCardDTO{
                        ID:              p.ID,
                        UserID:          p.UserID,
                        Nickname:        p.Nickname,
                        AvatarURL:       user.AvatarURL,
                        Bio:             p.Bio,
                        Rank:            p.Rank,
                        RatingAverage:   p.RatingAverage,
                        RatingCount:     p.RatingCount,
                        HourlyRateCents: p.HourlyRateCents,
                        MainGame:        gameName,
                        IsOnline:        s.getPlayerOnlineStatus(ctx, p.ID),
                        OrderCount:      orderCount,
                })</span>
        }

        <span class="cov8" title="1">return &amp;PlayerListResponse{
                Players: playerCards,
                Total:   total,
        }, nil</span>
}

// GetPlayerDetail 获取陪玩师详情（用户端）
func (s *PlayerService) GetPlayerDetail(ctx context.Context, id uint64) (*PlayerDetailResponse, error) <span class="cov8" title="1">{
        // 获取陪玩师信息
        player, err := s.players.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 只显示已审核通过的陪玩师
        <span class="cov8" title="1">if player.VerificationStatus != model.VerificationVerified </span><span class="cov0" title="0">{
                return nil, ErrPlayerNotVerified
        }</span>

        // 获取用户信息
        <span class="cov8" title="1">user, err := s.users.Get(ctx, player.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 获取游戏信息
        <span class="cov8" title="1">var gameName string
        if player.MainGameID &gt; 0 </span><span class="cov8" title="1">{
                game, err := s.games.Get(ctx, player.MainGameID)
                if err == nil </span><span class="cov8" title="1">{
                        gameName = game.Name
                }</span>
        }

        // 获取标签
        <span class="cov8" title="1">tags, err := s.playerTags.GetTags(ctx, player.ID)
        if err != nil </span><span class="cov0" title="0">{
                tags = []string{}
        }</span>

        // 获取订单统计
        <span class="cov8" title="1">stats, err := s.getPlayerStats(ctx, player.ID)
        if err != nil </span><span class="cov0" title="0">{
                stats = PlayerStatsDTO{}
        }</span>

        // 获取评价列表
        <span class="cov8" title="1">reviews, err := s.getPlayerReviews(ctx, player.ID, 5)
        if err != nil </span><span class="cov0" title="0">{
                reviews = []ReviewDTO{}
        }</span>

        // 计算好评率
        <span class="cov8" title="1">goodRatio := s.calculateGoodRatio(ctx, player.ID)

        // 获取订单数
        orderCount, _ := s.getPlayerOrderCount(ctx, player.ID)

        return &amp;PlayerDetailResponse{
                Player: PlayerDetailDTO{
                        PlayerCardDTO: PlayerCardDTO{
                                ID:              player.ID,
                                UserID:          player.UserID,
                                Nickname:        player.Nickname,
                                AvatarURL:       user.AvatarURL,
                                Bio:             player.Bio,
                                Rank:            player.Rank,
                                RatingAverage:   player.RatingAverage,
                                RatingCount:     player.RatingCount,
                                HourlyRateCents: player.HourlyRateCents,
                                MainGame:        gameName,
                                IsOnline:        s.getPlayerOnlineStatus(ctx, player.ID),
                                OrderCount:      orderCount,
                        },
                        Tags:           tags,
                        GoodRatio:      goodRatio,
                        AvgResponseMin: s.calculateAvgResponseTime(ctx, player.ID),
                },
                Reviews: reviews,
                Stats:   stats,
        }, nil</span>
}

// ApplyAsPlayer 申请成为陪玩师
func (s *PlayerService) ApplyAsPlayer(ctx context.Context, userID uint64, req ApplyPlayerRequest) (*ApplyPlayerResponse, error) <span class="cov8" title="1">{
        // 检查用户是否存在
        user, err := s.users.Get(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 检查用户是否已经是陪玩师
        <span class="cov8" title="1">players, _, err := s.players.ListPaged(ctx, 1, 1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, p := range players </span><span class="cov8" title="1">{
                if p.UserID == userID </span><span class="cov0" title="0">{
                        return nil, ErrAlreadyPlayer
                }</span>
        }

        // 验证游戏ID
        <span class="cov8" title="1">if _, err := s.games.Get(ctx, req.MainGameID); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid game id")
        }</span>

        // 创建陪玩师资料
        <span class="cov8" title="1">player := &amp;model.Player{
                UserID:             userID,
                Nickname:           req.Nickname,
                Bio:                req.Bio,
                Rank:               req.Rank,
                HourlyRateCents:    req.HourlyRateCents,
                MainGameID:         req.MainGameID,
                VerificationStatus: model.VerificationPending, // 待审核
        }

        if err := s.players.Create(ctx, player); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 保存标签
        <span class="cov8" title="1">if len(req.Tags) &gt; 0 </span><span class="cov8" title="1">{
                if err := s.playerTags.ReplaceTags(ctx, player.ID, req.Tags); err != nil </span>{<span class="cov0" title="0">
                        // 标签保存失败不影响申请
                }</span>
        }

        // 更新用户角色为 player（可选）
        <span class="cov8" title="1">user.Role = model.RolePlayer
        _ = s.users.Update(ctx, user)

        return &amp;ApplyPlayerResponse{
                PlayerID:           player.ID,
                VerificationStatus: player.VerificationStatus,
        }, nil</span>
}

// GetPlayerProfile 获取陪玩师自己的资料
func (s *PlayerService) GetPlayerProfile(ctx context.Context, userID uint64) (*PlayerDetailResponse, error) <span class="cov8" title="1">{
        // 查找该用户的陪玩师资料
        players, _, err := s.players.ListPaged(ctx, 1, 100)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var player *model.Player
        for _, p := range players </span><span class="cov8" title="1">{
                if p.UserID == userID </span><span class="cov8" title="1">{
                        player = &amp;p
                        break</span>
                }
        }

        <span class="cov8" title="1">if player == nil </span><span class="cov0" title="0">{
                return nil, ErrNotFound
        }</span>

        // 返回详情（不需要检查审核状态，陪玩师可以查看自己的资料）
        <span class="cov8" title="1">return s.GetPlayerDetail(ctx, player.ID)</span>
}

// UpdatePlayerProfile 更新陪玩师资料
func (s *PlayerService) UpdatePlayerProfile(ctx context.Context, userID uint64, req UpdatePlayerProfileRequest) error <span class="cov8" title="1">{
        // 查找该用户的陪玩师资料
        players, _, err := s.players.ListPaged(ctx, 1, 100)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var player *model.Player
        for _, p := range players </span><span class="cov8" title="1">{
                if p.UserID == userID </span><span class="cov8" title="1">{
                        player = &amp;p
                        break</span>
                }
        }

        <span class="cov8" title="1">if player == nil </span><span class="cov0" title="0">{
                return ErrNotFound
        }</span>

        // 更新资料
        <span class="cov8" title="1">player.Nickname = req.Nickname
        player.Bio = req.Bio
        if req.Rank != "" </span><span class="cov0" title="0">{
                player.Rank = req.Rank
        }</span>
        <span class="cov8" title="1">if req.HourlyRateCents &gt; 0 </span><span class="cov8" title="1">{
                player.HourlyRateCents = req.HourlyRateCents
        }</span>

        <span class="cov8" title="1">if err := s.players.Update(ctx, player); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 更新标签
        <span class="cov8" title="1">if len(req.Tags) &gt; 0 </span><span class="cov8" title="1">{
                if err := s.playerTags.ReplaceTags(ctx, player.ID, req.Tags); err != nil </span>{<span class="cov0" title="0">
                        // 标签更新失败不影响资料更新
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// SetPlayerOnlineStatus 设置陪玩师在线状态
func (s *PlayerService) SetPlayerOnlineStatus(ctx context.Context, userID uint64, online bool) error <span class="cov8" title="1">{
        // 查找该用户的陪玩师资料
        players, _, err := s.players.ListPaged(ctx, 1, 100)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var playerID uint64
        for _, p := range players </span><span class="cov8" title="1">{
                if p.UserID == userID </span><span class="cov8" title="1">{
                        playerID = p.ID
                        break</span>
                }
        }

        <span class="cov8" title="1">if playerID == 0 </span><span class="cov0" title="0">{
                return ErrNotFound
        }</span>

        // 使用 Redis 存储在线状态
        <span class="cov8" title="1">key := s.getOnlineStatusKey(playerID)
        if online </span><span class="cov8" title="1">{
                // 设置在线状态，TTL为5分钟（需要客户端定期心跳刷新）
                return s.cache.Set(ctx, key, "1", 5*time.Minute)
        }</span>
        // 删除在线状态
        <span class="cov8" title="1">return s.cache.Delete(ctx, key)</span>
}

// getPlayerOnlineStatus 获取陪玩师在线状态
func (s *PlayerService) getPlayerOnlineStatus(ctx context.Context, playerID uint64) bool <span class="cov8" title="1">{
        key := s.getOnlineStatusKey(playerID)
        _, ok, _ := s.cache.Get(ctx, key)
        return ok
}</span>

// getOnlineStatusKey 获取在线状态的缓存键
func (s *PlayerService) getOnlineStatusKey(playerID uint64) string <span class="cov8" title="1">{
        return fmt.Sprintf("player:online:%d", playerID)
}</span>

// getPlayerOrderCount 获取陪玩师的订单数量
func (s *PlayerService) getPlayerOrderCount(ctx context.Context, playerID uint64) (int64, error) <span class="cov8" title="1">{
        playerIDPtr := &amp;playerID
        orders, total, err := s.orders.List(ctx, repository.OrderListOptions{
                PlayerID: playerIDPtr,
                Page:     1,
                PageSize: 1,
        })
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">_ = orders
        return total, nil</span>
}

// getPlayerStats 获取陪玩师统计数据
func (s *PlayerService) getPlayerStats(ctx context.Context, playerID uint64) (PlayerStatsDTO, error) <span class="cov8" title="1">{
        playerIDPtr := &amp;playerID

        // 总订单数
        _, total, err := s.orders.List(ctx, repository.OrderListOptions{
                PlayerID: playerIDPtr,
                Page:     1,
                PageSize: 1,
        })
        if err != nil </span><span class="cov0" title="0">{
                return PlayerStatsDTO{}, err
        }</span>

        // 已完成订单数
        <span class="cov8" title="1">_, completed, err := s.orders.List(ctx, repository.OrderListOptions{
                PlayerID: playerIDPtr,
                Statuses: []model.OrderStatus{model.OrderStatusCompleted},
                Page:     1,
                PageSize: 1,
        })
        if err != nil </span><span class="cov0" title="0">{
                return PlayerStatsDTO{}, err
        }</span>

        <span class="cov8" title="1">return PlayerStatsDTO{
                TotalOrders:     total,
                CompletedOrders: completed,
                RepeatRate:      s.calculateRepeatRate(ctx, playerID),
        }, nil</span>
}

// getPlayerReviews 获取陪玩师的评价列表
func (s *PlayerService) getPlayerReviews(ctx context.Context, playerID uint64, limit int) ([]ReviewDTO, error) <span class="cov8" title="1">{
        playerIDPtr := &amp;playerID
        reviews, _, err := s.reviews.List(ctx, repository.ReviewListOptions{
                PlayerID: playerIDPtr,
                Page:     1,
                PageSize: limit,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">reviewDTOs := make([]ReviewDTO, 0, len(reviews))
        for _, r := range reviews </span><span class="cov8" title="1">{
                user, err := s.users.Get(ctx, r.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">reviewDTOs = append(reviewDTOs, ReviewDTO{
                        ID:            r.ID,
                        UserNickname:  user.Name,
                        UserAvatarURL: user.AvatarURL,
                        Rating:        int(r.Score),
                        Comment:       r.Content,
                        CreatedAt:     r.CreatedAt.Format("2006-01-02 15:04:05"),
                })</span>
        }

        <span class="cov8" title="1">return reviewDTOs, nil</span>
}

// calculateGoodRatio 计算好评率
func (s *PlayerService) calculateGoodRatio(ctx context.Context, playerID uint64) float32 <span class="cov8" title="1">{
        playerIDPtr := &amp;playerID
        reviews, _, err := s.reviews.List(ctx, repository.ReviewListOptions{
                PlayerID: playerIDPtr,
                Page:     1,
                PageSize: 1000,
        })
        if err != nil || len(reviews) == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>

        <span class="cov8" title="1">goodCount := 0
        for _, r := range reviews </span><span class="cov8" title="1">{
                if r.Score &gt;= 4 </span><span class="cov8" title="1">{ // 4分和5分算好评
                        goodCount++
                }</span>
        }

        <span class="cov8" title="1">return float32(goodCount) / float32(len(reviews))</span>
}

// calculateAvgResponseTime 计算平均响应时间（分钟）
// 响应时间 = 订单开始时间 - 订单创建时间
func (s *PlayerService) calculateAvgResponseTime(ctx context.Context, playerID uint64) int <span class="cov8" title="1">{
        playerIDPtr := &amp;playerID
        orders, _, err := s.orders.List(ctx, repository.OrderListOptions{
                PlayerID: playerIDPtr,
                Statuses: []model.OrderStatus{
                        model.OrderStatusInProgress,
                        model.OrderStatusCompleted,
                },
                Page:     1,
                PageSize: 100, // 取最近100个订单
        })
        if err != nil || len(orders) == 0 </span><span class="cov8" title="1">{
                return 30 // 默认30分钟
        }</span>

        <span class="cov8" title="1">var totalMinutes int64
        var count int64
        for _, o := range orders </span><span class="cov8" title="1">{
                if o.StartedAt != nil </span><span class="cov8" title="1">{
                        // 计算响应时间（订单开始时间 - 创建时间）
                        responseTime := o.StartedAt.Sub(o.CreatedAt)
                        totalMinutes += int64(responseTime.Minutes())
                        count++
                }</span>
        }

        <span class="cov8" title="1">if count == 0 </span><span class="cov8" title="1">{
                return 30
        }</span>

        <span class="cov8" title="1">return int(totalMinutes / count)</span>
}

// calculateRepeatRate 计算复购率
// 复购率 = 有过多次下单的用户数 / 总用户数
func (s *PlayerService) calculateRepeatRate(ctx context.Context, playerID uint64) float32 <span class="cov8" title="1">{
        playerIDPtr := &amp;playerID
        orders, _, err := s.orders.List(ctx, repository.OrderListOptions{
                PlayerID: playerIDPtr,
                Statuses: []model.OrderStatus{model.OrderStatusCompleted},
                Page:     1,
                PageSize: 10000, // 获取所有已完成订单
        })
        if err != nil || len(orders) == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>

        // 统计每个用户的订单数
        <span class="cov8" title="1">userOrderCount := make(map[uint64]int)
        for _, o := range orders </span><span class="cov8" title="1">{
                userOrderCount[o.UserID]++
        }</span>

        // 统计有复购的用户数
        <span class="cov8" title="1">totalUsers := len(userOrderCount)
        repeatUsers := 0
        for _, count := range userOrderCount </span><span class="cov8" title="1">{
                if count &gt; 1 </span><span class="cov8" title="1">{
                        repeatUsers++
                }</span>
        }

        <span class="cov8" title="1">if totalUsers == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov8" title="1">return float32(repeatUsers) / float32(totalUsers)</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package ranking

import (
    "context"
    "errors"
    "time"

    "gamelink/internal/model"
    "gamelink/internal/repository"
    "gamelink/internal/repository/ranking"
)

var (
        // ErrNotFound 排名不存在
        ErrNotFound = repository.ErrNotFound
        // ErrValidation 表示输入校验失败
        ErrValidation = errors.New("validation failed")
)

// RankingService 排名服务
type RankingService struct {
    rankings    ranking.RankingRepository
    commissions ranking.RankingCommissionRepository
    orders      repository.OrderRepository
}

// NewRankingService 创建排名服务
func NewRankingService(
    rankings ranking.RankingRepository,
    commissions ranking.RankingCommissionRepository,
    orders repository.OrderRepository,
) *RankingService <span class="cov0" title="0">{
    return &amp;RankingService{
        rankings:    rankings,
        commissions: commissions,
        orders:      orders,
    }
}</span>

// CalculateMonthlyRankings 计算月度排名
// 注意：礼物订单不计入单量和金额排名
func (s *RankingService) CalculateMonthlyRankings(ctx context.Context, month string) error <span class="cov0" title="0">{
        // 获取该月所有已完成订单（排除礼物订单）
        monthStart, _ := time.Parse("2006-01", month)
        monthEnd := monthStart.AddDate(0, 1, 0)

        orders, _, err := s.orders.List(ctx, repository.OrderListOptions{
                DateFrom: &amp;monthStart,
                DateTo:   &amp;monthEnd,
                Statuses: []model.OrderStatus{model.OrderStatusCompleted},
                Page:     1,
                PageSize: 100000,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 按陪玩师统计（排除礼物订单）
        <span class="cov0" title="0">playerStats := make(map[uint64]*PlayerMonthStats)
        for _, order := range orders </span><span class="cov0" title="0">{
                // 跳过礼物订单（不计入排名）
                if order.IsGiftOrder() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">playerID := order.GetPlayerID()
                if playerID == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">stats, exists := playerStats[playerID]
                if !exists </span><span class="cov0" title="0">{
                        stats = &amp;PlayerMonthStats{PlayerID: playerID}
                        playerStats[playerID] = stats
                }</span>

                <span class="cov0" title="0">stats.OrderCount++
                stats.TotalIncome += order.TotalPriceCents</span>
        }

        // 按订单数量排名
        <span class="cov0" title="0">if err := s.saveOrderCountRankings(ctx, month, playerStats); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 按金额排名
        <span class="cov0" title="0">if err := s.saveIncomeRankings(ctx, month, playerStats); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PlayerMonthStats 玩家月度统计
type PlayerMonthStats struct {
        PlayerID    uint64
        OrderCount  int64
        TotalIncome int64
}

// saveOrderCountRankings 保存订单数量排名
func (s *RankingService) saveOrderCountRankings(ctx context.Context, month string, stats map[uint64]*PlayerMonthStats) error <span class="cov0" title="0">{
        // 转换为切片并排序
        players := make([]*PlayerMonthStats, 0, len(stats))
        for _, stat := range stats </span><span class="cov0" title="0">{
                players = append(players, stat)
        }</span>

        // 按订单数量排序
        <span class="cov0" title="0">sortByOrderCount(players)

        // 保存排名（只保存前20名）
        limit := 20
        if len(players) &lt; limit </span><span class="cov0" title="0">{
                limit = len(players)
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; limit; i++ </span><span class="cov0" title="0">{
                ranking := &amp;model.PlayerRanking{
                        PlayerID:    players[i].PlayerID,
                        RankingType: model.RankingTypeOrderCount,
                        Period:      "monthly",
                        PeriodValue: month,
                        Rank:        i + 1,
                        Score:       float64(players[i].OrderCount),
                        OrderCount:  players[i].OrderCount,
                }

                // 检查是否有排名奖励
                reward, _ := s.rankings.GetRewardForRank(ctx, model.RankingTypeOrderCount, "monthly", ranking.Rank)
                if reward != nil </span><span class="cov0" title="0">{
                        ranking.BonusCents = reward.RewardValue
                }</span>

                <span class="cov0" title="0">if err := s.rankings.CreateRanking(ctx, ranking); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// saveIncomeRankings 保存收入排名
func (s *RankingService) saveIncomeRankings(ctx context.Context, month string, stats map[uint64]*PlayerMonthStats) error <span class="cov0" title="0">{
        // 转换为切片并排序
        players := make([]*PlayerMonthStats, 0, len(stats))
        for _, stat := range stats </span><span class="cov0" title="0">{
                players = append(players, stat)
        }</span>

        // 按收入排序
        <span class="cov0" title="0">sortByIncome(players)

        // 保存排名（只保存前20名）
        limit := 20
        if len(players) &lt; limit </span><span class="cov0" title="0">{
                limit = len(players)
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; limit; i++ </span><span class="cov0" title="0">{
                ranking := &amp;model.PlayerRanking{
                        PlayerID:    players[i].PlayerID,
                        RankingType: model.RankingTypeIncome,
                        Period:      "monthly",
                        PeriodValue: month,
                        Rank:        i + 1,
                        Score:       float64(players[i].TotalIncome),
                        IncomeCents: players[i].TotalIncome,
                }

                // 检查是否有排名奖励
                reward, _ := s.rankings.GetRewardForRank(ctx, model.RankingTypeIncome, "monthly", ranking.Rank)
                if reward != nil </span><span class="cov0" title="0">{
                        ranking.BonusCents = reward.RewardValue
                }</span>

                <span class="cov0" title="0">if err := s.rankings.CreateRanking(ctx, ranking); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetPlayerRankingInfo 获取陪玩师排名信息（用于抽成计算）
func (s *RankingService) GetPlayerRankingInfo(ctx context.Context, playerID uint64, month string) (*PlayerRankingInfo, error) <span class="cov0" title="0">{
        rankings, _, err := s.rankings.ListRankings(ctx, ranking.RankingListOptions{
                PlayerID:    &amp;playerID,
                PeriodValue: &amp;month,
                Page:        1,
                PageSize:    10,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">info := &amp;PlayerRankingInfo{
                PlayerID: playerID,
                Month:    month,
        }

        // 查找单量排名和金额排名中最好的
        bestRank := 999
        for _, ranking := range rankings </span><span class="cov0" title="0">{
                if ranking.Rank &lt; bestRank </span><span class="cov0" title="0">{
                        bestRank = ranking.Rank
                        info.BestRank = ranking.Rank
                        info.RankingType = string(ranking.RankingType)
                }</span>
        }

        <span class="cov0" title="0">return info, nil</span>
}

// PlayerRankingInfo 玩家排名信息
type PlayerRankingInfo struct {
        PlayerID    uint64
        Month       string
        BestRank    int
        RankingType string
}

// sortByOrderCount 按订单数量排序
func sortByOrderCount(players []*PlayerMonthStats) <span class="cov0" title="0">{
        // 冒泡排序（简化实现）
        n := len(players)
        for i := 0; i &lt; n-1; i++ </span><span class="cov0" title="0">{
                for j := 0; j &lt; n-i-1; j++ </span><span class="cov0" title="0">{
                        if players[j].OrderCount &lt; players[j+1].OrderCount </span><span class="cov0" title="0">{
                                players[j], players[j+1] = players[j+1], players[j]
                        }</span>
                }
        }
}

// sortByIncome 按收入排序
func sortByIncome(players []*PlayerMonthStats) <span class="cov0" title="0">{
        // 冒泡排序（简化实现）
        n := len(players)
        for i := 0; i &lt; n-1; i++ </span><span class="cov0" title="0">{
                for j := 0; j &lt; n-i-1; j++ </span><span class="cov0" title="0">{
                        if players[j].TotalIncome &lt; players[j+1].TotalIncome </span><span class="cov0" title="0">{
                                players[j], players[j+1] = players[j+1], players[j]
                        }</span>
                }
        }
}

// CreateRankingRewardRequest 创建排名奖励规则请求
type CreateRankingRewardRequest struct {
        RankingType model.RankingType `json:"rankingType" binding:"required"`
        Period      string             `json:"period" binding:"required"`
        RankStart   int                `json:"rankStart" binding:"required,min=1"`
        RankEnd     int                `json:"rankEnd" binding:"required,min=1"`
        RewardType  string             `json:"rewardType" binding:"required,oneof=commission"`
        RewardValue int64              `json:"rewardValue" binding:"required"`
        Description string             `json:"description"`
}

// CreateRankingReward 创建排名奖励规则（管理员）
func (s *RankingService) CreateRankingReward(ctx context.Context, req CreateRankingRewardRequest) (*model.RankingReward, error) <span class="cov0" title="0">{
        reward := &amp;model.RankingReward{
                RankingType: req.RankingType,
                Period:      req.Period,
                RankStart:   req.RankStart,
                RankEnd:     req.RankEnd,
                RewardType:  req.RewardType,
                RewardValue: req.RewardValue,
                Description: req.Description,
                IsActive:    true,
        }

        if err := s.rankings.CreateReward(ctx, reward); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return reward, nil</span>
}

</pre>
		
		<pre class="file" id="file110" style="display: none">package review

import (
        "context"
        "errors"

        "gamelink/internal/model"
        "gamelink/internal/repository"
)

var (
        // ErrNotFound 评价不存在
        ErrNotFound = repository.ErrNotFound
        // ErrValidation 表示输入校验失败
        ErrValidation = errors.New("validation failed")
        // ErrAlreadyReviewed 已评价
        ErrAlreadyReviewed = errors.New("order already reviewed")
        // ErrOrderNotCompleted 订单未完成
        ErrOrderNotCompleted = errors.New("order not completed")
        // ErrUnauthorized 无权操作
        ErrUnauthorized = errors.New("unauthorized")
)

// ReviewService 评价服务
//
// 功能：
// 1. 创建评价
// 2. 查询评价列表
// 3. 更新陪玩师评分
type ReviewService struct {
        reviews repository.ReviewRepository
        orders  repository.OrderRepository
        players repository.PlayerRepository
        users   repository.UserRepository
}

// NewReviewService 创建评价服务
func NewReviewService(
        reviews repository.ReviewRepository,
        orders repository.OrderRepository,
        players repository.PlayerRepository,
        users repository.UserRepository,
) *ReviewService <span class="cov8" title="1">{
        return &amp;ReviewService{
                reviews: reviews,
                orders:  orders,
                players: players,
                users:   users,
        }
}</span>

// CreateReviewRequest 创建评价请求
type CreateReviewRequest struct {
        OrderID   uint64   `json:"orderId" binding:"required"`
        Rating    int      `json:"rating" binding:"required,min=1,max=5"`
        Comment   string   `json:"comment" binding:"max=500"`
        Tags      []string `json:"tags"`      // 评价标签
        Anonymous bool     `json:"anonymous"` // 是否匿名
}

// CreateReviewResponse 创建评价响应
type CreateReviewResponse struct {
        ReviewID uint64 `json:"reviewId"`
}

// MyReviewDTO 我的评价信息
type MyReviewDTO struct {
        ReviewDTO
        OrderTitle     string `json:"orderTitle"`
        PlayerNickname string `json:"playerNickname"`
}

// ReviewDTO 评价信息
type ReviewDTO struct {
        ID            uint64 `json:"id"`
        OrderID       uint64 `json:"orderId"`
        Rating        int    `json:"rating"`
        Comment       string `json:"comment"`
        UserNickname  string `json:"userNickname"`
        UserAvatarURL string `json:"userAvatarUrl"`
        CreatedAt     string `json:"createdAt"`
}

// MyReviewListResponse 我的评价列表响应
type MyReviewListResponse struct {
        Reviews []MyReviewDTO `json:"reviews"`
        Total   int64         `json:"total"`
}

// CreateReview 创建评价
func (s *ReviewService) CreateReview(ctx context.Context, userID uint64, req CreateReviewRequest) (*CreateReviewResponse, error) <span class="cov8" title="1">{
        // 验证订单
        order, err := s.orders.Get(ctx, req.OrderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 权限检查：只能评价自己的订单
        <span class="cov8" title="1">if order.UserID != userID </span><span class="cov8" title="1">{
                return nil, ErrUnauthorized
        }</span>

        // 状态检查：只有已完成的订单可以评价
        <span class="cov8" title="1">if order.Status != model.OrderStatusCompleted </span><span class="cov8" title="1">{
                return nil, ErrOrderNotCompleted
        }</span>

        // 检查是否已评价
        <span class="cov8" title="1">orderIDPtr := &amp;req.OrderID
        existingReviews, _, err := s.reviews.List(ctx, repository.ReviewListOptions{
                OrderID:  orderIDPtr,
                Page:     1,
                PageSize: 1,
        })
        if err == nil &amp;&amp; len(existingReviews) &gt; 0 </span><span class="cov8" title="1">{
                return nil, ErrAlreadyReviewed
        }</span>

        // 创建评价
        <span class="cov8" title="1">playerID := order.GetPlayerID()
        review := &amp;model.Review{
                OrderID:  req.OrderID,
                UserID:   userID,
                PlayerID: playerID,
                Score:    model.Rating(req.Rating),
                Content:  req.Comment,
        }

        if err := s.reviews.Create(ctx, review); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 更新陪玩师评分
        <span class="cov8" title="1">if playerID &gt; 0 </span><span class="cov8" title="1">{
                if err := s.updatePlayerRating(ctx, playerID); err != nil </span>{<span class="cov0" title="0">
                        // 更新评分失败不影响评价创建
                }</span>
        }

        <span class="cov8" title="1">return &amp;CreateReviewResponse{
                ReviewID: review.ID,
        }, nil</span>
}

// GetMyReviews 获取我的评价列表
func (s *ReviewService) GetMyReviews(ctx context.Context, userID uint64, page, pageSize int) (*MyReviewListResponse, error) <span class="cov8" title="1">{
        // 默认分页参数
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov8" title="1">if pageSize &lt; 1 || pageSize &gt; 100 </span><span class="cov0" title="0">{
                pageSize = 20
        }</span>

        // 查询评价
        <span class="cov8" title="1">userIDPtr := &amp;userID
        reviews, total, err := s.reviews.List(ctx, repository.ReviewListOptions{
                UserID:   userIDPtr,
                Page:     page,
                PageSize: pageSize,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 转换为 DTO
        <span class="cov8" title="1">myReviews := make([]MyReviewDTO, 0, len(reviews))
        for _, r := range reviews </span><span class="cov8" title="1">{
                // 获取订单信息
                order, err := s.orders.Get(ctx, r.OrderID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 获取陪玩师信息
                <span class="cov8" title="1">player, err := s.players.Get(ctx, r.PlayerID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 获取用户信息
                <span class="cov8" title="1">user, err := s.users.Get(ctx, r.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">myReviews = append(myReviews, MyReviewDTO{
                        ReviewDTO: ReviewDTO{
                                ID:            r.ID,
                                OrderID:       r.OrderID,
                                Rating:        int(r.Score),
                                Comment:       r.Content,
                                UserNickname:  user.Name,
                                UserAvatarURL: user.AvatarURL,
                                CreatedAt:     r.CreatedAt.Format("2006-01-02 15:04:05"),
                        },
                        OrderTitle:     order.Title,
                        PlayerNickname: player.Nickname,
                })</span>
        }

        <span class="cov8" title="1">return &amp;MyReviewListResponse{
                Reviews: myReviews,
                Total:   total,
        }, nil</span>
}

// GetPlayerReviews 获取陪玩师的评价列表
func (s *ReviewService) GetPlayerReviews(ctx context.Context, playerID uint64, page, pageSize int) ([]ReviewDTO, int64, error) <span class="cov8" title="1">{
        // 默认分页参数
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov8" title="1">if pageSize &lt; 1 || pageSize &gt; 100 </span><span class="cov0" title="0">{
                pageSize = 20
        }</span>

        // 查询评价
        <span class="cov8" title="1">playerIDPtr := &amp;playerID
        reviews, total, err := s.reviews.List(ctx, repository.ReviewListOptions{
                PlayerID: playerIDPtr,
                Page:     page,
                PageSize: pageSize,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 转换为 DTO
        <span class="cov8" title="1">reviewDTOs := make([]ReviewDTO, 0, len(reviews))
        for _, r := range reviews </span><span class="cov8" title="1">{
                user, err := s.users.Get(ctx, r.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">reviewDTOs = append(reviewDTOs, ReviewDTO{
                        ID:            r.ID,
                        OrderID:       r.OrderID,
                        Rating:        int(r.Score),
                        Comment:       r.Content,
                        UserNickname:  user.Name,
                        UserAvatarURL: user.AvatarURL,
                        CreatedAt:     r.CreatedAt.Format("2006-01-02 15:04:05"),
                })</span>
        }

        <span class="cov8" title="1">return reviewDTOs, total, nil</span>
}

// updatePlayerRating 更新陪玩师评分
func (s *ReviewService) updatePlayerRating(ctx context.Context, playerID uint64) error <span class="cov8" title="1">{
        // 获取陪玩师
        player, err := s.players.Get(ctx, playerID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 获取所有评价
        <span class="cov8" title="1">playerIDPtr := &amp;playerID
        reviews, _, err := s.reviews.List(ctx, repository.ReviewListOptions{
                PlayerID: playerIDPtr,
                Page:     1,
                PageSize: 10000, // 获取所有评价
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(reviews) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 计算平均评分
        <span class="cov8" title="1">var totalScore int
        for _, r := range reviews </span><span class="cov8" title="1">{
                totalScore += int(r.Score)
        }</span>

        <span class="cov8" title="1">player.RatingAverage = float32(totalScore) / float32(len(reviews))
        player.RatingCount = uint32(len(reviews))

        return s.players.Update(ctx, player)</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">package role

import (
        "context"

        "gamelink/internal/model"
        "gamelink/internal/repository"

        "github.com/stretchr/testify/mock"
)

// MockRoleRepository is a mock for RoleRepository
type MockRoleRepository struct {
        mock.Mock
}

func (m *MockRoleRepository) List(ctx context.Context) ([]model.RoleModel, error) <span class="cov0" title="0">{
        args := m.Called(ctx)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).([]model.RoleModel), args.Error(1)</span>
}

func (m *MockRoleRepository) ListPaged(ctx context.Context, page, pageSize int) ([]model.RoleModel, int64, error) <span class="cov0" title="0">{
        args := m.Called(ctx, page, pageSize)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, 0, args.Error(2)
        }</span>
        <span class="cov0" title="0">return args.Get(0).([]model.RoleModel), args.Get(1).(int64), args.Error(2)</span>
}

func (m *MockRoleRepository) ListPagedWithFilter(ctx context.Context, page, pageSize int, keyword string, isSystem *bool) ([]model.RoleModel, int64, error) <span class="cov0" title="0">{
        args := m.Called(ctx, page, pageSize, keyword, isSystem)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, 0, args.Error(2)
        }</span>
        <span class="cov0" title="0">return args.Get(0).([]model.RoleModel), args.Get(1).(int64), args.Error(2)</span>
}

func (m *MockRoleRepository) ListWithPermissions(ctx context.Context) ([]model.RoleModel, error) <span class="cov0" title="0">{
        args := m.Called(ctx)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).([]model.RoleModel), args.Error(1)</span>
}

func (m *MockRoleRepository) Get(ctx context.Context, id uint64) (*model.RoleModel, error) <span class="cov0" title="0">{
        args := m.Called(ctx, id)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*model.RoleModel), args.Error(1)</span>
}

func (m *MockRoleRepository) GetWithPermissions(ctx context.Context, id uint64) (*model.RoleModel, error) <span class="cov0" title="0">{
        args := m.Called(ctx, id)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*model.RoleModel), args.Error(1)</span>
}

func (m *MockRoleRepository) GetBySlug(ctx context.Context, slug string) (*model.RoleModel, error) <span class="cov0" title="0">{
        args := m.Called(ctx, slug)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*model.RoleModel), args.Error(1)</span>
}

func (m *MockRoleRepository) Create(ctx context.Context, role *model.RoleModel) error <span class="cov0" title="0">{
        args := m.Called(ctx, role)
        return args.Error(0)
}</span>

func (m *MockRoleRepository) Update(ctx context.Context, role *model.RoleModel) error <span class="cov0" title="0">{
        args := m.Called(ctx, role)
        return args.Error(0)
}</span>

func (m *MockRoleRepository) Delete(ctx context.Context, id uint64) error <span class="cov0" title="0">{
        args := m.Called(ctx, id)
        return args.Error(0)
}</span>

func (m *MockRoleRepository) AssignPermissions(ctx context.Context, roleID uint64, permissionIDs []uint64) error <span class="cov0" title="0">{
        args := m.Called(ctx, roleID, permissionIDs)
        return args.Error(0)
}</span>

func (m *MockRoleRepository) AddPermissions(ctx context.Context, roleID uint64, permissionIDs []uint64) error <span class="cov0" title="0">{
        args := m.Called(ctx, roleID, permissionIDs)
        return args.Error(0)
}</span>

func (m *MockRoleRepository) RemovePermissions(ctx context.Context, roleID uint64, permissionIDs []uint64) error <span class="cov0" title="0">{
        args := m.Called(ctx, roleID, permissionIDs)
        return args.Error(0)
}</span>

func (m *MockRoleRepository) AssignToUser(ctx context.Context, userID uint64, roleIDs []uint64) error <span class="cov0" title="0">{
        args := m.Called(ctx, userID, roleIDs)
        return args.Error(0)
}</span>

func (m *MockRoleRepository) RemoveFromUser(ctx context.Context, userID uint64, roleIDs []uint64) error <span class="cov0" title="0">{
        args := m.Called(ctx, userID, roleIDs)
        return args.Error(0)
}</span>

func (m *MockRoleRepository) ListByUserID(ctx context.Context, userID uint64) ([]model.RoleModel, error) <span class="cov0" title="0">{
        args := m.Called(ctx, userID)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).([]model.RoleModel), args.Error(1)</span>
}

func (m *MockRoleRepository) CheckUserHasRole(ctx context.Context, userID uint64, roleSlug string) (bool, error) <span class="cov0" title="0">{
        args := m.Called(ctx, userID, roleSlug)
        return args.Bool(0), args.Error(1)
}</span>

var _ repository.RoleRepository = (*MockRoleRepository)(nil)

</pre>
		
		<pre class="file" id="file112" style="display: none">package role

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "gamelink/internal/cache"
        "gamelink/internal/model"
        "gamelink/internal/repository"
        "gamelink/internal/service"
)

const (
        cacheKeyPermissionsByUser = "rbac:user_permissions:%d"
        cacheKeyPermissionsByRole = "rbac:role_permissions:%d"
)

var (
        ErrValidation = service.ErrValidation
        ErrNotFound   = service.ErrNotFound
)

// RoleService 提供角色管理的业务逻辑。
type RoleService struct {
        roles repository.RoleRepository
        cache cache.Cache
}

// NewRoleService 创建角色服务实例。
func NewRoleService(roles repository.RoleRepository, cache cache.Cache) *RoleService <span class="cov8" title="1">{
        return &amp;RoleService{
                roles: roles,
                cache: cache,
        }
}</span>

const (
        cacheKeyRoles       = "admin:roles"
        cacheKeyRolesByUser = "admin:roles:user:%d"
        cacheTTLRoles       = 30 * time.Minute
)

// ListRoles 获取所有角色列表。
func (s *RoleService) ListRoles(ctx context.Context) ([]model.RoleModel, error) <span class="cov8" title="1">{
        return s.roles.List(ctx)
}</span>

// ListRolesPaged 分页获取角色列表。
func (s *RoleService) ListRolesPaged(ctx context.Context, page, pageSize int) ([]model.RoleModel, int64, error) <span class="cov8" title="1">{
        if page &lt; 1 </span><span class="cov8" title="1">{
                page = 1
        }</span>
        <span class="cov8" title="1">if pageSize &lt; 1 || pageSize &gt; 100 </span><span class="cov8" title="1">{
                pageSize = 20
        }</span>
        <span class="cov8" title="1">return s.roles.ListPaged(ctx, page, pageSize)</span>
}

// ListRolesPagedWithFilter 分页获取角色列表（带过滤）。
func (s *RoleService) ListRolesPagedWithFilter(ctx context.Context, page, pageSize int, keyword string, isSystem *bool) ([]model.RoleModel, int64, error) <span class="cov8" title="1">{
        if page &lt; 1 </span><span class="cov8" title="1">{
                page = 1
        }</span>
        <span class="cov8" title="1">if pageSize &lt; 1 || pageSize &gt; 100 </span><span class="cov8" title="1">{
                pageSize = 20
        }</span>
        <span class="cov8" title="1">return s.roles.ListPagedWithFilter(ctx, page, pageSize, keyword, isSystem)</span>
}

// ListRolesWithPermissions 获取角色列表，预加载权限。
func (s *RoleService) ListRolesWithPermissions(ctx context.Context) ([]model.RoleModel, error) <span class="cov8" title="1">{
        return s.roles.ListWithPermissions(ctx)
}</span>

// GetRole 根据ID获取角色。
func (s *RoleService) GetRole(ctx context.Context, id uint64) (*model.RoleModel, error) <span class="cov8" title="1">{
        return s.roles.Get(ctx, id)
}</span>

// GetRoleWithPermissions 根据ID获取角色，预加载权限。
func (s *RoleService) GetRoleWithPermissions(ctx context.Context, id uint64) (*model.RoleModel, error) <span class="cov8" title="1">{
        return s.roles.GetWithPermissions(ctx, id)
}</span>

// GetRoleBySlug 根据Slug获取角色。
func (s *RoleService) GetRoleBySlug(ctx context.Context, slug string) (*model.RoleModel, error) <span class="cov8" title="1">{
        return s.roles.GetBySlug(ctx, slug)
}</span>

// CreateRole 创建角色。
func (s *RoleService) CreateRole(ctx context.Context, role *model.RoleModel) error <span class="cov8" title="1">{
        // 校验必填字段
        if role.Slug == "" || role.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: slug and name are required", ErrValidation)
        }</span>

        // 检查 slug 是否已存在
        <span class="cov8" title="1">existing, err := s.roles.GetBySlug(ctx, role.Slug)
        if err == nil &amp;&amp; existing != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: role with slug %s already exists", ErrValidation, role.Slug)
        }</span>

        // 创建角色
        <span class="cov8" title="1">if err := s.roles.Create(ctx, role); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 清除缓存
        <span class="cov8" title="1">s.invalidateRoleCache()
        return nil</span>
}

// UpdateRole 更新角色。
func (s *RoleService) UpdateRole(ctx context.Context, role *model.RoleModel) error <span class="cov8" title="1">{
        if role.ID == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: role ID is required", ErrValidation)
        }</span>

        // 检查是否为系统角色
        <span class="cov8" title="1">existing, err := s.roles.Get(ctx, role.ID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if existing.IsSystem </span><span class="cov8" title="1">{
                // 系统角色只允许更新描述
                existing.Description = role.Description
                role = existing
        }</span>

        <span class="cov8" title="1">if err := s.roles.Update(ctx, role); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 清除缓存
        <span class="cov8" title="1">s.invalidateRoleCache()
        return nil</span>
}

// DeleteRole 删除角色（系统角色不可删除）。
func (s *RoleService) DeleteRole(ctx context.Context, id uint64) error <span class="cov8" title="1">{
        if err := s.roles.Delete(ctx, id); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // 清除缓存
        <span class="cov8" title="1">s.invalidateRoleCache()
        return nil</span>
}

// AssignPermissionsToRole 为角色分配权限（替换现有权限）。
func (s *RoleService) AssignPermissionsToRole(ctx context.Context, roleID uint64, permissionIDs []uint64) error <span class="cov8" title="1">{
        if err := s.roles.AssignPermissions(ctx, roleID, permissionIDs); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // 清除缓存
        <span class="cov8" title="1">s.invalidateRoleCache()
        s.invalidatePermissionCacheForRole(roleID)
        return nil</span>
}

// AddPermissionsToRole 为角色添加权限（追加）。
func (s *RoleService) AddPermissionsToRole(ctx context.Context, roleID uint64, permissionIDs []uint64) error <span class="cov8" title="1">{
        if err := s.roles.AddPermissions(ctx, roleID, permissionIDs); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 清除缓存
        <span class="cov8" title="1">s.invalidateRoleCache()
        s.invalidatePermissionCacheForRole(roleID)
        return nil</span>
}

// RemovePermissionsFromRole 移除角色的权限。
func (s *RoleService) RemovePermissionsFromRole(ctx context.Context, roleID uint64, permissionIDs []uint64) error <span class="cov8" title="1">{
        if err := s.roles.RemovePermissions(ctx, roleID, permissionIDs); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 清除缓存
        <span class="cov8" title="1">s.invalidateRoleCache()
        s.invalidatePermissionCacheForRole(roleID)
        return nil</span>
}

// ListRolesByUserID 获取用户拥有的所有角色。
func (s *RoleService) ListRolesByUserID(ctx context.Context, userID uint64) ([]model.RoleModel, error) <span class="cov8" title="1">{
        cacheKey := fmt.Sprintf(cacheKeyRolesByUser, userID)

        // 尝试从缓存获取
        if value, ok, err := s.cache.Get(ctx, cacheKey); err == nil &amp;&amp; ok </span><span class="cov8" title="1">{
                var roles []model.RoleModel
                if err := json.Unmarshal([]byte(value), &amp;roles); err == nil </span><span class="cov8" title="1">{
                        return roles, nil
                }</span>
        }

        // 从数据库获取
        <span class="cov8" title="1">roles, err := s.roles.ListByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 写入缓存
        <span class="cov8" title="1">if data, err := json.Marshal(roles); err == nil </span><span class="cov8" title="1">{
                _ = s.cache.Set(ctx, cacheKey, string(data), cacheTTLRoles)
        }</span>
        <span class="cov8" title="1">return roles, nil</span>
}

// AssignRolesToUser 为用户分配角色（替换现有角色）。
func (s *RoleService) AssignRolesToUser(ctx context.Context, userID uint64, roleIDs []uint64) error <span class="cov8" title="1">{
        if err := s.roles.AssignToUser(ctx, userID, roleIDs); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // 清除缓存
        <span class="cov8" title="1">s.invalidateUserRoleCache(userID)
        return nil</span>
}

// RemoveRolesFromUser 移除用户的角色。
func (s *RoleService) RemoveRolesFromUser(ctx context.Context, userID uint64, roleIDs []uint64) error <span class="cov8" title="1">{
        if err := s.roles.RemoveFromUser(ctx, userID, roleIDs); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 清除缓存
        <span class="cov8" title="1">s.invalidateUserRoleCache(userID)
        return nil</span>
}

// CheckUserHasRole 检查用户是否拥有指定角色。
func (s *RoleService) CheckUserHasRole(ctx context.Context, userID uint64, roleSlug string) (bool, error) <span class="cov8" title="1">{
        return s.roles.CheckUserHasRole(ctx, userID, roleSlug)
}</span>

// CheckUserIsSuperAdmin 检查用户是否为超级管理员。
func (s *RoleService) CheckUserIsSuperAdmin(ctx context.Context, userID uint64) (bool, error) <span class="cov8" title="1">{
        return s.roles.CheckUserHasRole(ctx, userID, string(model.RoleSlugSuperAdmin))
}</span>

// invalidateRoleCache 清除角色相关缓存。
func (s *RoleService) invalidateRoleCache() <span class="cov8" title="1">{
        ctx := context.Background()
        _ = s.cache.Delete(ctx, cacheKeyRoles)
}</span>

// invalidateUserRoleCache 清除用户角色缓存。
func (s *RoleService) invalidateUserRoleCache(userID uint64) <span class="cov8" title="1">{
        ctx := context.Background()
        cacheKey := fmt.Sprintf(cacheKeyRolesByUser, userID)
        _ = s.cache.Delete(ctx, cacheKey)

        // 同时清除用户权限缓存
        permCacheKey := fmt.Sprintf(cacheKeyPermissionsByUser, userID)
        _ = s.cache.Delete(ctx, permCacheKey)
}</span>

// invalidatePermissionCacheForRole 清除角色权限缓存。
func (s *RoleService) invalidatePermissionCacheForRole(roleID uint64) <span class="cov8" title="1">{
        ctx := context.Background()
        cacheKey := fmt.Sprintf(cacheKeyPermissionsByRole, roleID)
        _ = s.cache.Delete(ctx, cacheKey)
}</span>
</pre>
		
		<pre class="file" id="file113" style="display: none">package stats

import (
    "context"
    "time"

    "gamelink/internal/repository"
)

// StatsService 聚合统计查询。
type StatsService struct {
    repo repository.StatsRepository
}

func NewStatsService(repo repository.StatsRepository) *StatsService <span class="cov8" title="1">{ return &amp;StatsService{repo: repo} }</span>

func (s *StatsService) Dashboard(ctx context.Context) (repository.Dashboard, error) <span class="cov8" title="1">{
    return s.repo.Dashboard(ctx)
}</span>

func (s *StatsService) RevenueTrend(ctx context.Context, days int) ([]repository.DateValue, error) <span class="cov8" title="1">{
    return s.repo.RevenueTrend(ctx, days)
}</span>

func (s *StatsService) UserGrowth(ctx context.Context, days int) ([]repository.DateValue, error) <span class="cov8" title="1">{
    return s.repo.UserGrowth(ctx, days)
}</span>

func (s *StatsService) OrdersByStatus(ctx context.Context) (map[string]int64, error) <span class="cov8" title="1">{
    return s.repo.OrdersByStatus(ctx)
}</span>

func (s *StatsService) TopPlayers(ctx context.Context, limit int) ([]repository.PlayerTop, error) <span class="cov8" title="1">{
    return s.repo.TopPlayers(ctx, limit)
}</span>

// AuditOverview returns counts grouped by entity and action within a time window.
func (s *StatsService) AuditOverview(ctx context.Context, from, to *time.Time) (map[string]int64, map[string]int64, error) <span class="cov8" title="1">{
    return s.repo.AuditOverview(ctx, from, to)
}</span>

// AuditTrend returns daily counts filtered by time and optional entity/action.
func (s *StatsService) AuditTrend(ctx context.Context, from, to *time.Time, entity, action string) ([]repository.DateValue, error) <span class="cov8" title="1">{
    return s.repo.AuditTrend(ctx, from, to, entity, action)
}</span>

</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
